class YZ_CLAS_MDG_UTILITY definition
  public
  abstract
  create public .

public section.

  interfaces IF_USMD_CR_MASTER .
  interfaces IF_DRF_CONST .
  interfaces IF_EHFND_UI_CONSTANTS_C .
  interfaces IF_FPM_CONSTANTS .
  interfaces IF_MDG_CONSTANTS .
  interfaces IF_MDG_IDSC_CONST .
  interfaces IF_MDG_OTC_CONST .
  interfaces IF_USMD_CR_CONSTANTS .
  interfaces IF_USMD_SEARCH_CONSTANTS .
  interfaces IF_XO_CONST_MESSAGE .
  interfaces YZ_INTF_MDG_CONST_EXT .
  interfaces YZ_INTF_MDG_CONST .
  interfaces YZ_INTF_MDG_UTILITY_CONST .
  interfaces YZ_INTF_MDG_DATA_TYPES .
  interfaces YZ_INTF_USMD_PP_HANA_SEARCH .

  aliases ACCOUNTASSIGNMENTCATEGORYCODE
    for IF_MDG_OTC_CONST~ACCOUNTASSIGNMENTCATEGORYCODE .
  aliases ACCOUNTASSIGNMENTCATEGORY_ID
    for IF_MDG_IDSC_CONST~ACCOUNTASSIGNMENTCATEGORY_ID .
  aliases ACTION_DEQUEUE
    for IF_DRF_CONST~ACTION_DEQUEUE .
  aliases ACTION_ENQUEUE
    for IF_DRF_CONST~ACTION_ENQUEUE .
  aliases ACTION_TYPE_ADD
    for IF_DRF_CONST~ACTION_TYPE_ADD .
  aliases ACTION_TYPE_CHANGE
    for IF_DRF_CONST~ACTION_TYPE_CHANGE .
  aliases ACTION_TYPE_DELETE
    for IF_DRF_CONST~ACTION_TYPE_DELETE .
  aliases ACTIVATION_FUNCTIONS
    for IF_DRF_CONST~ACTIVATION_FUNCTIONS .
  aliases ADDRESS
    for IF_MDG_OTC_CONST~ADDRESS .
  aliases ALTERNATE_FUNCTIONS
    for IF_DRF_CONST~ALTERNATE_FUNCTIONS .
  aliases ALV_SEL_MODE_A
    for IF_DRF_CONST~ALV_SEL_MODE_A .
  aliases ANSWER_CANCELED
    for IF_DRF_CONST~ANSWER_CANCELED .
  aliases ANSWER_NO
    for IF_DRF_CONST~ANSWER_NO .
  aliases ANSWER_YES
    for IF_DRF_CONST~ANSWER_YES .
  aliases APPLICATION_JOB_LOG
    for IF_MDG_OTC_CONST~APPLICATION_JOB_LOG .
  aliases APPLICATION_JOB_LOG_KEY
    for IF_MDG_IDSC_CONST~APPLICATION_JOB_LOG_KEY .
  aliases APPL_LOG_CTXTOBJ_BAL
    for IF_DRF_CONST~APPL_LOG_CTXTOBJ_BAL .
  aliases APPL_LOG_CTXTOBJ_FILTCRIT
    for IF_DRF_CONST~APPL_LOG_CTXTOBJ_FILTCRIT .
  aliases APPL_LOG_CTXTOBJ_HEADER
    for IF_DRF_CONST~APPL_LOG_CTXTOBJ_HEADER .
  aliases APPL_LOG_CTXTOBJ_IDOC
    for IF_DRF_CONST~APPL_LOG_CTXTOBJ_IDOC .
  aliases APPL_LOG_CTXTOBJ_OBJLOG
    for IF_DRF_CONST~APPL_LOG_CTXTOBJ_OBJLOG .
  aliases APPL_LOG_CTXTOBJ_XIMSG
    for IF_DRF_CONST~APPL_LOG_CTXTOBJ_XIMSG .
  aliases APPL_LOG_FM_DETAIL_CALLBACK
    for IF_DRF_CONST~APPL_LOG_FM_DETAIL_CALLBACK .
  aliases APPL_LOG_FM_TYPE
    for IF_DRF_CONST~APPL_LOG_FM_TYPE .
  aliases APPL_LOG_FM_UCBF_CALLBACK
    for IF_DRF_CONST~APPL_LOG_FM_UCBF_CALLBACK .
  aliases APPL_LOG_OBJECT
    for IF_DRF_CONST~APPL_LOG_OBJECT .
  aliases APPL_LOG_PARNAME_APPL
    for IF_DRF_CONST~APPL_LOG_PARNAME_APPL .
  aliases APPL_LOG_PARNAME_BALHANDLE
    for IF_DRF_CONST~APPL_LOG_PARNAME_BALHANDLE .
  aliases APPL_LOG_PARNAME_BUSSYS
    for IF_DRF_CONST~APPL_LOG_PARNAME_BUSSYS .
  aliases APPL_LOG_PARNAME_FOBJ
    for IF_DRF_CONST~APPL_LOG_PARNAME_FOBJ .
  aliases APPL_LOG_PARNAME_IDOC
    for IF_DRF_CONST~APPL_LOG_PARNAME_IDOC .
  aliases APPL_LOG_PARNAME_LOG_COUNTER
    for IF_DRF_CONST~APPL_LOG_PARNAME_LOG_COUNTER .
  aliases APPL_LOG_PARNAME_OUTB_IMPL
    for IF_DRF_CONST~APPL_LOG_PARNAME_OUTB_IMPL .
  aliases APPL_LOG_PARNAME_RECOVER
    for IF_DRF_CONST~APPL_LOG_PARNAME_RECOVER .
  aliases APPL_LOG_PARNAME_RUNID
    for IF_DRF_CONST~APPL_LOG_PARNAME_RUNID .
  aliases APPL_LOG_PARNAME_START_DATE
    for IF_DRF_CONST~APPL_LOG_PARNAME_START_DATE .
  aliases APPL_LOG_PARNAME_START_TIME
    for IF_DRF_CONST~APPL_LOG_PARNAME_START_TIME .
  aliases APPL_LOG_PARNAME_STRUC_CNTXT
    for IF_DRF_CONST~APPL_LOG_PARNAME_STRUC_CNTXT .
  aliases APPL_LOG_PARNAME_TYPE
    for IF_DRF_CONST~APPL_LOG_PARNAME_TYPE .
  aliases APPL_LOG_PARNAME_XIMSG
    for IF_DRF_CONST~APPL_LOG_PARNAME_XIMSG .
  aliases APPL_LOG_SUBOBJECT_ADHOC
    for IF_DRF_CONST~APPL_LOG_SUBOBJECT_ADHOC .
  aliases APPL_LOG_SUBOBJECT_CHANGES
    for IF_DRF_CONST~APPL_LOG_SUBOBJECT_CHANGES .
  aliases APPL_LOG_SUBOBJECT_DIRECTLY
    for IF_DRF_CONST~APPL_LOG_SUBOBJECT_DIRECTLY .
  aliases APPL_LOG_SUBOBJECT_INIT
    for IF_DRF_CONST~APPL_LOG_SUBOBJECT_INIT .
  aliases APPL_LOG_SUBOBJECT_ONLINE
    for IF_DRF_CONST~APPL_LOG_SUBOBJECT_ONLINE .
  aliases APPL_POWL
    for IF_DRF_CONST~APPL_POWL .
  aliases APP_PARAM_LOG_TYPE
    for IF_DRF_CONST~APP_PARAM_LOG_TYPE .
  aliases ASTERISK
    for IF_DRF_CONST~ASTERISK .
  aliases AUDIT_CNF_SUCCESS
    for IF_DRF_CONST~AUDIT_CNF_SUCCESS .
  aliases AUTH_DELETE_FILTER
    for IF_DRF_CONST~AUTH_DELETE_FILTER .
  aliases AUTH_DISPLAY_FILTER
    for IF_DRF_CONST~AUTH_DISPLAY_FILTER .
  aliases AUTH_INIT
    for IF_DRF_CONST~AUTH_INIT .
  aliases AUTH_MAIN_FILTER
    for IF_DRF_CONST~AUTH_MAIN_FILTER .
  aliases AUTH_MANUAL
    for IF_DRF_CONST~AUTH_MANUAL .
  aliases AUTH_OVERRIDE
    for IF_DRF_CONST~AUTH_OVERRIDE .
  aliases AUTH_RECEIVING_SYSTEM
    for IF_DRF_CONST~AUTH_RECEIVING_SYSTEM .
  aliases AUTH_REORG
    for IF_DRF_CONST~AUTH_REORG .
  aliases AUTH_SUPPORT_USER
    for IF_DRF_CONST~AUTH_SUPPORT_USER .
  aliases BALHDR_CONTEXT_STRUCNAME
    for IF_DRF_CONST~BALHDR_CONTEXT_STRUCNAME .
  aliases BALHDR_TEXTS_STRUCNAME
    for IF_DRF_CONST~BALHDR_TEXTS_STRUCNAME .
  aliases BALLOGMODE_ALL
    for IF_DRF_CONST~BALLOGMODE_ALL .
  aliases BALLOGMODE_NO_OUTB_IMPL
    for IF_DRF_CONST~BALLOGMODE_NO_OUTB_IMPL .
  aliases BALLOGMODE_ONLY_OUTB_IMPL
    for IF_DRF_CONST~BALLOGMODE_ONLY_OUTB_IMPL .
  aliases BANK
    for IF_MDG_OTC_CONST~BANK .
  aliases BANK_ID
    for IF_MDG_IDSC_CONST~BANK_ID .
  aliases BATCH
    for IF_MDG_OTC_CONST~BATCH .
  aliases BATCH_KEY
    for IF_MDG_IDSC_CONST~BATCH_KEY .
  aliases BILL_OF_MATERIAL
    for IF_MDG_OTC_CONST~BILL_OF_MATERIAL .
  aliases BILL_OF_MATERIAL_GENERIC
    for IF_MDG_OTC_CONST~BILL_OF_MATERIAL_GENERIC .
  aliases BILL_OF_MATERIAL_ID
    for IF_MDG_IDSC_CONST~BILL_OF_MATERIAL_ID .
  aliases BILL_OF_MATERIAL_ID_GENERIC
    for IF_MDG_IDSC_CONST~BILL_OF_MATERIAL_ID_GENERIC .
  aliases BILL_OF_MATERIAL_INTERNAL_ID
    for IF_MDG_IDSC_CONST~BILL_OF_MATERIAL_INTERNAL_ID .
  aliases BLANK
    for IF_DRF_CONST~BLANK .
  aliases BO_POWL
    for IF_DRF_CONST~BO_POWL .
  aliases BO_SAP_MAX
    for IF_DRF_CONST~BO_SAP_MAX .
  aliases BO_SAP_MIN
    for IF_DRF_CONST~BO_SAP_MIN .
  aliases BPARTNER
    for IF_MDG_OTC_CONST~BPARTNER .
  aliases BPARTNER_EXT_ID
    for IF_MDG_IDSC_CONST~BPARTNER_EXT_ID .
  aliases BPARTNER_NR
    for IF_MDG_IDSC_CONST~BPARTNER_NR .
  aliases BPARTNER_PLANT_ID
    for IF_MDG_IDSC_CONST~BPARTNER_PLANT_ID .
  aliases BPARTNER_RELATIONSHIP
    for IF_MDG_OTC_CONST~BPARTNER_RELATIONSHIP .
  aliases BPARTNER_RELATIONSHIP_CAT_ID
    for IF_MDG_IDSC_CONST~BPARTNER_RELATIONSHIP_CAT_ID .
  aliases BPARTNER_UUID
    for IF_MDG_IDSC_CONST~BPARTNER_UUID .
  aliases BP_RELSHIP_PROCESS_CTRL
    for IF_MDG_OTC_CONST~BP_RELSHIP_PROCESS_CTRL .
  aliases BT
    for IF_DRF_CONST~BT .
  aliases BUDGET_PERIOD
    for IF_MDG_OTC_CONST~BUDGET_PERIOD .
  aliases BUDGET_PERIOD_ID
    for IF_MDG_IDSC_CONST~BUDGET_PERIOD_ID .
  aliases BUPA_RELSHIP_PROCCTRL_ID
    for IF_MDG_IDSC_CONST~BUPA_RELSHIP_PROCCTRL_ID .
  aliases BUS_SYS
    for IF_DRF_CONST~BUS_SYS .
  aliases CASHDISCOUNTTERMS
    for IF_MDG_OTC_CONST~CASHDISCOUNTTERMS .
  aliases CASHDISCOUNTTERMS_ID
    for IF_MDG_IDSC_CONST~CASHDISCOUNTTERMS_ID .
  aliases CCMS_FAIL_FLAG
    for IF_DRF_CONST~CCMS_FAIL_FLAG .
  aliases CCMS_FAIL_TXT
    for IF_DRF_CONST~CCMS_FAIL_TXT .
  aliases CCMS_INFO_TXT
    for IF_DRF_CONST~CCMS_INFO_TXT .
  aliases CCMS_SUCCESS_FLAG
    for IF_DRF_CONST~CCMS_SUCCESS_FLAG .
  aliases CCMS_SUCCESS_TXT
    for IF_DRF_CONST~CCMS_SUCCESS_TXT .
  aliases CHANGE
    for IF_DRF_CONST~CHANGE .
  aliases CHART_OF_ACCOUNTS
    for IF_MDG_OTC_CONST~CHART_OF_ACCOUNTS .
  aliases CLOSE
    for IF_DRF_CONST~CLOSE .
  aliases CLOSE_B
    for IF_DRF_CONST~CLOSE_B .
  aliases CLOSE_D
    for IF_DRF_CONST~CLOSE_D .
  aliases COLON
    for IF_DRF_CONST~COLON .
  aliases COMPANY
    for IF_MDG_OTC_CONST~COMPANY .
  aliases COMPANYCODE
    for IF_MDG_OTC_CONST~COMPANYCODE .
  aliases COMPANYCODE_ID
    for IF_MDG_IDSC_CONST~COMPANYCODE_ID .
  aliases COMPANYCODE_UUID
    for IF_MDG_IDSC_CONST~COMPANYCODE_UUID .
  aliases COMPANY_ID
    for IF_MDG_IDSC_CONST~COMPANY_ID .
  aliases COM_CHANNEL_FILE
    for IF_DRF_CONST~COM_CHANNEL_FILE .
  aliases COM_CHANNEL_IDOC
    for IF_DRF_CONST~COM_CHANNEL_IDOC .
  aliases COM_CHANNEL_RFC
    for IF_DRF_CONST~COM_CHANNEL_RFC .
  aliases COM_CHANNEL_SERVICE
    for IF_DRF_CONST~COM_CHANNEL_SERVICE .
  aliases COM_CHANNEL_UPS
    for IF_DRF_CONST~COM_CHANNEL_UPS .
  aliases CONDITION_RECORD
    for IF_MDG_OTC_CONST~CONDITION_RECORD .
  aliases CONDITION_RECORD_ID
    for IF_MDG_IDSC_CONST~CONDITION_RECORD_ID .
  aliases COND_CHG_PT_BY_CDOBJID
    for IF_DRF_CONST~COND_CHG_PT_BY_CDOBJID .
  aliases COND_CHG_PT_BY_TABKEY
    for IF_DRF_CONST~COND_CHG_PT_BY_TABKEY .
  aliases COND_CHG_PT_BY_TABKEY_CDOBJID
    for IF_DRF_CONST~COND_CHG_PT_BY_TABKEY_CDOBJID .
  aliases CONTRACT_ACCOUNT
    for IF_MDG_OTC_CONST~CONTRACT_ACCOUNT .
  aliases CONTRACT_ACCOUNT_ID
    for IF_MDG_IDSC_CONST~CONTRACT_ACCOUNT_ID .
  aliases COPY
    for IF_DRF_CONST~COPY .
  aliases COST_CENTRE
    for IF_MDG_OTC_CONST~COST_CENTRE .
  aliases COST_CENTRE_GROUP
    for IF_MDG_OTC_CONST~COST_CENTRE_GROUP .
  aliases COST_CENTRE_GROUP_HIERARCHY_ID
    for IF_MDG_IDSC_CONST~COST_CENTRE_GROUP_HIERARCHY_ID .
  aliases COST_CENTRE_GROUP_ID
    for IF_MDG_IDSC_CONST~COST_CENTRE_GROUP_ID .
  aliases COST_CENTRE_GRP_HIERARCHY
    for IF_MDG_OTC_CONST~COST_CENTRE_GRP_HIERARCHY .
  aliases COST_CENTRE_ID
    for IF_MDG_IDSC_CONST~COST_CENTRE_ID .
  aliases COST_ELEMENT
    for IF_MDG_OTC_CONST~COST_ELEMENT .
  aliases COST_ELEMENT_GROUP
    for IF_MDG_OTC_CONST~COST_ELEMENT_GROUP .
  aliases COST_ELEMENT_GRP_HIERARCHY
    for IF_MDG_OTC_CONST~COST_ELEMENT_GRP_HIERARCHY .
  aliases COST_ELEMENT_GRP_HIERARCHY_ID
    for IF_MDG_IDSC_CONST~COST_ELEMENT_GRP_HIERARCHY_ID .
  aliases COST_ELEMENT_GRP_ID
    for IF_MDG_IDSC_CONST~COST_ELEMENT_GRP_ID .
  aliases COST_ELEMENT_ID
    for IF_MDG_IDSC_CONST~COST_ELEMENT_ID .
  aliases CO_CRUD
    for IF_USMD_CR_CONSTANTS~CO_CRUD .
  aliases CO_EVENT_EXT_XML
    for IF_MDG_CONSTANTS~CO_EVENT_EXT_XML .
  aliases CO_EVNT_INP_ADDRESS_HEADER
    for IF_MDG_CONSTANTS~CO_EVNT_INP_ADDRESS_HEADER .
  aliases CO_EVNT_INP_ADDR_REMARK
    for IF_MDG_CONSTANTS~CO_EVNT_INP_ADDR_REMARK .
  aliases CO_EVNT_INP_ADDR_USAGE
    for IF_MDG_CONSTANTS~CO_EVNT_INP_ADDR_USAGE .
  aliases CO_EVNT_INP_BANKDETAILS
    for IF_MDG_CONSTANTS~CO_EVNT_INP_BANKDETAILS .
  aliases CO_EVNT_INP_COMMON
    for IF_MDG_CONSTANTS~CO_EVNT_INP_COMMON .
  aliases CO_EVNT_INP_COMM_PREFERENCE
    for IF_MDG_CONSTANTS~CO_EVNT_INP_COMM_PREFERENCE .
  aliases CO_EVNT_INP_CP_COMMON
    for IF_MDG_CONSTANTS~CO_EVNT_INP_CP_COMMON .
  aliases CO_EVNT_INP_CP_HEADER
    for IF_MDG_CONSTANTS~CO_EVNT_INP_CP_HEADER .
  aliases CO_EVNT_INP_CP_PHONE_REMARK
    for IF_MDG_CONSTANTS~CO_EVNT_INP_CP_PHONE_REMARK .
  aliases CO_EVNT_INP_EMAIL
    for IF_MDG_CONSTANTS~CO_EVNT_INP_EMAIL .
  aliases CO_EVNT_INP_EMAIL_REMARK
    for IF_MDG_CONSTANTS~CO_EVNT_INP_EMAIL_REMARK .
  aliases CO_EVNT_INP_EMAIL_USAGE
    for IF_MDG_CONSTANTS~CO_EVNT_INP_EMAIL_USAGE .
  aliases CO_EVNT_INP_FAX
    for IF_MDG_CONSTANTS~CO_EVNT_INP_FAX .
  aliases CO_EVNT_INP_FAX_REMARK
    for IF_MDG_CONSTANTS~CO_EVNT_INP_FAX_REMARK .
  aliases CO_EVNT_INP_FAX_USAGE
    for IF_MDG_CONSTANTS~CO_EVNT_INP_FAX_USAGE .
  aliases CO_EVNT_INP_HEADER
    for IF_MDG_CONSTANTS~CO_EVNT_INP_HEADER .
  aliases CO_EVNT_INP_IDENTIFICATION
    for IF_MDG_CONSTANTS~CO_EVNT_INP_IDENTIFICATION .
  aliases CO_EVNT_INP_INDUSTRY
    for IF_MDG_CONSTANTS~CO_EVNT_INP_INDUSTRY .
  aliases CO_EVNT_INP_OPERATING_HOURS
    for IF_MDG_CONSTANTS~CO_EVNT_INP_OPERATING_HOURS .
  aliases CO_EVNT_INP_PHONE
    for IF_MDG_CONSTANTS~CO_EVNT_INP_PHONE .
  aliases CO_EVNT_INP_PHONE_REMARK
    for IF_MDG_CONSTANTS~CO_EVNT_INP_PHONE_REMARK .
  aliases CO_EVNT_INP_PHONE_USAGE
    for IF_MDG_CONSTANTS~CO_EVNT_INP_PHONE_USAGE .
  aliases CO_EVNT_INP_POSTAL_ADDRESS
    for IF_MDG_CONSTANTS~CO_EVNT_INP_POSTAL_ADDRESS .
  aliases CO_EVNT_INP_QMSYSTEM
    for IF_MDG_CONSTANTS~CO_EVNT_INP_QMSYSTEM .
  aliases CO_EVNT_INP_RS_CENTRAL_DATA
    for IF_MDG_CONSTANTS~CO_EVNT_INP_RS_CENTRAL_DATA .
  aliases CO_EVNT_INP_STATUS
    for IF_MDG_CONSTANTS~CO_EVNT_INP_STATUS .
  aliases CO_EVNT_INP_TAX
    for IF_MDG_CONSTANTS~CO_EVNT_INP_TAX .
  aliases CO_EVNT_INP_WEB
    for IF_MDG_CONSTANTS~CO_EVNT_INP_WEB .
  aliases CO_EVNT_INP_WEB_REMARK
    for IF_MDG_CONSTANTS~CO_EVNT_INP_WEB_REMARK .
  aliases CO_EVNT_INP_WEB_USAGE
    for IF_MDG_CONSTANTS~CO_EVNT_INP_WEB_USAGE .
  aliases CO_NODE_NAME
    for IF_USMD_CR_CONSTANTS~CO_NODE_NAME .
  aliases CO_NO_SMT_CONTEXT
    for IF_MDG_CONSTANTS~CO_NO_SMT_CONTEXT .
  aliases CO_SMT_APPLICATION
    for IF_MDG_CONSTANTS~CO_SMT_APPLICATION .
  aliases CREQUEST_STATUS
    for IF_USMD_CR_CONSTANTS~CREQUEST_STATUS .
  aliases CURRENCYCODE
    for IF_MDG_OTC_CONST~CURRENCYCODE .
  aliases CURRENCYCODE_ID
    for IF_MDG_IDSC_CONST~CURRENCYCODE_ID .
  aliases CURRENCYCONVERSIONKEY
    for IF_MDG_OTC_CONST~CURRENCYCONVERSIONKEY .
  aliases CURRENCYCONVERSIONKEY_ID
    for IF_MDG_IDSC_CONST~CURRENCYCONVERSIONKEY_ID .
  aliases CUSTOMER
    for IF_MDG_OTC_CONST~CUSTOMER .
  aliases CUSTOMER_HIERARCHY
    for IF_MDG_OTC_CONST~CUSTOMER_HIERARCHY .
  aliases CUSTOMER_HIERARCHY_ID
    for IF_MDG_IDSC_CONST~CUSTOMER_HIERARCHY_ID .
  aliases CUSTOMER_ID
    for IF_MDG_IDSC_CONST~CUSTOMER_ID .
  aliases CUSTOMER_RETURN
    for IF_MDG_OTC_CONST~CUSTOMER_RETURN .
  aliases CUSTOMER_RETURN_KEY
    for IF_MDG_IDSC_CONST~CUSTOMER_RETURN_KEY .
  aliases CV_ACTION_ACTIVATE
    for IF_USMD_CR_MASTER~CV_ACTION_ACTIVATE .
  aliases CV_ACTION_APPROVE
    for IF_USMD_CR_MASTER~CV_ACTION_APPROVE .
  aliases CV_ACTION_AVAILABLE_WITEMS
    for IF_USMD_CR_MASTER~CV_ACTION_AVAILABLE_WITEMS .
  aliases CV_ACTION_CHANGE_DOCUMENTS
    for IF_USMD_CR_MASTER~CV_ACTION_CHANGE_DOCUMENTS .
  aliases CV_ACTION_CHECK
    for IF_USMD_CR_MASTER~CV_ACTION_CHECK .
  aliases CV_ACTION_CRUIBB_REFRESH
    for IF_USMD_CR_MASTER~CV_ACTION_CRUIBB_REFRESH .
  aliases CV_ACTION_CR_EDIT
    for IF_USMD_CR_MASTER~CV_ACTION_CR_EDIT .
  aliases CV_ACTION_DELETE_DRAFT
    for IF_USMD_CR_MASTER~CV_ACTION_DELETE_DRAFT .
  aliases CV_ACTION_DELETE_DRAFT_HANDLER
    for IF_USMD_CR_MASTER~CV_ACTION_DELETE_DRAFT_HANDLER .
  aliases CV_ACTION_FINPROC
    for IF_USMD_CR_MASTER~CV_ACTION_FINPROC .
  aliases CV_ACTION_RECALL
    for IF_USMD_CR_MASTER~CV_ACTION_RECALL .
  aliases CV_ACTION_REFRESH
    for IF_USMD_CR_MASTER~CV_ACTION_REFRESH .
  aliases CV_ACTION_REJECT
    for IF_USMD_CR_MASTER~CV_ACTION_REJECT .
  aliases CV_ACTION_REQAGAIN
    for IF_USMD_CR_MASTER~CV_ACTION_REQAGAIN .
  aliases CV_ACTION_REWORK
    for IF_USMD_CR_MASTER~CV_ACTION_REWORK .
  aliases CV_ACTION_SAVE
    for IF_USMD_CR_MASTER~CV_ACTION_SAVE .
  aliases CV_ACTION_SENDFREV
    for IF_USMD_CR_MASTER~CV_ACTION_SENDFREV .
  aliases CV_ACTION_SUBMIT
    for IF_USMD_CR_MASTER~CV_ACTION_SUBMIT .
  aliases CV_ACTION_UNDO
    for IF_USMD_CR_MASTER~CV_ACTION_UNDO .
  aliases CV_ACTION_VALIDATE
    for IF_USMD_CR_MASTER~CV_ACTION_VALIDATE .
  aliases CV_ACTION_VAL_LOG
    for IF_USMD_CR_MASTER~CV_ACTION_VAL_LOG .
  aliases CV_ACTION_WORKFLOW_LOG
    for IF_USMD_CR_MASTER~CV_ACTION_WORKFLOW_LOG .
  aliases CV_CR_CHECK_BY_BUTTON
    for IF_USMD_CR_MASTER~CV_CR_CHECK_BY_BUTTON .
  aliases CV_EVENT_ID_ERASE_FINALIZE
    for IF_USMD_CR_MASTER~CV_EVENT_ID_ERASE_FINALIZE .
  aliases CV_EVENT_ID_RESUME_REJECT
    for IF_USMD_CR_MASTER~CV_EVENT_ID_RESUME_REJECT .
  aliases CX_PROXY_BADI_PROCESSING
    for IF_DRF_CONST~CX_PROXY_BADI_PROCESSING .
  aliases C_ACTION_CODE_SAVE
    for IF_MDG_CONSTANTS~C_ACTION_CODE_SAVE .
  aliases C_FALSE
    for IF_MDG_CONSTANTS~C_FALSE .
  aliases C_LOG_HIGH
    for IF_MDG_CONSTANTS~C_LOG_HIGH .
  aliases C_LOG_LOW
    for IF_MDG_CONSTANTS~C_LOG_LOW .
  aliases C_LOG_MEDIUM
    for IF_MDG_CONSTANTS~C_LOG_MEDIUM .
  aliases C_LOG_NONE
    for IF_MDG_CONSTANTS~C_LOG_NONE .
  aliases C_LOG_VERY_HIGH
    for IF_MDG_CONSTANTS~C_LOG_VERY_HIGH .
  aliases C_MDG_NAMESPACE_URI
    for IF_MDG_CONSTANTS~C_MDG_NAMESPACE_URI .
  aliases C_MDG_SUPPLIER_BULK_TAG
    for IF_MDG_CONSTANTS~C_MDG_SUPPLIER_BULK_TAG .
  aliases C_MDG_SUPPLIER_SINGLE_TAG
    for IF_MDG_CONSTANTS~C_MDG_SUPPLIER_SINGLE_TAG .
  aliases C_MSGID
    for IF_MDG_CONSTANTS~C_MSGID .
  aliases C_MSGTYPE_ERROR
    for IF_MDG_CONSTANTS~C_MSGTYPE_ERROR .
  aliases C_MSGTYPE_INFO
    for IF_MDG_CONSTANTS~C_MSGTYPE_INFO .
  aliases C_MSGTYPE_WARNING
    for IF_MDG_CONSTANTS~C_MSGTYPE_WARNING .
  aliases C_NO
    for IF_MDG_CONSTANTS~C_NO .
  aliases C_OFF
    for IF_MDG_CONSTANTS~C_OFF .
  aliases C_ON
    for IF_MDG_CONSTANTS~C_ON .
  aliases C_SELCRIT_PARAM
    for IF_MDG_CONSTANTS~C_SELCRIT_PARAM .
  aliases C_SELCRIT_SELECT
    for IF_MDG_CONSTANTS~C_SELCRIT_SELECT .
  aliases C_SELTYPE_INTER
    for IF_MDG_CONSTANTS~C_SELTYPE_INTER .
  aliases C_SELTYPE_MULT
    for IF_MDG_CONSTANTS~C_SELTYPE_MULT .
  aliases C_SEL_BETWEEN
    for IF_MDG_CONSTANTS~C_SEL_BETWEEN .
  aliases C_SEL_EQUAL
    for IF_MDG_CONSTANTS~C_SEL_EQUAL .
  aliases C_SEL_EXCL
    for IF_MDG_CONSTANTS~C_SEL_EXCL .
  aliases C_SEL_GREATER
    for IF_MDG_CONSTANTS~C_SEL_GREATER .
  aliases C_SEL_GREATEREQUAL
    for IF_MDG_CONSTANTS~C_SEL_GREATEREQUAL .
  aliases C_SEL_INCL
    for IF_MDG_CONSTANTS~C_SEL_INCL .
  aliases C_SEL_LESS
    for IF_MDG_CONSTANTS~C_SEL_LESS .
  aliases C_SEL_LESSEQ
    for IF_MDG_CONSTANTS~C_SEL_LESSEQ .
  aliases C_SUBNODE_ADDRESS
    for IF_MDG_CONSTANTS~C_SUBNODE_ADDRESS .
  aliases C_SUBNODE_ADDRESS_USAGE
    for IF_MDG_CONSTANTS~C_SUBNODE_ADDRESS_USAGE .
  aliases C_SUBNODE_COMM_PREFERENCE
    for IF_MDG_CONSTANTS~C_SUBNODE_COMM_PREFERENCE .
  aliases C_SUBNODE_CONTACT_PERSON_NAME
    for IF_MDG_CONSTANTS~C_SUBNODE_CONTACT_PERSON_NAME .
  aliases C_SUBNODE_EMAIL
    for IF_MDG_CONSTANTS~C_SUBNODE_EMAIL .
  aliases C_SUBNODE_EMAIL_NOTE
    for IF_MDG_CONSTANTS~C_SUBNODE_EMAIL_NOTE .
  aliases C_SUBNODE_EMAIL_USAGE
    for IF_MDG_CONSTANTS~C_SUBNODE_EMAIL_USAGE .
  aliases C_SUBNODE_FACSIMILE
    for IF_MDG_CONSTANTS~C_SUBNODE_FACSIMILE .
  aliases C_SUBNODE_FACSIMILE_NOTE
    for IF_MDG_CONSTANTS~C_SUBNODE_FACSIMILE_NOTE .
  aliases C_SUBNODE_FACSIMILE_USAGE
    for IF_MDG_CONSTANTS~C_SUBNODE_FACSIMILE_USAGE .
  aliases C_SUBNODE_FULLNAME
    for IF_MDG_CONSTANTS~C_SUBNODE_FULLNAME .
  aliases C_SUBNODE_GROUP
    for IF_MDG_CONSTANTS~C_SUBNODE_GROUP .
  aliases C_SUBNODE_NOTE
    for IF_MDG_CONSTANTS~C_SUBNODE_NOTE .
  aliases C_SUBNODE_NUMBER
    for IF_MDG_CONSTANTS~C_SUBNODE_NUMBER .
  aliases C_SUBNODE_OPERATING_HOURS_INFO
    for IF_MDG_CONSTANTS~C_SUBNODE_OPERATING_HOURS_INFO .
  aliases C_SUBNODE_ORGANISATION
    for IF_MDG_CONSTANTS~C_SUBNODE_ORGANISATION .
  aliases C_SUBNODE_POSTAL_ADDRESS
    for IF_MDG_CONSTANTS~C_SUBNODE_POSTAL_ADDRESS .
  aliases C_SUBNODE_TELEPHONE
    for IF_MDG_CONSTANTS~C_SUBNODE_TELEPHONE .
  aliases C_SUBNODE_TELEPHONE_NOTE
    for IF_MDG_CONSTANTS~C_SUBNODE_TELEPHONE_NOTE .
  aliases C_SUBNODE_TELEPHONE_USAGE
    for IF_MDG_CONSTANTS~C_SUBNODE_TELEPHONE_USAGE .
  aliases C_SUBNODE_WEB
    for IF_MDG_CONSTANTS~C_SUBNODE_WEB .
  aliases C_SUBNODE_WEB_NOTE
    for IF_MDG_CONSTANTS~C_SUBNODE_WEB_NOTE .
  aliases C_SUBNODE_WEB_USAGE
    for IF_MDG_CONSTANTS~C_SUBNODE_WEB_USAGE .
  aliases C_TRUE
    for IF_MDG_CONSTANTS~C_TRUE .
  aliases C_UPD_CURRENTSTATE
    for IF_MDG_CONSTANTS~C_UPD_CURRENTSTATE .
  aliases C_UPD_DELETE
    for IF_MDG_CONSTANTS~C_UPD_DELETE .
  aliases C_UPD_INSERT
    for IF_MDG_CONSTANTS~C_UPD_INSERT .
  aliases C_UPD_MAINTAIN
    for IF_MDG_CONSTANTS~C_UPD_MAINTAIN .
  aliases C_UPD_UPDATE
    for IF_MDG_CONSTANTS~C_UPD_UPDATE .
  aliases C_VENDORCONTACT_IDS_TYPE_CODE
    for IF_MDG_CONSTANTS~C_VENDORCONTACT_IDS_TYPE_CODE .
  aliases C_VENDOR_IDS_TYPE_CODE
    for IF_MDG_CONSTANTS~C_VENDOR_IDS_TYPE_CODE .
  aliases C_VENDOR_TYPE_CODE
    for IF_MDG_CONSTANTS~C_VENDOR_TYPE_CODE .
  aliases DELETE
    for IF_DRF_CONST~DELETE .
  aliases DELETE_B
    for IF_DRF_CONST~DELETE_B .
  aliases DIRECTLY
    for IF_DRF_CONST~DIRECTLY .
  aliases DISP
    for IF_DRF_CONST~DISP .
  aliases DOCUMENT
    for IF_MDG_OTC_CONST~DOCUMENT .
  aliases DOCUMENT_ID
    for IF_MDG_IDSC_CONST~DOCUMENT_ID .
  aliases DOCU_ID
    for IF_DRF_CONST~DOCU_ID .
  aliases DRAFT
    for IF_USMD_CR_CONSTANTS~DRAFT .
  aliases DRF_LOG_TYPE
    for IF_DRF_CONST~DRF_LOG_TYPE .
  aliases EDIT
    for IF_DRF_CONST~EDIT .
  aliases EKORG
    for IF_MDG_OTC_CONST~EKORG .
  aliases EKORG_ID
    for IF_MDG_IDSC_CONST~EKORG_ID .
  aliases ENG_CHG_ORDER
    for IF_MDG_OTC_CONST~ENG_CHG_ORDER .
  aliases ENG_CHG_ORDER_ID
    for IF_MDG_IDSC_CONST~ENG_CHG_ORDER_ID .
  aliases ENQUEUE_MODE_EXCLUSIVE
    for IF_DRF_CONST~ENQUEUE_MODE_EXCLUSIVE .
  aliases EQUIPMENT_RESOURCE
    for IF_MDG_OTC_CONST~EQUIPMENT_RESOURCE .
  aliases EQUIPMENT_RESOURCE_ID
    for IF_MDG_IDSC_CONST~EQUIPMENT_RESOURCE_ID .
  aliases ERASE
    for IF_DRF_CONST~ERASE .
  aliases ERP_CLASSIFICATION
    for IF_MDG_OTC_CONST~ERP_CLASSIFICATION .
  aliases ERP_CLASSIFICATION_ID
    for IF_MDG_IDSC_CONST~ERP_CLASSIFICATION_ID .
  aliases ERP_CONTACT_PARTNER_ID
    for IF_MDG_IDSC_CONST~ERP_CONTACT_PARTNER_ID .
  aliases ERP_LOGISTIC_AREA_ID
    for IF_MDG_IDSC_CONST~ERP_LOGISTIC_AREA_ID .
  aliases ERP_SUPPL_CONTACT_PARTNER_ID
    for IF_MDG_IDSC_CONST~ERP_SUPPL_CONTACT_PARTNER_ID .
  aliases FALSE
    for IF_DRF_CONST~FALSE .
  aliases FILE_PATH
    for IF_DRF_CONST~FILE_PATH .
  aliases FILTER_CAT_COMPLEX
    for IF_DRF_CONST~FILTER_CAT_COMPLEX .
  aliases FILTER_CAT_IMPLICIT
    for IF_DRF_CONST~FILTER_CAT_IMPLICIT .
  aliases FILTER_CAT_IMPL_CHECK
    for IF_DRF_CONST~FILTER_CAT_IMPL_CHECK .
  aliases FILTER_CAT_SIMPLE
    for IF_DRF_CONST~FILTER_CAT_SIMPLE .
  aliases FILTER_CRITERIA_POWL
    for IF_DRF_CONST~FILTER_CRITERIA_POWL .
  aliases FILTER_INTERFACE_NAME
    for IF_DRF_CONST~FILTER_INTERFACE_NAME .
  aliases FILTER_MAINTENANCE_APP
    for IF_DRF_CONST~FILTER_MAINTENANCE_APP .
  aliases FILTER_OBJECT_CLASS_DFLT_NAME
    for IF_DRF_CONST~FILTER_OBJECT_CLASS_DFLT_NAME .
  aliases FILTER_OBJECT_TEXTS
    for IF_DRF_CONST~FILTER_OBJECT_TEXTS .
  aliases FILTER_SAP_MAX
    for IF_DRF_CONST~FILTER_SAP_MAX .
  aliases FILTER_SAP_MIN
    for IF_DRF_CONST~FILTER_SAP_MIN .
  aliases FILTER_TP_AFTER_ANALYSIS
    for IF_DRF_CONST~FILTER_TP_AFTER_ANALYSIS .
  aliases FILTER_TP_BEFORE_ANALYSIS
    for IF_DRF_CONST~FILTER_TP_BEFORE_ANALYSIS .
  aliases FILTER_TP_WITHIN_ANALYSIS
    for IF_DRF_CONST~FILTER_TP_WITHIN_ANALYSIS .
  aliases FILT_CRIT_ON_FOBJ
    for IF_DRF_CONST~FILT_CRIT_ON_FOBJ .
  aliases FILT_CRIT_ON_OUTB_IMPL
    for IF_DRF_CONST~FILT_CRIT_ON_OUTB_IMPL .
  aliases FIN_ACC_CHART_OF_ACCOUNTS
    for IF_MDG_OTC_CONST~FIN_ACC_CHART_OF_ACCOUNTS .
  aliases FIN_ACC_CHART_OF_ACCOUNTS_ID
    for IF_MDG_IDSC_CONST~FIN_ACC_CHART_OF_ACCOUNTS_ID .
  aliases FIN_ACC_CHART_OF_ACC_ITEM_ID
    for IF_MDG_IDSC_CONST~FIN_ACC_CHART_OF_ACC_ITEM_ID .
  aliases FIN_ACC_FIN_REP_STRUCTURE
    for IF_MDG_OTC_CONST~FIN_ACC_FIN_REP_STRUCTURE .
  aliases FIN_ACC_FIN_REP_STRUCTURE_ID
    for IF_MDG_IDSC_CONST~FIN_ACC_FIN_REP_STRUCTURE_ID .
  aliases FIN_ACC_FIN_REP_STRUC_ITEM_ID
    for IF_MDG_IDSC_CONST~FIN_ACC_FIN_REP_STRUC_ITEM_ID .
  aliases FIN_CONSOLIDATION_ELEMENT
    for IF_MDG_OTC_CONST~FIN_CONSOLIDATION_ELEMENT .
  aliases FIN_CONSOLIDATION_GROUP
    for IF_MDG_OTC_CONST~FIN_CONSOLIDATION_GROUP .
  aliases FIN_CONSOLIDATION_GROUP_ID
    for IF_MDG_IDSC_CONST~FIN_CONSOLIDATION_GROUP_ID .
  aliases FIN_CONSOLIDATION_STRUCTURE
    for IF_MDG_OTC_CONST~FIN_CONSOLIDATION_STRUCTURE .
  aliases FIN_CONSOLIDATION_STRUCTURE_ID
    for IF_MDG_IDSC_CONST~FIN_CONSOLIDATION_STRUCTURE_ID .
  aliases FIN_CONSOLIDATION_UNIT
    for IF_MDG_OTC_CONST~FIN_CONSOLIDATION_UNIT .
  aliases FIN_CONSOLIDATION_UNIT_ID
    for IF_MDG_IDSC_CONST~FIN_CONSOLIDATION_UNIT_ID .
  aliases FIN_CONS_CHART_OF_ACCOUNTS
    for IF_MDG_OTC_CONST~FIN_CONS_CHART_OF_ACCOUNTS .
  aliases FIN_CONS_CHART_OF_ACCOUNTS_ID
    for IF_MDG_IDSC_CONST~FIN_CONS_CHART_OF_ACCOUNTS_ID .
  aliases FIN_CONS_CHART_OF_ACC_ITEM_ID
    for IF_MDG_IDSC_CONST~FIN_CONS_CHART_OF_ACC_ITEM_ID .
  aliases FIN_CONS_FIN_REP_STRUCTURE
    for IF_MDG_OTC_CONST~FIN_CONS_FIN_REP_STRUCTURE .
  aliases FIN_CONS_FIN_REP_STRUCTURE_ID
    for IF_MDG_IDSC_CONST~FIN_CONS_FIN_REP_STRUCTURE_ID .
  aliases FIN_CONS_FIN_REP_STRUC_ITEM_ID
    for IF_MDG_IDSC_CONST~FIN_CONS_FIN_REP_STRUC_ITEM_ID .
  aliases FIN_REPORTING_STRUCTURE
    for IF_MDG_OTC_CONST~FIN_REPORTING_STRUCTURE .
  aliases FIXED_ASSET
    for IF_MDG_OTC_CONST~FIXED_ASSET .
  aliases FIXED_ASSET_ID
    for IF_MDG_IDSC_CONST~FIXED_ASSET_ID .
  aliases FOBJ_SAP_MAX
    for IF_DRF_CONST~FOBJ_SAP_MAX .
  aliases FOBJ_SAP_MIN
    for IF_DRF_CONST~FOBJ_SAP_MIN .
  aliases FOBJ_TECH_SAP_MAX
    for IF_DRF_CONST~FOBJ_TECH_SAP_MAX .
  aliases FOBJ_TECH_SAP_MIN
    for IF_DRF_CONST~FOBJ_TECH_SAP_MIN .
  aliases FUNCTIONAL_AREA_ID
    for IF_MDG_IDSC_CONST~FUNCTIONAL_AREA_ID .
  aliases FUNDS_MANAGEMENT_FUND
    for IF_MDG_OTC_CONST~FUNDS_MANAGEMENT_FUND .
  aliases FUNDS_MANAGEMENT_FUND_ID
    for IF_MDG_IDSC_CONST~FUNDS_MANAGEMENT_FUND_ID .
  aliases FUND_CENTRE
    for IF_MDG_OTC_CONST~FUND_CENTRE .
  aliases FUND_CENTRE_ID
    for IF_MDG_IDSC_CONST~FUND_CENTRE_ID .
  aliases FUND_MANAGEMENT_FUNC_AREA
    for IF_MDG_OTC_CONST~FUND_MANAGEMENT_FUNC_AREA .
  aliases GCS_NAVI_PARAMETERS
    for IF_USMD_SEARCH_CONSTANTS~GCS_NAVI_PARAMETERS .
  aliases GC_0G_MODEL
    for YZ_INTF_MDG_UTILITY_CONST~GC_0G_MODEL .
  aliases GC_ACA_LOCATIONS
    for IF_FPM_CONSTANTS~GC_ACA_LOCATIONS .
  aliases GC_ACTIONS_CMN
    for IF_EHFND_UI_CONSTANTS_C~GC_ACTIONS_CMN .
  aliases GC_ACTION_CATEGORY
    for IF_FPM_CONSTANTS~GC_ACTION_CATEGORY .
  aliases GC_ACTION_PROPERTIES
    for IF_EHFND_UI_CONSTANTS_C~GC_ACTION_PROPERTIES .
  aliases GC_ACTION_TYPE
    for IF_FPM_CONSTANTS~GC_ACTION_TYPE .
  aliases GC_APP_PARAMS
    for IF_FPM_CONSTANTS~GC_APP_PARAMS .
  aliases GC_ARCHIVE_ACTIVE
    for IF_EHFND_UI_CONSTANTS_C~GC_ARCHIVE_ACTIVE .
  aliases GC_ARIA_LANDMARK
    for IF_FPM_CONSTANTS~GC_ARIA_LANDMARK .
  aliases GC_BOOL
    for YZ_INTF_MDG_UTILITY_CONST~GC_BOOL .
  aliases GC_BUTTON
    for IF_FPM_CONSTANTS~GC_BUTTON .
  aliases GC_BUTTON_CHOICE
    for IF_FPM_CONSTANTS~GC_BUTTON_CHOICE .
  aliases GC_BUTTON_CHOICE_DESIGN
    for IF_FPM_CONSTANTS~GC_BUTTON_CHOICE_DESIGN .
  aliases GC_BUTTON_DESIGN
    for IF_FPM_CONSTANTS~GC_BUTTON_DESIGN .
  aliases GC_BUTTON_TYPE
    for IF_FPM_CONSTANTS~GC_BUTTON_TYPE .
  aliases GC_CAPTURE_EXPOSABLE_ACTIONS
    for IF_FPM_CONSTANTS~GC_CAPTURE_EXPOSABLE_ACTIONS .
  aliases GC_CHECK_ALL_RM_UNIQUE_BO_BS
    for IF_DRF_CONST~GC_CHECK_ALL_RM_UNIQUE_BO_BS .
  aliases GC_CHECK_BO_HAS_FOBJ
    for IF_DRF_CONST~GC_CHECK_BO_HAS_FOBJ .
  aliases GC_CHECK_BO_HAS_OITC
    for IF_DRF_CONST~GC_CHECK_BO_HAS_OITC .
  aliases GC_CHECK_FOBJ_HAS_FILTER
    for IF_DRF_CONST~GC_CHECK_FOBJ_HAS_FILTER .
  aliases GC_CHECK_OITC_HAS_KEY_STRUC
    for IF_DRF_CONST~GC_CHECK_OITC_HAS_KEY_STRUC .
  aliases GC_CHECK_OI_BADI
    for IF_DRF_CONST~GC_CHECK_OI_BADI .
  aliases GC_CHECK_OI_HAS_FOBJ
    for IF_DRF_CONST~GC_CHECK_OI_HAS_FOBJ .
  aliases GC_CHECK_OI_SAME_BO_SAME_FOBJ
    for IF_DRF_CONST~GC_CHECK_OI_SAME_BO_SAME_FOBJ .
  aliases GC_CHECK_OI_SUPPORTS_BS_REQS
    for IF_DRF_CONST~GC_CHECK_OI_SUPPORTS_BS_REQS .
  aliases GC_CHECK_RM_HAS_OI
    for IF_DRF_CONST~GC_CHECK_RM_HAS_OI .
  aliases GC_CHECK_RM_LANGUAGE_SUPPORTED
    for IF_DRF_CONST~GC_CHECK_RM_LANGUAGE_SUPPORTED .
  aliases GC_CHECK_RM_OI_BS_CC_DEF
    for IF_DRF_CONST~GC_CHECK_RM_OI_BS_CC_DEF .
  aliases GC_CHECK_RM_OI_HAS_BS
    for IF_DRF_CONST~GC_CHECK_RM_OI_HAS_BS .
  aliases GC_CHECK_RM_OI_SETS_REQ_PAR
    for IF_DRF_CONST~GC_CHECK_RM_OI_SETS_REQ_PAR .
  aliases GC_CHECK_SUPPLIER_NOT_REPL
    for IF_DRF_CONST~GC_CHECK_SUPPLIER_NOT_REPL .
  aliases GC_CLIENT_ENVIRONMENT
    for IF_FPM_CONSTANTS~GC_CLIENT_ENVIRONMENT .
  aliases GC_COLLAPSED_UIBB_PROC_MODE
    for IF_FPM_CONSTANTS~GC_COLLAPSED_UIBB_PROC_MODE .
  aliases GC_COLUMN_WIDTH_MODE
    for IF_FPM_CONSTANTS~GC_COLUMN_WIDTH_MODE .
  aliases GC_COLUMN_WIDTH_RESIZING_MODE
    for IF_FPM_CONSTANTS~GC_COLUMN_WIDTH_RESIZING_MODE .
  aliases GC_COMPONENTS
    for IF_FPM_CONSTANTS~GC_COMPONENTS .
  aliases GC_CONTENT_AREA_TYPE
    for IF_FPM_CONSTANTS~GC_CONTENT_AREA_TYPE .
  aliases GC_CURRENT_DIALOG_LEVEL
    for IF_FPM_CONSTANTS~GC_CURRENT_DIALOG_LEVEL .
  aliases GC_DIALOG_ACTION_ID
    for IF_FPM_CONSTANTS~GC_DIALOG_ACTION_ID .
  aliases GC_DIALOG_BOX
    for IF_FPM_CONSTANTS~GC_DIALOG_BOX .
  aliases GC_DIALOG_BOXES
    for IF_EHFND_UI_CONSTANTS_C~GC_DIALOG_BOXES .
  aliases GC_EDIT_MODE
    for IF_FPM_CONSTANTS~GC_EDIT_MODE .
  aliases GC_ERROR
    for YZ_INTF_MDG_UTILITY_CONST~GC_ERROR .
  aliases GC_ERROR_TEXT
    for YZ_INTF_MDG_UTILITY_CONST~GC_ERROR_TEXT .
  aliases GC_EVENT
    for IF_FPM_CONSTANTS~GC_EVENT .
  aliases GC_EVENT_CONDITION
    for IF_FPM_CONSTANTS~GC_EVENT_CONDITION .
  aliases GC_EVENT_PARAM
    for IF_FPM_CONSTANTS~GC_EVENT_PARAM .
  aliases GC_EVENT_RESULT
    for IF_FPM_CONSTANTS~GC_EVENT_RESULT .
  aliases GC_EVENT_STATE
    for IF_FPM_CONSTANTS~GC_EVENT_STATE .
  aliases GC_EVT_ADD_ACTION
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_ADD_ACTION .
  aliases GC_EVT_ADD_PM_NOTIF
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_ADD_PM_NOTIF .
  aliases GC_EVT_ADD_TO_FAVOURITES
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_ADD_TO_FAVOURITES .
  aliases GC_EVT_ADD_UIBB
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_ADD_UIBB .
  aliases GC_EVT_CREATE_LINK
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_CREATE_LINK .
  aliases GC_EVT_CREATE_LOCATION
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_CREATE_LOCATION .
  aliases GC_EVT_DESELECT_ALL
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_DESELECT_ALL .
  aliases GC_EVT_DETAIL
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_DETAIL .
  aliases GC_EVT_DISPLAY_DETAILS
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_DISPLAY_DETAILS .
  aliases GC_EVT_DISPLAY_LOC
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_DISPLAY_LOC .
  aliases GC_EVT_DISPLAY_LOCATION
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_DISPLAY_LOCATION .
  aliases GC_EVT_DISPLAY_PERSON_DETAIL
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_DISPLAY_PERSON_DETAIL .
  aliases GC_EVT_DOWNLOAD_FILE_ID
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_DOWNLOAD_FILE_ID .
  aliases GC_EVT_DSC_CONF_DIALOG_CLOSED
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_DSC_CONF_DIALOG_CLOSED .
  aliases GC_EVT_EVT_DISP_EXT_NOTIF_DET
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_EVT_DISP_EXT_NOTIF_DET .
  aliases GC_EVT_EXPORT_LOCATION
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_EXPORT_LOCATION .
  aliases GC_EVT_EXT_NOTIF_VAR_PM
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_EXT_NOTIF_VAR_PM .
  aliases GC_EVT_FBI_BO_CONF_KEY
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_FBI_BO_CONF_KEY .
  aliases GC_EVT_FBI_DELETE
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_FBI_DELETE .
  aliases GC_EVT_FBI_IT_KEY
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_FBI_IT_KEY .
  aliases GC_EVT_FBI_NODE_CONF_KEY
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_FBI_NODE_CONF_KEY .
  aliases GC_EVT_FBI_SEL_CHANGE
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_FBI_SEL_CHANGE .
  aliases GC_EVT_FPM_GUIBB_LIST_CELL
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_FPM_GUIBB_LIST_CELL .
  aliases GC_EVT_GAF_STATE
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_GAF_STATE .
  aliases GC_EVT_HIDE_EMAIL
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_HIDE_EMAIL .
  aliases GC_EVT_HIDE_MAINVIEW
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_HIDE_MAINVIEW .
  aliases GC_EVT_HIDE_SECTION
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_HIDE_SECTION .
  aliases GC_EVT_HIDE_TABSTRIP
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_HIDE_TABSTRIP .
  aliases GC_EVT_HIDE_UIBB
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_HIDE_UIBB .
  aliases GC_EVT_INCL_SUBLOCATIONS
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_INCL_SUBLOCATIONS .
  aliases GC_EVT_NODE_SEL_CHANGED
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_NODE_SEL_CHANGED .
  aliases GC_EVT_NODE_VAL_CHANGED
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_NODE_VAL_CHANGED .
  aliases GC_EVT_OIF_STATE
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_OIF_STATE .
  aliases GC_EVT_PARAM_ACTION_ID
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_ACTION_ID .
  aliases GC_EVT_PARAM_ACTION_KEY
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_ACTION_KEY .
  aliases GC_EVT_PARAM_AMN_KEY
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_AMN_KEY .
  aliases GC_EVT_PARAM_ASSOC_KEY
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_ASSOC_KEY .
  aliases GC_EVT_PARAM_BO
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_BO .
  aliases GC_EVT_PARAM_BO_DO_NODE
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_BO_DO_NODE .
  aliases GC_EVT_PARAM_BO_ELEM_TYPE
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_BO_ELEM_TYPE .
  aliases GC_EVT_PARAM_BO_INSTANCE
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_BO_INSTANCE .
  aliases GC_EVT_PARAM_BO_KEY
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_BO_KEY .
  aliases GC_EVT_PARAM_BO_NODE
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_BO_NODE .
  aliases GC_EVT_PARAM_BO_NODE_KEY
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_BO_NODE_KEY .
  aliases GC_EVT_PARAM_BO_NODE_KEY_TAB
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_BO_NODE_KEY_TAB .
  aliases GC_EVT_PARAM_COMPONENT
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_COMPONENT .
  aliases GC_EVT_PARAM_CONFIDENTIAL
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_CONFIDENTIAL .
  aliases GC_EVT_PARAM_CONFIG_ID
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_CONFIG_ID .
  aliases GC_EVT_PARAM_DATE
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_DATE .
  aliases GC_EVT_PARAM_DEFAULT
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_DEFAULT .
  aliases GC_EVT_PARAM_DEFAULT_LANG
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_DEFAULT_LANG .
  aliases GC_EVT_PARAM_DIALOG_BOX_ID
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_DIALOG_BOX_ID .
  aliases GC_EVT_PARAM_DO_ASSOC_KEY
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_DO_ASSOC_KEY .
  aliases GC_EVT_PARAM_EHSM_COMPONENT
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_EHSM_COMPONENT .
  aliases GC_EVT_PARAM_EVT_SOURCE
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_EVT_SOURCE .
  aliases GC_EVT_PARAM_EXT_NOTIF_CAT
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_EXT_NOTIF_CAT .
  aliases GC_EVT_PARAM_EXT_NOTIF_ID
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_EXT_NOTIF_ID .
  aliases GC_EVT_PARAM_FIELD_LENGTH
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_FIELD_LENGTH .
  aliases GC_EVT_PARAM_GAF_EVENT
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_GAF_EVENT .
  aliases GC_EVT_PARAM_HIDE_TABSTRIP
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_HIDE_TABSTRIP .
  aliases GC_EVT_PARAM_INTERFACE_VIEW
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_INTERFACE_VIEW .
  aliases GC_EVT_PARAM_INV_KEY
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_INV_KEY .
  aliases GC_EVT_PARAM_ISS_AUTHORITY
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_ISS_AUTHORITY .
  aliases GC_EVT_PARAM_KEY
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_KEY .
  aliases GC_EVT_PARAM_LOCATION
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_LOCATION .
  aliases GC_EVT_PARAM_MAINVIEW_ID
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_MAINVIEW_ID .
  aliases GC_EVT_PARAM_NEW_NODE_KEY
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_NEW_NODE_KEY .
  aliases GC_EVT_PARAM_NODE_KEY
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_NODE_KEY .
  aliases GC_EVT_PARAM_NO_LINE_SELECTED
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_NO_LINE_SELECTED .
  aliases GC_EVT_PARAM_PARENT_KEY
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_PARENT_KEY .
  aliases GC_EVT_PARAM_PARENT_NODE_KEY
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_PARENT_NODE_KEY .
  aliases GC_EVT_PARAM_PERSON_ID
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_PERSON_ID .
  aliases GC_EVT_PARAM_PURPOSE
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_PURPOSE .
  aliases GC_EVT_PARAM_RC_KEY
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_RC_KEY .
  aliases GC_EVT_PARAM_REGLIST_XL
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_REGLIST_XL .
  aliases GC_EVT_PARAM_ROOT_NODE_KEY
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_ROOT_NODE_KEY .
  aliases GC_EVT_PARAM_SAVE_SILENT
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_SAVE_SILENT .
  aliases GC_EVT_PARAM_SENDER
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_SENDER .
  aliases GC_EVT_PARAM_SEQ_NUMBER
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_SEQ_NUMBER .
  aliases GC_EVT_PARAM_STEP_CODE
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_STEP_CODE .
  aliases GC_EVT_PARAM_STEP_STATUS
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_STEP_STATUS .
  aliases GC_EVT_PARAM_TAB
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_TAB .
  aliases GC_EVT_PARAM_TRANSL_DISABLED
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_TRANSL_DISABLED .
  aliases GC_EVT_PARAM_TXT_FLD_LNG_NAME
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_TXT_FLD_LNG_NAME .
  aliases GC_EVT_PARAM_TXT_FLD_NAME
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_TXT_FLD_NAME .
  aliases GC_EVT_PARAM_UIBB_ID
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_UIBB_ID .
  aliases GC_EVT_PARAM_UIBB_INDEX
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_UIBB_INDEX .
  aliases GC_EVT_PARAM_UIBB_TYPE
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_UIBB_TYPE .
  aliases GC_EVT_PARAM_UI_MODE
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_UI_MODE .
  aliases GC_EVT_PARAM_VAL_UPLOAD
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_VAL_UPLOAD .
  aliases GC_EVT_PARAM_VARIANT
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_VARIANT .
  aliases GC_EVT_PARAM_WCODE_ERR
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_WCODE_ERR .
  aliases GC_EVT_PARAM_WCODE_MSGS
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_WCODE_MSGS .
  aliases GC_EVT_PARAM_WWF_VARIANT
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_PARAM_WWF_VARIANT .
  aliases GC_EVT_POST_PROCESSING
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_POST_PROCESSING .
  aliases GC_EVT_REFRESH
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_REFRESH .
  aliases GC_EVT_REFRESH_ROOT_CAUSES
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_REFRESH_ROOT_CAUSES .
  aliases GC_EVT_REMOVE_FAVOURITE
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_REMOVE_FAVOURITE .
  aliases GC_EVT_REMOVE_UIBB
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_REMOVE_UIBB .
  aliases GC_EVT_REPORT_MSG
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_REPORT_MSG .
  aliases GC_EVT_RESTORE_MODIFICATIONS
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_RESTORE_MODIFICATIONS .
  aliases GC_EVT_ROOT_ID
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_ROOT_ID .
  aliases GC_EVT_SAVE_SUCCESSFUL
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_SAVE_SUCCESSFUL .
  aliases GC_EVT_SELECT_ALL
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_SELECT_ALL .
  aliases GC_EVT_SET_TAB_ACTIVE
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_SET_TAB_ACTIVE .
  aliases GC_EVT_SET_VARIANT
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_SET_VARIANT .
  aliases GC_EVT_SHOW_MAINVIEW
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_SHOW_MAINVIEW .
  aliases GC_EVT_TRANSL_PARAM_CONF_DATA
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_TRANSL_PARAM_CONF_DATA .
  aliases GC_EVT_TRANSL_PARAM_TYPE
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_TRANSL_PARAM_TYPE .
  aliases GC_EVT_UI_MODE_CHANGED
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_UI_MODE_CHANGED .
  aliases GC_EVT_UPLOAD_DOCUMENT_ID
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_UPLOAD_DOCUMENT_ID .
  aliases GC_EVT_UPLOAD_FILE
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_UPLOAD_FILE .
  aliases GC_EVT_WCODE_UPLOAD_LOG
    for IF_EHFND_UI_CONSTANTS_C~GC_EVT_WCODE_UPLOAD_LOG .
  aliases GC_EXC_RELEASE_TYPE_CHANGE
    for IF_EHFND_UI_CONSTANTS_C~GC_EXC_RELEASE_TYPE_CHANGE .
  aliases GC_EXECUTION_BR
    for YZ_INTF_MDG_UTILITY_CONST~GC_EXECUTION_BR .
  aliases GC_EXECUTION_CD
    for YZ_INTF_MDG_UTILITY_CONST~GC_EXECUTION_CD .
  aliases GC_EXECUTION_CM
    for YZ_INTF_MDG_UTILITY_CONST~GC_EXECUTION_CM .
  aliases GC_EXECUTION_DR
    for YZ_INTF_MDG_UTILITY_CONST~GC_EXECUTION_DR .
  aliases GC_EXECUTION_FP
    for YZ_INTF_MDG_UTILITY_CONST~GC_EXECUTION_FP .
  aliases GC_EXECUTION_HU
    for YZ_INTF_MDG_UTILITY_CONST~GC_EXECUTION_HU .
  aliases GC_EXECUTION_VD
    for YZ_INTF_MDG_UTILITY_CONST~GC_EXECUTION_VD .
  aliases GC_EXTERNAL_NAVIGATION_CATEG
    for IF_FPM_CONSTANTS~GC_EXTERNAL_NAVIGATION_CATEG .
  aliases GC_FAIL
    for YZ_INTF_MDG_UTILITY_CONST~GC_FAIL .
  aliases GC_FAIL_TEXT
    for YZ_INTF_MDG_UTILITY_CONST~GC_FAIL_TEXT .
  aliases GC_FBI_DEFAULT_ACTION
    for IF_EHFND_UI_CONSTANTS_C~GC_FBI_DEFAULT_ACTION .
  aliases GC_FBI_DEFAULT_ACTION_ID
    for IF_EHFND_UI_CONSTANTS_C~GC_FBI_DEFAULT_ACTION_ID .
  aliases GC_FIELDNAME_CLIENT
    for IF_USMD_SEARCH_CONSTANTS~GC_FIELDNAME_CLIENT .
  aliases GC_FIELDNAME_MANDT
    for IF_USMD_SEARCH_CONSTANTS~GC_FIELDNAME_MANDT .
  aliases GC_FIELDNAME_USMD_ACTIVE
    for IF_USMD_SEARCH_CONSTANTS~GC_FIELDNAME_USMD_ACTIVE .
  aliases GC_FLOORPLAN
    for IF_FPM_CONSTANTS~GC_FLOORPLAN .
  aliases GC_FLOORPLAN_STATE
    for IF_FPM_CONSTANTS~GC_FLOORPLAN_STATE .
  aliases GC_FPM_BOPF_ACTION_PREFIX
    for IF_EHFND_UI_CONSTANTS_C~GC_FPM_BOPF_ACTION_PREFIX .
  aliases GC_FPM_CMN
    for IF_EHFND_UI_CONSTANTS_C~GC_FPM_CMN .
  aliases GC_FPM_CREATE_ACTION_PREFIX
    for IF_EHFND_UI_CONSTANTS_C~GC_FPM_CREATE_ACTION_PREFIX .
  aliases GC_FPM_DISPLAY_ACTION_PREFIX
    for IF_EHFND_UI_CONSTANTS_C~GC_FPM_DISPLAY_ACTION_PREFIX .
  aliases GC_FPM_EVENT_PARAM_CMN
    for IF_EHFND_UI_CONSTANTS_C~GC_FPM_EVENT_PARAM_CMN .
  aliases GC_FPM_EVENT_PARAM_SPC
    for IF_EHFND_UI_CONSTANTS_C~GC_FPM_EVENT_PARAM_SPC .
  aliases GC_FPM_MODIFYING_ACTION_PREFIX
    for IF_EHFND_UI_CONSTANTS_C~GC_FPM_MODIFYING_ACTION_PREFIX .
  aliases GC_FPM_MODIFY_UI_ACTION_PREFIX
    for IF_EHFND_UI_CONSTANTS_C~GC_FPM_MODIFY_UI_ACTION_PREFIX .
  aliases GC_FPM_NAV_MODE
    for IF_EHFND_UI_CONSTANTS_C~GC_FPM_NAV_MODE .
  aliases GC_FRAME_DERIVE
    for YZ_INTF_MDG_UTILITY_CONST~GC_FRAME_DERIVE .
  aliases GC_FRAME_FLD_PROP
    for YZ_INTF_MDG_UTILITY_CONST~GC_FRAME_FLD_PROP .
  aliases GC_FRAME_HIDE_UIBB
    for YZ_INTF_MDG_UTILITY_CONST~GC_FRAME_HIDE_UIBB .
  aliases GC_FRAME_VALIDATE
    for YZ_INTF_MDG_UTILITY_CONST~GC_FRAME_VALIDATE .
  aliases GC_HIDDEN
    for IF_FPM_CONSTANTS~GC_HIDDEN .
  aliases GC_HIDDEN_UIBB_PROC_MODE
    for IF_FPM_CONSTANTS~GC_HIDDEN_UIBB_PROC_MODE .
  aliases GC_HIDE_REFERENCE
    for IF_EHFND_UI_CONSTANTS_C~GC_HIDE_REFERENCE .
  aliases GC_INITIAL_PAGE_PROC_MODE
    for IF_FPM_CONSTANTS~GC_INITIAL_PAGE_PROC_MODE .
  aliases GC_INPUT_HELP
    for IF_FPM_CONSTANTS~GC_INPUT_HELP .
  aliases GC_INSTANCE
    for IF_FPM_CONSTANTS~GC_INSTANCE .
  aliases GC_LAYOUT_TYPE
    for IF_FPM_CONSTANTS~GC_LAYOUT_TYPE .
  aliases GC_LEFT_OUTER
    for YZ_INTF_MDG_UTILITY_CONST~GC_LEFT_OUTER .
  aliases GC_MASS
    for YZ_INTF_MDG_UTILITY_CONST~GC_MASS .
  aliases GC_MSG_CLAS_NAME
    for YZ_INTF_MDG_UTILITY_CONST~GC_MSG_CLAS_NAME .
  aliases GC_MSG_TYPE_E
    for YZ_INTF_MDG_UTILITY_CONST~GC_MSG_TYPE_E .
  aliases GC_MSG_TYPE_I
    for YZ_INTF_MDG_UTILITY_CONST~GC_MSG_TYPE_I .
  aliases GC_MSG_TYPE_W
    for YZ_INTF_MDG_UTILITY_CONST~GC_MSG_TYPE_W .
  aliases GC_NA
    for YZ_INTF_MDG_UTILITY_CONST~GC_NA .
  aliases GC_NAVIGATION_MODE
    for IF_FPM_CONSTANTS~GC_NAVIGATION_MODE .
  aliases GC_NAVIGATION_TARGET_TYPE
    for IF_FPM_CONSTANTS~GC_NAVIGATION_TARGET_TYPE .
  aliases GC_NAVI_SOURCE_KEY_ATTR_PREFIX
    for IF_FPM_CONSTANTS~GC_NAVI_SOURCE_KEY_ATTR_PREFIX .
  aliases GC_NA_TEXT
    for YZ_INTF_MDG_UTILITY_CONST~GC_NA_TEXT .
  aliases GC_NOTEOFVAL_TYPE_CHANGE
    for IF_EHFND_UI_CONSTANTS_C~GC_NOTEOFVAL_TYPE_CHANGE .
  aliases GC_OBJECT_HEADER_EVENT_SOURCE
    for IF_FPM_CONSTANTS~GC_OBJECT_HEADER_EVENT_SOURCE .
  aliases GC_ORDER_AS_TEXT
    for IF_FPM_CONSTANTS~GC_ORDER_AS_TEXT .
  aliases GC_ORDER_CRITERION
    for IF_FPM_CONSTANTS~GC_ORDER_CRITERION .
  aliases GC_ORIG_LANGU_NOT_EDITABLE
    for IF_EHFND_UI_CONSTANTS_C~GC_ORIG_LANGU_NOT_EDITABLE .
  aliases GC_PADDING
    for IF_FPM_CONSTANTS~GC_PADDING .
  aliases GC_PAGE_MASTER_POSITION
    for IF_FPM_CONSTANTS~GC_PAGE_MASTER_POSITION .
  aliases GC_PAGE_TOOLBAR_STD_FUNC_OVP
    for IF_FPM_CONSTANTS~GC_PAGE_TOOLBAR_STD_FUNC_OVP .
  aliases GC_PARAM_ARCHIVE
    for IF_EHFND_UI_CONSTANTS_C~GC_PARAM_ARCHIVE .
  aliases GC_PARAM_CREATED_SUBJECT_KEY
    for IF_EHFND_UI_CONSTANTS_C~GC_PARAM_CREATED_SUBJECT_KEY .
  aliases GC_PARAM_CREATED_SUBJECT_NAME
    for IF_EHFND_UI_CONSTANTS_C~GC_PARAM_CREATED_SUBJECT_NAME .
  aliases GC_PARAM_CREATED_SUBJECT_TYPE
    for IF_EHFND_UI_CONSTANTS_C~GC_PARAM_CREATED_SUBJECT_TYPE .
  aliases GC_PARAM_DISPLAY_LOC
    for IF_EHFND_UI_CONSTANTS_C~GC_PARAM_DISPLAY_LOC .
  aliases GC_PARAM_DISPLAY_LOC_NAME
    for IF_EHFND_UI_CONSTANTS_C~GC_PARAM_DISPLAY_LOC_NAME .
  aliases GC_PARAM_HIDE_ADDRESS
    for IF_EHFND_UI_CONSTANTS_C~GC_PARAM_HIDE_ADDRESS .
  aliases GC_PARAM_HIDE_SECTION
    for IF_EHFND_UI_CONSTANTS_C~GC_PARAM_HIDE_SECTION .
  aliases GC_PARAM_INST_DATA
    for IF_EHFND_UI_CONSTANTS_C~GC_PARAM_INST_DATA .
  aliases GC_PARAM_LOC_ROOT_SELECTED
    for IF_EHFND_UI_CONSTANTS_C~GC_PARAM_LOC_ROOT_SELECTED .
  aliases GC_PARAM_REGLIST_KEY
    for IF_EHFND_UI_CONSTANTS_C~GC_PARAM_REGLIST_KEY .
  aliases GC_PARAM_REG_LIST_TAB
    for IF_EHFND_UI_CONSTANTS_C~GC_PARAM_REG_LIST_TAB .
  aliases GC_PASS
    for YZ_INTF_MDG_UTILITY_CONST~GC_PASS .
  aliases GC_PASS_TEXT
    for YZ_INTF_MDG_UTILITY_CONST~GC_PASS_TEXT .
  aliases GC_PERSONALIZATION_SAVE_MODE
    for IF_FPM_CONSTANTS~GC_PERSONALIZATION_SAVE_MODE .
  aliases GC_PROCESS_TYPE_CDB
    for YZ_INTF_MDG_UTILITY_CONST~GC_PROCESS_TYPE_CDB .
  aliases GC_PROCESS_TYPE_DERIVE
    for YZ_INTF_MDG_UTILITY_CONST~GC_PROCESS_TYPE_DERIVE .
  aliases GC_PROCESS_TYPE_FIELD_PROPRTY
    for YZ_INTF_MDG_UTILITY_CONST~GC_PROCESS_TYPE_FIELD_PROPRTY .
  aliases GC_PROCESS_TYPE_HIDE_UIBB
    for YZ_INTF_MDG_UTILITY_CONST~GC_PROCESS_TYPE_HIDE_UIBB .
  aliases GC_PROCESS_TYPE_UNIQUE
    for YZ_INTF_MDG_UTILITY_CONST~GC_PROCESS_TYPE_UNIQUE .
  aliases GC_PROCESS_TYPE_VALIDATE
    for YZ_INTF_MDG_UTILITY_CONST~GC_PROCESS_TYPE_VALIDATE .
  aliases GC_PROPOSED_DIALOG_LEVEL
    for IF_FPM_CONSTANTS~GC_PROPOSED_DIALOG_LEVEL .
  aliases GC_ROLE
    for IF_FPM_CONSTANTS~GC_ROLE .
  aliases GC_SASH_COLLAPSE_DIRECTION
    for IF_FPM_CONSTANTS~GC_SASH_COLLAPSE_DIRECTION .
  aliases GC_SASH_POSITION_MODE
    for IF_FPM_CONSTANTS~GC_SASH_POSITION_MODE .
  aliases GC_SCROLLING_MODE
    for IF_FPM_CONSTANTS~GC_SCROLLING_MODE .
  aliases GC_SECTION_HEADER_DESIGN
    for IF_FPM_CONSTANTS~GC_SECTION_HEADER_DESIGN .
  aliases GC_SECTION_HEADER_LEVEL
    for IF_FPM_CONSTANTS~GC_SECTION_HEADER_LEVEL .
  aliases GC_SECTION_LAYOUT_TYPE
    for IF_FPM_CONSTANTS~GC_SECTION_LAYOUT_TYPE .
  aliases GC_SEMANTIC_FLT_ACTION
    for IF_DRF_CONST~GC_SEMANTIC_FLT_ACTION .
  aliases GC_SEMANTIC_OBJECT
    for IF_DRF_CONST~GC_SEMANTIC_OBJECT .
  aliases GC_SEMANTIC_SEGFLT_ACTION
    for IF_DRF_CONST~GC_SEMANTIC_SEGFLT_ACTION .
  aliases GC_SEPARATOR
    for IF_FPM_CONSTANTS~GC_SEPARATOR .
  aliases GC_SERVICE_KEY
    for IF_FPM_CONSTANTS~GC_SERVICE_KEY .
  aliases GC_SHOW_ICONS
    for IF_FPM_CONSTANTS~GC_SHOW_ICONS .
  aliases GC_SHOW_LISU_DETAILS_DIALOG_ID
    for IF_EHFND_UI_CONSTANTS_C~GC_SHOW_LISU_DETAILS_DIALOG_ID .
  aliases GC_SHOW_MAX_NUM_RESULT
    for IF_FPM_CONSTANTS~GC_SHOW_MAX_NUM_RESULT .
  aliases GC_STRETCHING
    for IF_FPM_CONSTANTS~GC_STRETCHING .
  aliases GC_SUBJECT_DET_DLG_PARAM_DATA
    for IF_EHFND_UI_CONSTANTS_C~GC_SUBJECT_DET_DLG_PARAM_DATA .
  aliases GC_SUBJECT_DET_DLG_PARAM_ID
    for IF_EHFND_UI_CONSTANTS_C~GC_SUBJECT_DET_DLG_PARAM_ID .
  aliases GC_SWAP_TYPE
    for IF_FPM_CONSTANTS~GC_SWAP_TYPE .
  aliases GC_TABBED
    for IF_EHFND_UI_CONSTANTS_C~GC_TABBED .
  aliases GC_TOGGLE_BUTTON_DESIGN
    for IF_FPM_CONSTANTS~GC_TOGGLE_BUTTON_DESIGN .
  aliases GC_TOKENIZER_EVENT
    for IF_FPM_CONSTANTS~GC_TOKENIZER_EVENT .
  aliases GC_TOOLBAR_BUTTON_DESIGN
    for IF_FPM_CONSTANTS~GC_TOOLBAR_BUTTON_DESIGN .
  aliases GC_TOOLBAR_ELEMENT_ALIGNMENT
    for IF_FPM_CONSTANTS~GC_TOOLBAR_ELEMENT_ALIGNMENT .
  aliases GC_TOOLBAR_ELEMENT_TYPE
    for IF_FPM_CONSTANTS~GC_TOOLBAR_ELEMENT_TYPE .
  aliases GC_TOOLBAR_LOCATION
    for IF_FPM_CONSTANTS~GC_TOOLBAR_LOCATION .
  aliases GC_TOOLBAR_LOCATION_TYPE
    for IF_FPM_CONSTANTS~GC_TOOLBAR_LOCATION_TYPE .
  aliases GC_TRANSLATE_EVT_ID
    for IF_EHFND_UI_CONSTANTS_C~GC_TRANSLATE_EVT_ID .
  aliases GC_TS_VALUE_FALSE
    for IF_EHFND_UI_CONSTANTS_C~GC_TS_VALUE_FALSE .
  aliases GC_TS_VALUE_TRUE
    for IF_EHFND_UI_CONSTANTS_C~GC_TS_VALUE_TRUE .
  aliases GC_TS_VALUE_UNKNOWN
    for IF_EHFND_UI_CONSTANTS_C~GC_TS_VALUE_UNKNOWN .
  aliases GC_UIBB_PROC_MODE_IN_MAX_MODE
    for IF_FPM_CONSTANTS~GC_UIBB_PROC_MODE_IN_MAX_MODE .
  aliases GC_UIBB_RENDER_TYPE
    for IF_FPM_CONSTANTS~GC_UIBB_RENDER_TYPE .
  aliases GC_UI_GUIDELINE_VERSION
    for IF_FPM_CONSTANTS~GC_UI_GUIDELINE_VERSION .
  aliases GC_UI_MODE_EDIT
    for IF_EHFND_UI_CONSTANTS_C~GC_UI_MODE_EDIT .
  aliases GC_UI_MODE_READ_ONLY
    for IF_EHFND_UI_CONSTANTS_C~GC_UI_MODE_READ_ONLY .
  aliases GC_UI_STATE_NORMAL
    for IF_EHFND_UI_CONSTANTS_C~GC_UI_STATE_NORMAL .
  aliases GC_UI_STATE_REQUIRED
    for IF_EHFND_UI_CONSTANTS_C~GC_UI_STATE_REQUIRED .
  aliases GC_VISIBILITY
    for IF_FPM_CONSTANTS~GC_VISIBILITY .
  aliases GC_WCODE_UPLOAD_LOG
    for IF_EHFND_UI_CONSTANTS_C~GC_WCODE_UPLOAD_LOG .
  aliases GC_WDUI_INVISIBLE
    for IF_EHFND_UI_CONSTANTS_C~GC_WDUI_INVISIBLE .
  aliases GC_WDUI_VISIBLE
    for IF_EHFND_UI_CONSTANTS_C~GC_WDUI_VISIBLE .
  aliases GC_WINDOWS
    for IF_FPM_CONSTANTS~GC_WINDOWS .
  aliases GC_WORKBENCH_TYPE
    for IF_FPM_CONSTANTS~GC_WORKBENCH_TYPE .
  aliases GENERAL_LEDGER_ACCOUNT_TYPE_ID
    for IF_MDG_IDSC_CONST~GENERAL_LEDGER_ACCOUNT_TYPE_ID .
  aliases GENERAL_LEDGER_ACC_MASTER
    for IF_MDG_OTC_CONST~GENERAL_LEDGER_ACC_MASTER .
  aliases GENERAL_LEDGER_ACC_MASTER_ID
    for IF_MDG_IDSC_CONST~GENERAL_LEDGER_ACC_MASTER_ID .
  aliases GENERIC_LOG_TYPE
    for IF_DRF_CONST~GENERIC_LOG_TYPE .
  aliases GEN_MSG_AUDIT_CNF
    for IF_DRF_CONST~GEN_MSG_AUDIT_CNF .
  aliases GOODS_MOVEMENT
    for IF_MDG_OTC_CONST~GOODS_MOVEMENT .
  aliases GOODS_MOVEMENT_ID
    for IF_MDG_IDSC_CONST~GOODS_MOVEMENT_ID .
  aliases GRANT
    for IF_MDG_OTC_CONST~GRANT .
  aliases GRANT_ID
    for IF_MDG_IDSC_CONST~GRANT_ID .
  aliases ICON
    for IF_DRF_CONST~ICON .
  aliases INACTIVE_ICON
    for IF_DRF_CONST~INACTIVE_ICON .
  aliases INCOTERMS
    for IF_MDG_OTC_CONST~INCOTERMS .
  aliases INCOTERMS_ID
    for IF_MDG_IDSC_CONST~INCOTERMS_ID .
  aliases INDIVIDUAL_MATERIAL
    for IF_MDG_OTC_CONST~INDIVIDUAL_MATERIAL .
  aliases INDIVIDUAL_MATERIAL_BOM
    for IF_MDG_OTC_CONST~INDIVIDUAL_MATERIAL_BOM .
  aliases INDIVIDUAL_MATERIAL_BOM_ID
    for IF_MDG_IDSC_CONST~INDIVIDUAL_MATERIAL_BOM_ID .
  aliases INDIVIDUAL_MATERIAL_BOM_INT_ID
    for IF_MDG_IDSC_CONST~INDIVIDUAL_MATERIAL_BOM_INT_ID .
  aliases INDIVIDUAL_MATERIAL_ID
    for IF_MDG_IDSC_CONST~INDIVIDUAL_MATERIAL_ID .
  aliases INS
    for IF_DRF_CONST~INS .
  aliases INSERT
    for IF_DRF_CONST~INSERT .
  aliases INSTALLATION_POINT
    for IF_MDG_OTC_CONST~INSTALLATION_POINT .
  aliases INSTALLATION_POINT_BILL_OF_MAT
    for IF_MDG_OTC_CONST~INSTALLATION_POINT_BILL_OF_MAT .
  aliases INSTALLATION_POINT_BOM_ID
    for IF_MDG_IDSC_CONST~INSTALLATION_POINT_BOM_ID .
  aliases INSTALLATION_POINT_BOM_INT_ID
    for IF_MDG_IDSC_CONST~INSTALLATION_POINT_BOM_INT_ID .
  aliases INSTALLATION_POINT_ID
    for IF_MDG_IDSC_CONST~INSTALLATION_POINT_ID .
  aliases INTERNAL_ORDER
    for IF_MDG_OTC_CONST~INTERNAL_ORDER .
  aliases INTERNAL_ORDER_ID
    for IF_MDG_IDSC_CONST~INTERNAL_ORDER_ID .
  aliases ISR_ARTICLE
    for IF_MDG_OTC_CONST~ISR_ARTICLE .
  aliases ISR_ARTICLE_HIERARCHY
    for IF_MDG_OTC_CONST~ISR_ARTICLE_HIERARCHY .
  aliases ISR_CONSUMPTION
    for IF_MDG_OTC_CONST~ISR_CONSUMPTION .
  aliases ISR_INVENTORY
    for IF_MDG_OTC_CONST~ISR_INVENTORY .
  aliases ISR_LOCATION_PRODUCT
    for IF_MDG_OTC_CONST~ISR_LOCATION_PRODUCT .
  aliases ISR_MAT_GRP_HIERARCHY
    for IF_MDG_OTC_CONST~ISR_MAT_GRP_HIERARCHY .
  aliases ISR_MOVING_AVERAGE_PRICE
    for IF_MDG_OTC_CONST~ISR_MOVING_AVERAGE_PRICE .
  aliases ISR_PLANT_CLASS_HIERARCHY
    for IF_MDG_OTC_CONST~ISR_PLANT_CLASS_HIERARCHY .
  aliases ISR_PLANT_HIERARCHY
    for IF_MDG_OTC_CONST~ISR_PLANT_HIERARCHY .
  aliases ISR_PROMOTIONS
    for IF_MDG_OTC_CONST~ISR_PROMOTIONS .
  aliases ISR_SALES_PRICE
    for IF_MDG_OTC_CONST~ISR_SALES_PRICE .
  aliases ISR_SOURCE_OF_SUPPLY
    for IF_MDG_OTC_CONST~ISR_SOURCE_OF_SUPPLY .
  aliases JOURNAL_ENTRY
    for IF_MDG_OTC_CONST~JOURNAL_ENTRY .
  aliases JOURNAL_ENTRY_ID
    for IF_MDG_IDSC_CONST~JOURNAL_ENTRY_ID .
  aliases KEY_MAPPING
    for IF_MDG_OTC_CONST~KEY_MAPPING .
  aliases KEY_MAP_SOA_SVC_KEY
    for IF_MDG_IDSC_CONST~KEY_MAP_SOA_SVC_KEY .
  aliases LOGISTICS_AREA
    for IF_MDG_OTC_CONST~LOGISTICS_AREA .
  aliases LOG_SYS
    for IF_DRF_CONST~LOG_SYS .
  aliases MAINTENANCE_ITEM
    for IF_MDG_OTC_CONST~MAINTENANCE_ITEM .
  aliases MAINTENANCE_ITEM_ID
    for IF_MDG_IDSC_CONST~MAINTENANCE_ITEM_ID .
  aliases MAINTENANCE_ORDER_ID
    for IF_MDG_IDSC_CONST~MAINTENANCE_ORDER_ID .
  aliases MAINTENANCE_PLAN
    for IF_MDG_OTC_CONST~MAINTENANCE_PLAN .
  aliases MAINTENANCE_PLAN_ID
    for IF_MDG_IDSC_CONST~MAINTENANCE_PLAN_ID .
  aliases MAINTENANCE_TASK_LIST
    for IF_MDG_OTC_CONST~MAINTENANCE_TASK_LIST .
  aliases MAINTENANCE_TASK_LIST_ID
    for IF_MDG_IDSC_CONST~MAINTENANCE_TASK_LIST_ID .
  aliases MAINT_VIEW_FOBJ
    for IF_DRF_CONST~MAINT_VIEW_FOBJ .
  aliases MATERIAL
    for IF_MDG_OTC_CONST~MATERIAL .
  aliases MATERIALGROUP
    for IF_MDG_OTC_CONST~MATERIALGROUP .
  aliases MATERIALGROUP_ID
    for IF_MDG_IDSC_CONST~MATERIALGROUP_ID .
  aliases MATERIAL_ECM_REV
    for IF_MDG_OTC_CONST~MATERIAL_ECM_REV .
  aliases MATERIAL_ECM_REVLEV_ID
    for IF_MDG_IDSC_CONST~MATERIAL_ECM_REVLEV_ID .
  aliases MATERIAL_ID
    for IF_MDG_IDSC_CONST~MATERIAL_ID .
  aliases MATERIAL_ID_EXT
    for IF_MDG_IDSC_CONST~MATERIAL_ID_EXT .
  aliases MATERIAL_QMAT
    for IF_MDG_OTC_CONST~MATERIAL_QMAT .
  aliases MATERIAL_QMAT_ID
    for IF_MDG_IDSC_CONST~MATERIAL_QMAT_ID .
  aliases MATERIAL_UUID
    for IF_MDG_IDSC_CONST~MATERIAL_UUID .
  aliases MAT_DRAD
    for IF_MDG_OTC_CONST~MAT_DRAD .
  aliases MAT_DRAD_ID
    for IF_MDG_IDSC_CONST~MAT_DRAD_ID .
  aliases MAX_DATE
    for IF_DRF_CONST~MAX_DATE .
  aliases MAX_TIME
    for IF_DRF_CONST~MAX_TIME .
  aliases MDGF_ACCOUNT_COMPANY_CODE
    for IF_MDG_OTC_CONST~MDGF_ACCOUNT_COMPANY_CODE .
  aliases MDGF_ACCOUNT_COMPANY_CODE_ID
    for IF_MDG_IDSC_CONST~MDGF_ACCOUNT_COMPANY_CODE_ID .
  aliases MDGF_BREAKDOWN_CATEGORY
    for IF_MDG_OTC_CONST~MDGF_BREAKDOWN_CATEGORY .
  aliases MDGF_BREAKDOWN_CATEGORY_ID
    for IF_MDG_IDSC_CONST~MDGF_BREAKDOWN_CATEGORY_ID .
  aliases MDGF_BREAKDOWN_CATEGORY_SET
    for IF_MDG_OTC_CONST~MDGF_BREAKDOWN_CATEGORY_SET .
  aliases MDGF_BREAKDOWN_CATEGORY_SET_ID
    for IF_MDG_IDSC_CONST~MDGF_BREAKDOWN_CATEGORY_SET_ID .
  aliases MDGF_CAUSE_FOR_SUBMISSION
    for IF_MDG_OTC_CONST~MDGF_CAUSE_FOR_SUBMISSION .
  aliases MDGF_CAUSE_FOR_SUBMISSION_ID
    for IF_MDG_IDSC_CONST~MDGF_CAUSE_FOR_SUBMISSION_ID .
  aliases MDGF_CONS_CHARACTERISTICS
    for IF_MDG_OTC_CONST~MDGF_CONS_CHARACTERISTICS .
  aliases MDGF_CONS_CHARACTERISTICS_ID
    for IF_MDG_IDSC_CONST~MDGF_CONS_CHARACTERISTICS_ID .
  aliases MDGF_FIN_REP_STRUC_ITEM
    for IF_MDG_OTC_CONST~MDGF_FIN_REP_STRUC_ITEM .
  aliases MDGF_FIN_REP_STRUC_ITEM_ID
    for IF_MDG_IDSC_CONST~MDGF_FIN_REP_STRUC_ITEM_ID .
  aliases MDGF_ITEM
    for IF_MDG_OTC_CONST~MDGF_ITEM .
  aliases MDGF_ITEM_ID
    for IF_MDG_IDSC_CONST~MDGF_ITEM_ID .
  aliases MDGF_LOG_TYPE
    for IF_DRF_CONST~MDGF_LOG_TYPE .
  aliases MDGF_TEXT_ITEM
    for IF_MDG_OTC_CONST~MDGF_TEXT_ITEM .
  aliases MDGF_TEXT_ITEM_ID
    for IF_MDG_IDSC_CONST~MDGF_TEXT_ITEM_ID .
  aliases MDGF_TRANSACTION_TYPE
    for IF_MDG_OTC_CONST~MDGF_TRANSACTION_TYPE .
  aliases MDGF_TRANSACTION_TYPE_ID
    for IF_MDG_IDSC_CONST~MDGF_TRANSACTION_TYPE_ID .
  aliases MDG_ADDRESS_UUID
    for IF_MDG_IDSC_CONST~MDG_ADDRESS_UUID .
  aliases MDG_CARR_ID
    for IF_MDG_IDSC_CONST~MDG_CARR_ID .
  aliases MDG_EXAMPLE_AIRLINE
    for IF_MDG_OTC_CONST~MDG_EXAMPLE_AIRLINE .
  aliases MDG_EXAMPLE_FLIGHT_CONNECTION
    for IF_MDG_OTC_CONST~MDG_EXAMPLE_FLIGHT_CONNECTION .
  aliases MDG_EXAMPLE_FLIGHT_SCHEDULE
    for IF_MDG_OTC_CONST~MDG_EXAMPLE_FLIGHT_SCHEDULE .
  aliases MDG_FLIGHT_ID
    for IF_MDG_IDSC_CONST~MDG_FLIGHT_ID .
  aliases MDG_PFLI_ID
    for IF_MDG_IDSC_CONST~MDG_PFLI_ID .
  aliases MEASURING_DEVICE
    for IF_MDG_OTC_CONST~MEASURING_DEVICE .
  aliases MEASURING_DEVICE_ID
    for IF_MDG_IDSC_CONST~MEASURING_DEVICE_ID .
  aliases MERCHANDISE
    for IF_MDG_OTC_CONST~MERCHANDISE .
  aliases MERCHANDISE_KEY
    for IF_MDG_IDSC_CONST~MERCHANDISE_KEY .
  aliases MODE
    for IF_DRF_CONST~MODE .
  aliases MODE_ADHOC
    for IF_DRF_CONST~MODE_ADHOC .
  aliases MODE_CHANGE
    for IF_DRF_CONST~MODE_CHANGE .
  aliases MODE_DIRECTLY
    for IF_DRF_CONST~MODE_DIRECTLY .
  aliases MODE_INIT
    for IF_DRF_CONST~MODE_INIT .
  aliases MSGID
    for IF_USMD_CR_CONSTANTS~MSGID .
  aliases MSG_ID_COMMON
    for IF_DRF_CONST~MSG_ID_COMMON .
  aliases MSG_ID_CUST_CHECK
    for IF_DRF_CONST~MSG_ID_CUST_CHECK .
  aliases MSG_ID_DRF_COMMON
    for IF_DRF_CONST~MSG_ID_DRF_COMMON .
  aliases MSG_PROBCLASS_1
    for IF_DRF_CONST~MSG_PROBCLASS_1 .
  aliases MSG_PROBCLASS_2
    for IF_DRF_CONST~MSG_PROBCLASS_2 .
  aliases MSG_PROBCLASS_3
    for IF_DRF_CONST~MSG_PROBCLASS_3 .
  aliases MSG_PROBCLASS_4
    for IF_DRF_CONST~MSG_PROBCLASS_4 .
  aliases MSG_TYPE_ABORT
    for IF_DRF_CONST~MSG_TYPE_ABORT .
  aliases MSG_TYPE_ERROR
    for IF_DRF_CONST~MSG_TYPE_ERROR .
  aliases MSG_TYPE_ICON_ABORT
    for IF_DRF_CONST~MSG_TYPE_ICON_ABORT .
  aliases MSG_TYPE_ICON_ERROR
    for IF_DRF_CONST~MSG_TYPE_ICON_ERROR .
  aliases MSG_TYPE_ICON_SUCCESS
    for IF_DRF_CONST~MSG_TYPE_ICON_SUCCESS .
  aliases MSG_TYPE_ICON_WARNING
    for IF_DRF_CONST~MSG_TYPE_ICON_WARNING .
  aliases MSG_TYPE_INFO
    for IF_DRF_CONST~MSG_TYPE_INFO .
  aliases MSG_TYPE_SUCCESS
    for IF_DRF_CONST~MSG_TYPE_SUCCESS .
  aliases MSG_TYPE_WARNING
    for IF_DRF_CONST~MSG_TYPE_WARNING .
  aliases N
    for IF_DRF_CONST~N .
  aliases NAME_IF_OUTB_IMPL
    for IF_DRF_CONST~NAME_IF_OUTB_IMPL .
  aliases NAME_VIEW_OUTB_CLASS
    for IF_DRF_CONST~NAME_VIEW_OUTB_CLASS .
  aliases NEW_FOLDER_MESSAGE
    for IF_DRF_CONST~NEW_FOLDER_MESSAGE .
  aliases NO
    for IF_DRF_CONST~NO .
  aliases OBJECT_LINK
    for IF_MDG_OTC_CONST~OBJECT_LINK .
  aliases OBJECT_LINK_ID
    for IF_MDG_IDSC_CONST~OBJECT_LINK_ID .
  aliases OBJECT_NETWORK
    for IF_MDG_OTC_CONST~OBJECT_NETWORK .
  aliases OBJECT_NETWORK_ID
    for IF_MDG_IDSC_CONST~OBJECT_NETWORK_ID .
  aliases ORG_CENTER
    for IF_MDG_OTC_CONST~ORG_CENTER .
  aliases ORG_CENTER_NR
    for IF_MDG_IDSC_CONST~ORG_CENTER_NR .
  aliases OTHER_FUNCTIONS
    for IF_DRF_CONST~OTHER_FUNCTIONS .
  aliases OUTBPAR_PCK_SIZE_BULK
    for IF_DRF_CONST~OUTBPAR_PCK_SIZE_BULK .
  aliases OUTBPAR_TASK_SIZE_DELTA
    for IF_DRF_CONST~OUTBPAR_TASK_SIZE_DELTA .
  aliases OUTBPAR_TASK_SIZE_PROCMSG
    for IF_DRF_CONST~OUTBPAR_TASK_SIZE_PROCMSG .
  aliases OUTBPAR_WRITE_OBJ_REPL_STAT
    for IF_DRF_CONST~OUTBPAR_WRITE_OBJ_REPL_STAT .
  aliases PACKAGE_SIZE_DEFAULT
    for IF_DRF_CONST~PACKAGE_SIZE_DEFAULT .
  aliases PARAMOD_CPA
    for IF_DRF_CONST~PARAMOD_CPA .
  aliases PARAMOD_MSG
    for IF_DRF_CONST~PARAMOD_MSG .
  aliases PARAMOD_NO_PARA
    for IF_DRF_CONST~PARAMOD_NO_PARA .
  aliases PAYMENT_METHOD
    for IF_MDG_OTC_CONST~PAYMENT_METHOD .
  aliases PAYMENT_METHOD_ID
    for IF_MDG_IDSC_CONST~PAYMENT_METHOD_ID .
  aliases PLANNED_ORDER
    for IF_MDG_OTC_CONST~PLANNED_ORDER .
  aliases PLANNED_ORDER_ID
    for IF_MDG_IDSC_CONST~PLANNED_ORDER_ID .
  aliases PLANT
    for IF_MDG_OTC_CONST~PLANT .
  aliases PLANTPURCHASINGORGRELATIONSHIP
    for IF_MDG_OTC_CONST~PLANTPURCHASINGORGRELATIONSHIP .
  aliases PLANTPURCHASINGORGRELATION_ID
    for IF_MDG_IDSC_CONST~PLANTPURCHASINGORGRELATION_ID .
  aliases PLANT_ID
    for IF_MDG_IDSC_CONST~PLANT_ID .
  aliases PM_ORDER
    for IF_MDG_OTC_CONST~PM_ORDER .
  aliases PORTAL_OP_NAME
    for IF_DRF_CONST~PORTAL_OP_NAME .
  aliases POWL_ACTION_CREATE
    for IF_DRF_CONST~POWL_ACTION_CREATE .
  aliases POWL_ACTION_DISPLAY
    for IF_DRF_CONST~POWL_ACTION_DISPLAY .
  aliases POWL_ACTION_EDIT
    for IF_DRF_CONST~POWL_ACTION_EDIT .
  aliases POWL_ACTION_FILTER_CRITERIA
    for IF_DRF_CONST~POWL_ACTION_FILTER_CRITERIA .
  aliases POWL_ACTION_LEAD_SEL
    for IF_DRF_CONST~POWL_ACTION_LEAD_SEL .
  aliases POWL_ACTION_TRANSPORT
    for IF_DRF_CONST~POWL_ACTION_TRANSPORT .
  aliases POWL_COLID_APPL_DESCR
    for IF_DRF_CONST~POWL_COLID_APPL_DESCR .
  aliases POWL_COLID_APPL_ID
    for IF_DRF_CONST~POWL_COLID_APPL_ID .
  aliases POWL_COLID_BO_DESCR
    for IF_DRF_CONST~POWL_COLID_BO_DESCR .
  aliases POWL_COLID_BO_ID
    for IF_DRF_CONST~POWL_COLID_BO_ID .
  aliases POWL_COLID_CM_CHANNEL_DESC
    for IF_DRF_CONST~POWL_COLID_CM_CHANNEL_DESC .
  aliases POWL_COLID_EXPL_FLT
    for IF_DRF_CONST~POWL_COLID_EXPL_FLT .
  aliases POWL_COLID_FILTER_CRITERIA
    for IF_DRF_CONST~POWL_COLID_FILTER_CRITERIA .
  aliases POWL_COLID_FILT_IMAGE
    for IF_DRF_CONST~POWL_COLID_FILT_IMAGE .
  aliases POWL_COLID_ICON_TXT
    for IF_DRF_CONST~POWL_COLID_ICON_TXT .
  aliases POWL_COLID_IMPL_FLT
    for IF_DRF_CONST~POWL_COLID_IMPL_FLT .
  aliases POWL_COLID_SERV_OPERATION
    for IF_DRF_CONST~POWL_COLID_SERV_OPERATION .
  aliases POWL_LAUNCH_FROM_TRANSACTION
    for IF_DRF_CONST~POWL_LAUNCH_FROM_TRANSACTION .
  aliases POWL_PORTAL_ACTIONS_BO_NAME
    for IF_DRF_CONST~POWL_PORTAL_ACTIONS_BO_NAME .
  aliases POWL_PORTAL_ACTIONS_BO_OP_NAME
    for IF_DRF_CONST~POWL_PORTAL_ACTIONS_BO_OP_NAME .
  aliases POWL_PORTAL_ACTIONS_BO_SYSTEM
    for IF_DRF_CONST~POWL_PORTAL_ACTIONS_BO_SYSTEM .
  aliases POWL_TYPE_MULTIPLE_APPL
    for IF_DRF_CONST~POWL_TYPE_MULTIPLE_APPL .
  aliases POWL_TYPE_MULTIPLE_BO
    for IF_DRF_CONST~POWL_TYPE_MULTIPLE_BO .
  aliases POWL_TYPE_MULTIPLE_BO_APPL
    for IF_DRF_CONST~POWL_TYPE_MULTIPLE_BO_APPL .
  aliases POWL_TYPE_SINGLE_APPL
    for IF_DRF_CONST~POWL_TYPE_SINGLE_APPL .
  aliases POWL_TYPE_SINGLE_BO
    for IF_DRF_CONST~POWL_TYPE_SINGLE_BO .
  aliases PRODCUTION_BOO_ID
    for IF_MDG_IDSC_CONST~PRODCUTION_BOO_ID .
  aliases PRODUCTALLOCATIONPROCEDURE
    for IF_MDG_OTC_CONST~PRODUCTALLOCATIONPROCEDURE .
  aliases PRODUCTALLOCATIONPROCEDURE_ID
    for IF_MDG_IDSC_CONST~PRODUCTALLOCATIONPROCEDURE_ID .
  aliases PRODUCTION_BOM
    for IF_MDG_OTC_CONST~PRODUCTION_BOM .
  aliases PRODUCTION_BOM_ID
    for IF_MDG_IDSC_CONST~PRODUCTION_BOM_ID .
  aliases PRODUCTION_BOO
    for IF_MDG_OTC_CONST~PRODUCTION_BOO .
  aliases PRODUCTION_ORDER
    for IF_MDG_OTC_CONST~PRODUCTION_ORDER .
  aliases PRODUCTION_ORDER_ID
    for IF_MDG_IDSC_CONST~PRODUCTION_ORDER_ID .
  aliases PRODUCT_CATEGORY_HIERARCHY
    for IF_MDG_OTC_CONST~PRODUCT_CATEGORY_HIERARCHY .
  aliases PRODUCT_CATEGORY_INT_ID
    for IF_MDG_IDSC_CONST~PRODUCT_CATEGORY_INT_ID .
  aliases PRODUCT_EXT_ID
    for IF_MDG_IDSC_CONST~PRODUCT_EXT_ID .
  aliases PROFIT_CENTRE
    for IF_MDG_OTC_CONST~PROFIT_CENTRE .
  aliases PROFIT_CENTRE_GROUP
    for IF_MDG_OTC_CONST~PROFIT_CENTRE_GROUP .
  aliases PROFIT_CENTRE_GROUP_ID
    for IF_MDG_IDSC_CONST~PROFIT_CENTRE_GROUP_ID .
  aliases PROFIT_CENTRE_GRP_HIERARCHY
    for IF_MDG_OTC_CONST~PROFIT_CENTRE_GRP_HIERARCHY .
  aliases PROFIT_CENTRE_GRP_HIERARCHY_ID
    for IF_MDG_IDSC_CONST~PROFIT_CENTRE_GRP_HIERARCHY_ID .
  aliases PROFIT_CENTRE_ID
    for IF_MDG_IDSC_CONST~PROFIT_CENTRE_ID .
  aliases PROJECT
    for IF_MDG_OTC_CONST~PROJECT .
  aliases PROJECT_EXTERNAL_ID
    for IF_MDG_IDSC_CONST~PROJECT_EXTERNAL_ID .
  aliases PURCHASE_ORDER
    for IF_MDG_OTC_CONST~PURCHASE_ORDER .
  aliases PURCHASE_ORDER_ID
    for IF_MDG_IDSC_CONST~PURCHASE_ORDER_ID .
  aliases PURCHASINGDOCITEMCATEG
    for IF_MDG_OTC_CONST~PURCHASINGDOCITEMCATEG .
  aliases PURCHASINGDOC_ITEMCATEGORY_ID
    for IF_MDG_IDSC_CONST~PURCHASINGDOC_ITEMCATEGORY_ID .
  aliases PURCHASINGGROUP
    for IF_MDG_OTC_CONST~PURCHASINGGROUP .
  aliases PURCHASINGGROUP_ID
    for IF_MDG_IDSC_CONST~PURCHASINGGROUP_ID .
  aliases RANGE_OPTION_BETWEEN
    for IF_DRF_CONST~RANGE_OPTION_BETWEEN .
  aliases RANGE_OPTION_CP
    for IF_DRF_CONST~RANGE_OPTION_CP .
  aliases RANGE_OPTION_EQUAL
    for IF_DRF_CONST~RANGE_OPTION_EQUAL .
  aliases RANGE_OPTION_GE
    for IF_DRF_CONST~RANGE_OPTION_GE .
  aliases RANGE_OPTION_GT
    for IF_DRF_CONST~RANGE_OPTION_GT .
  aliases RANGE_OPTION_LE
    for IF_DRF_CONST~RANGE_OPTION_LE .
  aliases RANGE_OPTION_LT
    for IF_DRF_CONST~RANGE_OPTION_LT .
  aliases RANGE_OPTION_NB
    for IF_DRF_CONST~RANGE_OPTION_NB .
  aliases RANGE_OPTION_NOT_EQUAL
    for IF_DRF_CONST~RANGE_OPTION_NOT_EQUAL .
  aliases RANGE_OPTION_NP
    for IF_DRF_CONST~RANGE_OPTION_NP .
  aliases RANGE_SIGN_EXCLUSIVE
    for IF_DRF_CONST~RANGE_SIGN_EXCLUSIVE .
  aliases RANGE_SIGN_INCLUSIVE
    for IF_DRF_CONST~RANGE_SIGN_INCLUSIVE .
  aliases REGION
    for IF_MDG_OTC_CONST~REGION .
  aliases REGION_ID
    for IF_MDG_IDSC_CONST~REGION_ID .
  aliases RELID_RUNTIME
    for IF_DRF_CONST~RELID_RUNTIME .
  aliases REMOVE
    for IF_DRF_CONST~REMOVE .
  aliases REPLICATION_MODE
    for IF_USMD_CR_CONSTANTS~REPLICATION_MODE .
  aliases REPLICATION_STATUS_POSTED
    for IF_DRF_CONST~REPLICATION_STATUS_POSTED .
  aliases REPLICATION_STATUS_POST_ERROR
    for IF_DRF_CONST~REPLICATION_STATUS_POST_ERROR .
  aliases REPLICATION_STATUS_SEND_ERROR
    for IF_DRF_CONST~REPLICATION_STATUS_SEND_ERROR .
  aliases REPLICATION_STATUS_SENT
    for IF_DRF_CONST~REPLICATION_STATUS_SENT .
  aliases REPLICATION_STATUS_TO_BE_SEND
    for IF_DRF_CONST~REPLICATION_STATUS_TO_BE_SEND .
  aliases REPL_VIA_FILE
    for IF_DRF_CONST~REPL_VIA_FILE .
  aliases REPL_VIA_IDOC
    for IF_DRF_CONST~REPL_VIA_IDOC .
  aliases REPL_VIA_RFC
    for IF_DRF_CONST~REPL_VIA_RFC .
  aliases REPL_VIA_SERVICES
    for IF_DRF_CONST~REPL_VIA_SERVICES .
  aliases RETAIL_ARTICLE
    for IF_MDG_IDSC_CONST~RETAIL_ARTICLE .
  aliases RETAIL_ARTICLE_HIERARCHY_ID
    for IF_MDG_IDSC_CONST~RETAIL_ARTICLE_HIERARCHY_ID .
  aliases RETAIL_BONUS_BUY
    for IF_MDG_OTC_CONST~RETAIL_BONUS_BUY .
  aliases RETAIL_BONUS_BUY_ID
    for IF_MDG_IDSC_CONST~RETAIL_BONUS_BUY_ID .
  aliases RETAIL_CONSUMPTION_ID
    for IF_MDG_IDSC_CONST~RETAIL_CONSUMPTION_ID .
  aliases RETAIL_INVENTORY_ID
    for IF_MDG_IDSC_CONST~RETAIL_INVENTORY_ID .
  aliases RETAIL_LOCATION_PRODUCT_ID
    for IF_MDG_IDSC_CONST~RETAIL_LOCATION_PRODUCT_ID .
  aliases RETAIL_MAT_GRP_HIERARCHY_ID
    for IF_MDG_IDSC_CONST~RETAIL_MAT_GRP_HIERARCHY_ID .
  aliases RETAIL_MOVING_AVERAGE_PRICE_ID
    for IF_MDG_IDSC_CONST~RETAIL_MOVING_AVERAGE_PRICE_ID .
  aliases RETAIL_PLANT_CLASS_HIER_ID
    for IF_MDG_IDSC_CONST~RETAIL_PLANT_CLASS_HIER_ID .
  aliases RETAIL_PLANT_HIERARCHY_ID
    for IF_MDG_IDSC_CONST~RETAIL_PLANT_HIERARCHY_ID .
  aliases RETAIL_PROMOTIONS_ID
    for IF_MDG_IDSC_CONST~RETAIL_PROMOTIONS_ID .
  aliases RETAIL_SALES_PRICE_ID
    for IF_MDG_IDSC_CONST~RETAIL_SALES_PRICE_ID .
  aliases RETAIL_SOURCE_OF_SUPPLY_ID
    for IF_MDG_IDSC_CONST~RETAIL_SOURCE_OF_SUPPLY_ID .
  aliases RFC_DEST
    for IF_DRF_CONST~RFC_DEST .
  aliases RUNMOD_BYPASS_FILTER
    for IF_DRF_CONST~RUNMOD_BYPASS_FILTER .
  aliases RUNMOD_ORIGINAL
    for IF_DRF_CONST~RUNMOD_ORIGINAL .
  aliases RUNMOD_RESTART_ALL_OBJ
    for IF_DRF_CONST~RUNMOD_RESTART_ALL_OBJ .
  aliases RUNMOD_RESTART_ERR_OBJ
    for IF_DRF_CONST~RUNMOD_RESTART_ERR_OBJ .
  aliases RUNMOD_RESTART_SEL_OBJ
    for IF_DRF_CONST~RUNMOD_RESTART_SEL_OBJ .
  aliases SALES_FUNCTIONAL_UNIT
    for IF_MDG_OTC_CONST~SALES_FUNCTIONAL_UNIT .
  aliases SALES_FUNCTIONAL_UNIT_ID
    for IF_MDG_IDSC_CONST~SALES_FUNCTIONAL_UNIT_ID .
  aliases SALES_ORDER
    for IF_MDG_OTC_CONST~SALES_ORDER .
  aliases SALES_ORDER_KEY
    for IF_MDG_IDSC_CONST~SALES_ORDER_KEY .
  aliases SAP_APPLICATION_CONFIG_ID
    for IF_DRF_CONST~SAP_APPLICATION_CONFIG_ID .
  aliases SAVE
    for IF_DRF_CONST~SAVE .
  aliases SAVE_B
    for IF_DRF_CONST~SAVE_B .
  aliases SC_LPD_INSTANCE
    for IF_DRF_CONST~SC_LPD_INSTANCE .
  aliases SC_LPD_LINK_TEXT
    for IF_DRF_CONST~SC_LPD_LINK_TEXT .
  aliases SC_LPD_ROLE
    for IF_DRF_CONST~SC_LPD_ROLE .
  aliases SEARCH_HELP
    for IF_DRF_CONST~SEARCH_HELP .
  aliases SERVICE_CONTRACT
    for IF_MDG_OTC_CONST~SERVICE_CONTRACT .
  aliases SERVICE_CONTRACT_KEY
    for IF_MDG_IDSC_CONST~SERVICE_CONTRACT_KEY .
  aliases SERVICE_PRODUCT
    for IF_MDG_OTC_CONST~SERVICE_PRODUCT .
  aliases SERVICE_PRODUCT_ID
    for IF_MDG_IDSC_CONST~SERVICE_PRODUCT_ID .
  aliases SERV_IMPL_SAP_MAX
    for IF_DRF_CONST~SERV_IMPL_SAP_MAX .
  aliases SERV_IMPL_SAP_MIN
    for IF_DRF_CONST~SERV_IMPL_SAP_MIN .
  aliases SERV_OPER_INBOUND
    for IF_DRF_CONST~SERV_OPER_INBOUND .
  aliases SERV_OPER_OUTBOUND
    for IF_DRF_CONST~SERV_OPER_OUTBOUND .
  aliases SERV_OPER_SAP_MAX
    for IF_DRF_CONST~SERV_OPER_SAP_MAX .
  aliases SERV_OPER_SAP_MIN
    for IF_DRF_CONST~SERV_OPER_SAP_MIN .
  aliases SHOP_FLR_BILL_OF_OPERATION
    for IF_MDG_OTC_CONST~SHOP_FLR_BILL_OF_OPERATION .
  aliases SHP_FLR_BILL_OF_OP_ID
    for IF_MDG_IDSC_CONST~SHP_FLR_BILL_OF_OP_ID .
  aliases SITE
    for IF_MDG_OTC_CONST~SITE .
  aliases SORTFIELD_GENERAL
    for IF_DRF_CONST~SORTFIELD_GENERAL .
  aliases STORAGE_LOCATION
    for IF_MDG_OTC_CONST~STORAGE_LOCATION .
  aliases STORAGE_LOCATION_KEY
    for IF_MDG_IDSC_CONST~STORAGE_LOCATION_KEY .
  aliases SUPPLIER
    for IF_MDG_OTC_CONST~SUPPLIER .
  aliases SUPPLIER_ID
    for IF_MDG_IDSC_CONST~SUPPLIER_ID .
  aliases TABIX_1
    for IF_DRF_CONST~TABIX_1 .
  aliases TAXCODE
    for IF_MDG_OTC_CONST~TAXCODE .
  aliases TAXCODE_ID
    for IF_MDG_IDSC_CONST~TAXCODE_ID .
  aliases TRUE
    for IF_DRF_CONST~TRUE .
  aliases UNITSOFMEASURECODE
    for IF_MDG_OTC_CONST~UNITSOFMEASURECODE .
  aliases UNITSOFMEASURECODE_ID
    for IF_MDG_IDSC_CONST~UNITSOFMEASURECODE_ID .
  aliases UOM_GROUP
    for IF_MDG_OTC_CONST~UOM_GROUP .
  aliases UOM_GROUP_ID
    for IF_MDG_IDSC_CONST~UOM_GROUP_ID .
  aliases UPDATE
    for IF_DRF_CONST~UPDATE .
  aliases VALUE_MAPPING
    for IF_MDG_OTC_CONST~VALUE_MAPPING .
  aliases VARIANT
    for IF_DRF_CONST~VARIANT .
  aliases WARRANTY
    for IF_MDG_OTC_CONST~WARRANTY .
  aliases WARRANTY_ID
    for IF_MDG_IDSC_CONST~WARRANTY_ID .
  aliases WBS_ELEMENT
    for IF_MDG_OTC_CONST~WBS_ELEMENT .
  aliases WBS_ELEMENT_ID
    for IF_MDG_IDSC_CONST~WBS_ELEMENT_ID .
  aliases WBS_EXTERNAL_ID
    for IF_MDG_IDSC_CONST~WBS_EXTERNAL_ID .
  aliases WD_APP_CONFIG_ID
    for IF_DRF_CONST~WD_APP_CONFIG_ID .
  aliases WORKCENTER
    for IF_MDG_OTC_CONST~WORKCENTER .
  aliases WORK_CENTRE_ID
    for IF_MDG_IDSC_CONST~WORK_CENTRE_ID .
  aliases X
    for IF_DRF_CONST~X .
  aliases Y
    for IF_DRF_CONST~Y .
  aliases YES
    for IF_DRF_CONST~YES .
  aliases GTY_S_ATTRIBUTE_ENTITY_REL
    for YZ_INTF_MDG_DATA_TYPES~GTY_S_ATTRIBUTE_ENTITY_REL .
  aliases GTY_S_CHANGE_DOCUMENT
    for YZ_INTF_MDG_DATA_TYPES~GTY_S_CHANGE_DOCUMENT .
  aliases GTY_S_DEPENDENT_ENTITIES
    for YZ_INTF_MDG_DATA_TYPES~GTY_S_DEPENDENT_ENTITIES .
  aliases GTY_S_ENTITY_ATTRIBUTE
    for YZ_INTF_MDG_DATA_TYPES~GTY_S_ENTITY_ATTRIBUTE .
  aliases GTY_S_ENTITY_ATTRIBUTES_REL
    for YZ_INTF_MDG_DATA_TYPES~GTY_S_ENTITY_ATTRIBUTES_REL .
  aliases GTY_S_ENTITY_DATA
    for YZ_INTF_MDG_DATA_TYPES~GTY_S_ENTITY_DATA .
  aliases GTY_S_ENTITY_INFO
    for YZ_INTF_MDG_DATA_TYPES~GTY_S_ENTITY_INFO .
  aliases GTY_S_ENTITY_UIBB_MAPPING
    for YZ_INTF_MDG_DATA_TYPES~GTY_S_ENTITY_UIBB_MAPPING .
  aliases GTY_S_ENT_PROP
    for YZ_INTF_MDG_DATA_TYPES~GTY_S_ENT_PROP .
  aliases GTY_S_FLD_PROP
    for YZ_INTF_MDG_DATA_TYPES~GTY_S_FLD_PROP .
  aliases GTY_S_KEY_VALUE
    for YZ_INTF_MDG_DATA_TYPES~GTY_S_KEY_VALUE .
  aliases GTY_T_ADDRESS
    for YZ_INTF_MDG_DATA_TYPES~GTY_T_ADDRESS .
  aliases GTY_T_ATTRIBUTE_ENTITY_REL
    for YZ_INTF_MDG_DATA_TYPES~GTY_T_ATTRIBUTE_ENTITY_REL .
  aliases GTY_T_CHANGE_DOCUMENT
    for YZ_INTF_MDG_DATA_TYPES~GTY_T_CHANGE_DOCUMENT .
  aliases GTY_T_DEPENDENT_ENTITIES
    for YZ_INTF_MDG_DATA_TYPES~GTY_T_DEPENDENT_ENTITIES .
  aliases GTY_T_ENTITY_ATTRIBUTE
    for YZ_INTF_MDG_DATA_TYPES~GTY_T_ENTITY_ATTRIBUTE .
  aliases GTY_T_ENTITY_ATTRIBUTES_REL
    for YZ_INTF_MDG_DATA_TYPES~GTY_T_ENTITY_ATTRIBUTES_REL .
  aliases GTY_T_ENTITY_DATA
    for YZ_INTF_MDG_DATA_TYPES~GTY_T_ENTITY_DATA .
  aliases GTY_T_ENTITY_INFO
    for YZ_INTF_MDG_DATA_TYPES~GTY_T_ENTITY_INFO .
  aliases GTY_T_ENTITY_UIBB_MAPPING
    for YZ_INTF_MDG_DATA_TYPES~GTY_T_ENTITY_UIBB_MAPPING .
  aliases GTY_T_FLD_PROP
    for YZ_INTF_MDG_DATA_TYPES~GTY_T_FLD_PROP .
  aliases GTY_T_KEY_VALUE
    for YZ_INTF_MDG_DATA_TYPES~GTY_T_KEY_VALUE .

  types:
    BEGIN OF gtyp_role,
        uname    TYPE xubname,
        pernr    TYPE pernr-pernr,
        agr_name TYPE agr_name,
      END OF gtyp_role .
  types:
    BEGIN OF gtyp_loopwf,
        def_id    TYPE yz_dtel_def_id,
        cwf_step  TYPE usmd_ssw_crequest_step,
        nwf_step  TYPE usmd_ssw_crequest_step,
        cr_status TYPE usmd_crequest_status,
      END OF gtyp_loopwf .
  types:
    BEGIN OF gty_entity_key_data,
        entity TYPE usmd_entity,
        BEGIN OF ty_key,
          fieldname TYPE string,
          value     TYPE string,
        END OF ty_key,
      END OF gty_entity_key_data .
  types:
    tt_roles            TYPE STANDARD TABLE OF gtyp_role WITH DEFAULT KEY .
  types:
    gtt_entity_key_data TYPE SORTED TABLE OF gty_entity_key_data WITH NON-UNIQUE KEY entity .
  types:
    BEGIN OF gty_entity_key,
        entity    TYPE usmd_entity,
        field     TYPE string,
        key_value TYPE string,
      END OF gty_entity_key .
  types:
    BEGIN OF gty_entity_attr,
        entity     TYPE usmd_entity,
        attribute  TYPE usmd_attribute,
        attr_value TYPE string,
        tabname    TYPE tabname,
        fieldname  TYPE fieldname,
      END OF gty_entity_attr .
  types:
*    gtt_entity_attr TYPE SORTED TABLE OF gty_entity_attr WITH NON-UNIQUE KEY tabname fieldname .
    gtt_entity_attr TYPE STANDARD TABLE OF gty_entity_attr WITH NON-UNIQUE KEY entity attribute attr_value tabname fieldname .
  types:
    gtt_balmi       TYPE STANDARD TABLE OF balmi .
  types:
    ty_attributes   TYPE STANDARD TABLE OF usmd_attribute .
  types:
    BEGIN OF ty_user_agent_from_ag,
        agr_name TYPE agr_name,
        uname    TYPE xubname,
      END OF ty_user_agent_from_ag .
  types:
    BEGIN OF ty_agr_name,
        agr_name TYPE agr_name,
      END OF ty_agr_name .
  types:
    tt_user_agent_from_ag      TYPE TABLE OF ty_user_agent_from_ag .
  types:
    tt_agr_name                TYPE TABLE OF ty_agr_name .
  types:
    tt_user_list_from_position TYPE TABLE OF tree_objec .
  types:
    tt_department              TYPE TABLE OF ad_dprtmnt .
  types:
    tt_function                TYPE TABLE OF ad_fnctn .
  types:
    BEGIN OF gtyp_yyorgunit,
        department TYPE ad_dprtmnt,
        function   TYPE ad_fnctn,
        job        TYPE hrobjid,
        person     TYPE pernr-pernr,
        position   TYPE hrobjid,
        user       TYPE syuname,
        role       TYPE agr_name,
      END OF gtyp_yyorgunit .
  types:
    tt_yyorgunit TYPE STANDARD TABLE OF gtyp_yyorgunit WITH DEFAULT KEY .
  types:
    BEGIN OF gtyp_yyusage,
        cr_type   TYPE usmd_crequest_type,
        cr_step   TYPE usmd_crequest_appstep,
        " attribute related to MASS,MDC, DQM to be added by respective developer
        rule_stag TYPE mdq_rule_stage,
      END OF gtyp_yyusage .
  types:
    tt_yyusage TYPE STANDARD TABLE OF gtyp_yyusage WITH DEFAULT KEY .
  types:
    BEGIN OF ts_changed_fields,
        usmd_entity TYPE usmd_entity,
        fieldname   TYPE RANGE OF usmd_fieldname,
      END OF ts_changed_fields .
  types:
    tt_changed_fields TYPE SORTED TABLE OF ts_changed_fields WITH NON-UNIQUE KEY primary_key COMPONENTS usmd_entity .
  types:
    ty_t_usvalues TYPE STANDARD TABLE OF usvalues .
  types:
    BEGIN OF ty_s_xufield,
        field           TYPE c LENGTH 10,
        tab_name        TYPE c LENGTH 16,
        tab_field_name  TYPE c LENGTH 30,
        model_fieldname TYPE usmd_fieldname,
        entity          TYPE usmd_entity.
    TYPES: END OF ty_s_xufield .
  types:
    ty_t_xufield TYPE STANDARD TABLE OF  ty_s_xufield WITH KEY field .
  types:
    BEGIN OF ty_s_auth_object,
        auth_object TYPE xuobject,
        input_dep   TYPE char1,
        auth_fields TYPE ty_t_xufield.
    TYPES:END OF ty_s_auth_object .
  types:
    ty_t_auth_object TYPE SORTED TABLE OF ty_s_auth_object WITH UNIQUE KEY auth_object .
  types:
    BEGIN OF ty_reuse_table,
        table TYPE usmd_tab_source,
      END OF ty_reuse_table .
  types:
    tty_reuse_table TYPE SORTED TABLE OF  ty_reuse_table WITH UNIQUE KEY table .
  types:
    BEGIN OF  gty_s_reuse_attr_map ,
        reuse_table         TYPE  usmd_tab_source,
        reuse_fieldname     TYPE  usmd_pp_fieldname,
        is_key              TYPE  boolean,
        rollname            TYPE  rollname,
        model_fieldname     TYPE  usmd_fieldname,
        deviating_fieldname TYPE  usmd_pp_fieldname,
        deviating_fieldtext TYPE  usmd_desc,
        entity              TYPE usmd_entity,
      END OF gty_s_reuse_attr_map .
  types:
    gty_t_reuse_attr_map TYPE STANDARD TABLE OF  gty_s_reuse_attr_map .
  types:
    BEGIN OF tys_message,
        msg_text      TYPE string,
        msgid         TYPE symsgid,
        msgty         TYPE  symsgty,
        msgno	        TYPE symsgno,
        msgv1	        TYPE symsgv,
        msgv2	        TYPE symsgv,
        msgv3	        TYPE symsgv,
        msgv4	        TYPE symsgv,
        row           TYPE n LENGTH 6,
        fieldname     TYPE fieldname,
        has_long_text TYPE boole_d,
        prio          TYPE i,
        style         TYPE lvc_t_styl,
        status        TYPE iconname,
      END OF tys_message .
  types:
    ty_t_message  TYPE STANDARD TABLE OF tys_message .
  types:
    BEGIN OF tys_data_2pp,
        is_usable_mapping  TYPE char1,
        is_used_mapping    TYPE char1,
        entity_kind        TYPE char18,
        entity             TYPE char13,
        is_disabled_entity TYPE char1,
        field_kind         TYPE char10,
        from_field         TYPE char255,
        is_disabled_field  TYPE char1,
        to_field           TYPE char255,
        trans_group        TYPE n LENGTH 5,
        is_disabled        TYPE char1,
        is_compl_trans     TYPE char1,
        is_extension       TYPE char1,
        pp_structure       TYPE char30,
        fc_structure       TYPE char30,
        fp_structure       TYPE char30,
        smt_appl           TYPE char30,
        event              TYPE char30,
        sstructure         TYPE char30,
        tstructure         TYPE char30,
      END OF tys_data_2pp .
  types:
    ty_t_data_2pp TYPE STANDARD TABLE OF tys_data_2pp .

  class-data:
    gr_fieldname TYPE RANGE OF usmd_fieldname .
  class-data:
    gt_changed_fields TYPE SORTED TABLE OF ts_changed_fields WITH NON-UNIQUE KEY primary_key COMPONENTS usmd_entity .
  class-data GT_YYORGUNIT type TT_YYORGUNIT .
  class-data GT_YYUSAGE type TT_YYUSAGE .
  constants GC_YYORGUNIT type USMD_ENTITY value 'YYORGUNIT' ##NO_TEXT.
  constants GC_YYUSAGE type USMD_ENTITY value 'YYUSAGE' ##NO_TEXT.
  class-data GC_MODEL type USMD_MODEL .
  constants GC_READMODE_ACT_INACT type USMD_READMODE value '2' ##NO_TEXT.
  constants GC_READMODE_ACT_ONLY type USMD_READMODE value '3' ##NO_TEXT.
  constants GC_READMODE_INACT_ONLY type USMD_READMODE value '4' ##NO_TEXT.
  class-data GO_MDG_API type ref to IF_USMD_CONV_SOM_GOV_API .
  class-data GS_CREQUEST_ATTRIBUTES type USMD_S_CREQUEST read-only .
  class-data:
    gt_entity_key TYPE STANDARD TABLE OF gty_entity_key WITH NON-UNIQUE KEY entity field key_value .
  class-data GT_ENTITY_KEYS type USMD_TS_ENTITY_CONT .
  class-data GT_RCPT_SAPID type USMD_T_USER_AGENT read-only .
  class-data GT_ATTRIBUTE_ENTITY_REL type GTY_T_ATTRIBUTE_ENTITY_REL .
  data GT_ENTITY_ATTRIBUTES_REL type GTY_T_ENTITY_ATTRIBUTES_REL .
  data GO_MODEL type ref to IF_USMD_MODEL_EXT .
  class-data GT_DEPENDENT_ENTITIES type GTY_T_DEPENDENT_ENTITIES .
  class-data GV_CREQUEST type USMD_CREQUEST read-only .
  class-data GV_CREQUEST_STATUS type USMD_CREQUEST_STATUS .
  class-data GV_CREQUEST_STEP type USMD_SSW_CREQUEST_STEP .
  class-data GV_PARNUM type EDI_SNDPRN .
  class-data GV_USER_LANGU type LAISO .
  class-data LT_KEY_DATA type GTT_ENTITY_KEY_DATA .
  constants GC_GET type STRING value 'GET_' ##NO_TEXT.
  constants GC_SET type STRING value 'SET_' ##NO_TEXT.
  constants GC_DEL type STRING value 'DEL_' ##NO_TEXT.
  class-data GV_APPSTEP type USMD_CREQUEST_APPSTEP .
  constants GC_KATTR type STRING value 'KATTR' ##NO_TEXT.
  constants ABORT type BAPI_MTYPE value 'A' ##NO_TEXT.
  constants ERROR type BAPI_MTYPE value 'E' ##NO_TEXT.
  constants EXIT type BAPI_MTYPE value 'X' ##NO_TEXT.
  constants INFO type BAPI_MTYPE value 'I' ##NO_TEXT.
  constants SUCCESS type BAPI_MTYPE value 'S' ##NO_TEXT.
  constants WARNING type BAPI_MTYPE value 'W' ##NO_TEXT.
  class-data GV_MODEL type USMD_MODEL .
  class-data GT_ATTR_AND_KEYS_REST type MDG_BS_MAT_T_PROP_ENTIES .
  class-data GT_ENTITY_STRUC type MDG_BS_MAT_T_ENTY_STR .
  class-data GS_ENTITY_STRUC type MDG_BS_MAT_S_ENTY_STR .
  class-data GT_MERGED_MAPPING_FINAL type MDG_BS_MAT_T_SMT_FLD_MAPPINF_D .
  class-data GT_ALL_ENTITY type USMD_T_ENTITY .
  class-data GT_MAPPED_ENTITY type USMD_T_ENTITY .
  class-data GT_RMAPPED_ENTITY type USMD_T_ENTITY .
  class-data GT_RNMAPPED_ENTITY type USMD_T_ENTITY .
  class-data GT_FLEX_ENTITY type USMD_T_ENTITY .
  class-data GT_FLEXMAPPED_ENTITY type USMD_T_ENTITY .
  class-data GT_FLEXNMAPPED_ENTITY type USMD_T_ENTITY .
  class-data GV_MAP_TO_PP type BOOLE_D .
  class-data GV_GROUP type I .
  class-data GV_IS_USABLE_MAPPING type BOOLE .
  class-data GV_IS_USED_MAPPING type BOOLE .
  class-data GV_ENTITY_KIND type CHAR18 .
  class-data GV_IS_COMPL_TRANS type BOOLE .
  class-data GV_IS_EXTENSION type BOOLE .
  class-data GV_ENTITY type CHAR13 .
  class-data GV_ENTITY1 type USMD_ENTITY .
  class-data GV_DISABLED_ENTITY type BOOLE .
  class-data GV_PP_STRUCTURE type CHAR30 .
  class-data GV_FC_STRUCTURE type CHAR30 .
  class-data GV_FP_STRUCTURE type CHAR30 .
  class-data GS_MESSAGE type TYS_MESSAGE .
  class-data GV_MESSAGE type STRING .
  class-data GV_STRUC_TXT type SMT_STRUCTURE .
  class-data GT_CONSIDERED_ENTITIES type USMD_T_ENTITY .
  class-data GV_STRUC_ATTR type SMT_STRUCTURE .
  class-data GT_ENABLED_ATTR_USUAL type MDG_BS_MAT_T_SMT_FIELD .
  class-data GT_DISABLED_ATTR_USUAL type MDG_BS_MAT_T_SMT_FIELD .
  class-data GT_ENABLED_ATTR_TXT_USUAL type MDG_BS_MAT_T_SMT_FIELD .
  class-data GT_DISABLED_ATTR_TXT_USUAL type MDG_BS_MAT_T_SMT_FIELD .
  class-data GT_ATTR_USUAL type MDG_BS_MAT_T_SMT_FIELD .
  class-data GT_ATTR_TXT_USUAL type MDG_BS_MAT_T_SMT_FIELD .
  class-data GT_DISABLED_FIELDS_USUAL type MDG_BS_MAT_T_SMT_FIELD .

  class-methods GET_MAPPING
    importing
      !IV_MODEL type USMD_MODEL
    exporting
      !ET_DATA type TY_T_DATA_2PP
      !ET_MESSAGES type TY_T_MESSAGE .
  class-methods GET_ENTITY_DETAILS
    importing
      !IV_MODEL type USMD_MODEL
      !IT_MODEL_ATTRIBUTES type USMD_TS_ENTITY_FIELDNAME
      !IV_MAIN_ENTITY type USMD_ENTITY optional
    exporting
      !EV_MAIN_TABLE type USMD_TAB_SOURCE
      !ET_REUSE_ATTRIBUTES type GTY_T_REUSE_ATTR_MAP
      !ET_REUSE_TABLE type TTY_REUSE_TABLE
      !ET_MESSAGES type TY_T_MESSAGE
    changing
      !CT_MAPPING_INFO type ref to MDG_HDB_TT_REUSE_MAPPING optional .
  class-methods ACTIVATE_CR_WITH_SELECTION
    importing
      !IV_USMD_CREQUEST type USMD_CREQUEST optional
      !IV_DAYS type CHAR3 optional
    exporting
      !ET_MESSAGE type USMD_T_MESSAGE .
  class-methods ADD_TO_GLOBAL_MESSAGE
    importing
      !IO_FPM type ref to IF_FPM optional
      !IT_MESSAGE type USMD_T_MESSAGE
    returning
      value(RV_EVENT_RESULT) type FPM_EVENT_RESULT .
  class-methods APPEND_ENTITY_KEYS_DERIVATION
    importing
      !IV_ENTITY type USMD_ENTITY
      !IT_DATA type ANY TABLE .
  class-methods ARE_YOU_AUTH_FOR_CR_TYPE
    importing
      !IV_CREQUEST_TYPE type USMD_CREQUEST_TYPE
    returning
      value(RV_BOOL) type BOOLEAN .
  class-methods ASSIGN_TO
    importing
      !COMPONENT_NAME type STRING
      !VALUE type ANY
    changing
      !STRUCTURE type ANY
    returning
      value(RV_SUBRC) type SY-SUBRC .
  class-methods ASSIGN_USER_TO_CREQUEST
    importing
      !IV_CREQUEST type USMD_CREQUEST
      !IV_USERNAME type XUBNAME
    exporting
      !ET_MESSAGE type USMD_T_MESSAGE .
  class-methods CHECK_CR_EXISTANCE
    importing
      !IV_CREQUEST type USMD_CREQUEST
    returning
      value(RV_EXIST) type BOOLEAN .
  class-methods CHECK_ENTITY_LOCK_STATUS
    importing
      !IV_ENTITY_TYPE type USMD_ENTITY
      !IS_ENTITY_ROW type ANY
    returning
      value(RV_CREQUEST) type USMD_CREQUEST .
  class-methods CONSTRUCT_URL
    importing
      !IM_CR type USMD_CREQUEST optional
      !IV_WF_ID type SWW_WIID optional
      !IV_APPLICATION_NAME type STRING optional
      !IV_ACTION type STRING optional
      !IN_PARAMETERS type TIHTTPNVP optional
    exporting
      !EV_URL type STRING
    returning
      value(RV_URL) type STRING .
  class-methods CONVERT_MESSAGE_USMD_TO_FPM
    importing
      !IT_USMD_MESSAGE type USMD_T_MESSAGE
    returning
      value(RT_FPM_MESSAGE) type FPMGB_T_MESSAGES .
  class-methods CONVERT_NOTE_STRING
    importing
      !IS_NOTE type USMD_S_CREQUEST_NOTE
    returning
      value(RO_NOTE_TXT) type ref to CL_WD_FORMATTED_TEXT .
  class-methods COPY_CR_FROM_SYSTEMS
    importing
      !IV_CREQUEST type USMD_CREQUEST
      !IV_RFCDEST type RFCDEST default 'NONE'
    exporting
      !ET_MESSAGE type ANY
    returning
      value(RV_CREQUEST) type USMD_CREQUEST .
  methods COPY_DECISION_TABLE
    importing
      !IV_NAME type STRING
      !IT_DECISION_TAB type IF_FDT_DECISION_TABLE=>TS_TABLE_DATA .
  methods COPY_TO
    importing
      !IV_CRTYPE type STRING .
  class-methods CREATE_DEPENDENT_ENTITIES
    importing
      !IV_ENTITY type USMD_ENTITY
      !IS_RECORD type ANY .
  class-methods DELETE_CR_WITH_SELECTION
    importing
      !IV_USMD_CREQUEST type USMD_CREQUEST optional
      !IV_DAYS type CHAR3 optional
    exporting
      !ET_MESSAGE type USMD_T_MESSAGE .
  class-methods DELETE_FROM_GLOBAL_MESSAGE
    importing
      !IT_MESSAGE type USMD_T_MESSAGE optional
      !IT_MESSAGES type CRMT_GENIL_MESSAGE_TAB optional .
  class-methods EXECUTE_AND_CONDITION
    importing
      !IV_OPERAND1 type BOOLE_D
      !IV_OPERAND2 type BOOLE_D
    returning
      value(RV_RESULT) type BOOLE_D .
  class-methods EXECUTE_BADI_CONTROL_CALL
    importing
      !IV_METHOD_NAME type STRING
      !IO_MODEL type ref to IF_USMD_MODEL_EXT optional
      !ID_EDITION type USMD_EDITION optional
      !ID_CREQUEST type USMD_CREQUEST optional
      !ID_ENTITYTYPE type USMD_ENTITY optional
      !IF_ONLINE_CHECK type USMD_FLG default ABAP_TRUE
      !IT_DATA type ANY TABLE optional
      !IO_CHANGED_DATA type ref to IF_USMD_DELTA_BUFFER_READ optional
      !IO_WRITE_DATA type ref to IF_USMD_DELTA_BUFFER_WRITE optional
    exporting
      !ET_MESSAGE_INFO type USMD_T_MESSAGE
      !ET_MESSAGE type USMD_T_MESSAGE
    changing
      !CT_DATA type ANY TABLE optional
    returning
      value(RV_BADI_EXECUTED) type BOOLEAN .
  class-methods EXECUTE_CONDITIONAL_OPERATOR
    importing
      !IV_OPERAND1 type BOOLE_D optional
      !IV_OPERAND2 type BOOLE_D optional
      !IV_OPERATOR type CHAR3 optional
    returning
      value(RV_RESULT) type BOOLE_D .
  class-methods EXECUTE_OR_CONDITION
    importing
      !IV_OPERAND1 type BOOLE_D
      !IV_OPERAND2 type BOOLE_D
    returning
      value(RV_RESULT) type BOOLE_D .
  class-methods FORWARD_CR_WITH_SELECTION
    importing
      !IV_USMD_CREQUEST type USMD_CREQUEST optional
      !IV_DAYS type CHAR3 optional
      !IV_USER type SY-UNAME default SY-UNAME
    exporting
      !ET_MESSAGE type USMD_T_MESSAGE .
  class-methods GET_AGENTS_FROM_ORG_MGMT
    importing
      !IV_CREQUEST type USMD_CREQUEST optional
      !IV_POSITION type HR_MCSHORT optional
      !CR_TYPE type USMD_CREQUEST_TYPE optional
      !CR_STEP type USMD_SSW_CREQUEST_STEP optional
    exporting
      !ET_AGENTS type USMD_T_USER_AGENT
    returning
      value(RV_S_ID) type HROBJID .
  class-methods GET_APPLICATION_PARAMETER
    importing
      !IT_PARAMETER type FPMGB_T_PARAM_VALUE optional
    exporting
      !EV_ACTION type BS_ACTION
      !EV_CR_ID type USMD_CREQUEST
      !EV_CR_TYPE type USMD_CREQUEST_TYPE
      !EV_ENTITY type USMD_ENTITY
      !EV_MODEL type USMD_MODEL
      !EV_OTC type USMD_OTC
      !EV_SEARCH_EDITION_MODE type ABAP_BOOL
      !EV_EDITION type USMD_EDITION
      !EV_HIERARCHY_ENTITY type USMD_ENTITY .
  class-methods GET_BRF_ELEMENT
    importing
      !IV_NAME type IF_FDT_TYPES=>NAME
      !IV_CR_NUMBER type USMD_CREQUEST
    returning
      value(RV_FDT_UUID) type FDT_UUID .
  class-methods GET_BRF_ELEMENT_ID
    importing
      !IV_NAME type IF_FDT_TYPES=>NAME
      !IV_FRAMEWORK_RESULT type BOOLE_D
      !IV_CR_NUMBER type USMD_CREQUEST
    exporting
      !ET_RULE_CONTEXT_VALUE type USMD_T_FDT_CONTEXT_VALUE .
  class-methods GET_BUSINESS_OBJECT_TYPE
    returning
      value(RV_USMD_OTC) type USMD_OTC .
  class-methods GET_CLASS_BY_IMPL_INTERFACE
    importing
      !IV_INTERFACE_NAME type SEOCLSKEY
    returning
      value(RT_CLASS_NAME) type SEOR_IMPLEMENTING_KEYS .
  class-methods GET_COUNTRY_FROM_COMPCODE
    importing
      !IV_COMPCODE type BUKRS
    exporting
      !RV_COUNTRY type LAND1 .
  class-methods GET_COUNTRY_FROM_SALESORG
    importing
      !IV_SALESORG type VKORG
    returning
      value(RV_COUNTRY) type LAND1 .
  class-methods GET_CR_ACTION
    importing
      !IV_CREQUEST type USMD_CREQUEST optional
    returning
      value(RV_USMD_ACTION) type USMD_ACTION .
  class-methods GET_CR_ACTIVATION_STATUS
    importing
      !IV_USMD_CREQUEST type USMD_CREQUEST optional
    returning
      value(RV_USMD_DATA_ACTIVATED) type USMD_DATA_ACTIVATED .
  class-methods GET_CR_API
    importing
      !IV_CREQUEST type USMD_CREQUEST
    exporting
      !ET_MESSAGE type USMD_T_MESSAGE
    returning
      value(RO_CR_API) type ref to IF_USMD_CREQUEST_API .
  class-methods GET_CR_ATTRIBUTES
    importing
      !IV_CREQUEST type USMD_CREQUEST
    returning
      value(RS_CREQUEST_ATTRIBUTES) type USMD_S_CREQUEST .
  class-methods GET_CR_BUSINESS_ACTIVITY
    importing
      !IV_CREQUEST_TYPE type USMD_CREQUEST_TYPE optional
    returning
      value(RV_PROCESS) type USMD_PROCESS .
  class-methods GET_CR_CHANGE_DOCUMENT
    importing
      !IV_CREQUEST type USMD_CREQUEST optional
      !IO_MODEL type ref to IF_USMD_MODEL optional
    exporting
      !ET_DOCUMENT_HEADER type CL_USMD_MDF_CHANGE_DOCUMENT=>T_DOCUMENT_HEADER
    returning
      value(RT_CHANGED_DOC) type USMD_T_CHANGE_DOCUMENT_CHANGE .
  class-methods GET_CR_CONTEXT_API
    returning
      value(RO_CR_CONTEXT_API) type ref to IF_USMD_APP_CONTEXT .
  class-methods GET_CR_CONV_API
    importing
      !IV_CREQUEST type USMD_CREQUEST
    returning
      value(RO_CR_CONV_API) type ref to IF_USMD_CONV_SOM_GOV_API .
  class-methods GET_CR_DETAILS
    importing
      !IV_CR_NUMBER type USMD_CREQUEST
    returning
      value(RV_CREQUEST) type USMD120C .
  class-methods GET_CR_ENTITIES_BY_MODEL
    importing
      !IV_MODEL type USMD_MODEL optional
    returning
      value(RT_ENTITY) type USMD_T_ENTITY .
  class-methods GET_CR_ENTITY_DATA
    importing
      !IV_USMD_CREQUEST type USMD_CREQUEST optional
      !IV_UPDATE_SNAPSHOT type FLAG optional
    returning
      value(RT_USMD_TS_DATA_ENTITY) type USMD_TS_DATA_ENTITY .
  class-methods GET_CR_ENTITY_KEY_DATA
    importing
      !IV_CREQUEST type USMD_CREQUEST
      !IV_ENTITY type USMD_ENTITY
      !IT_DATA type ANY TABLE
    returning
      value(RT_KEY) type USMD_GOV_API_TS_ENT_TABL .
  class-methods GET_CR_GOV_API
    importing
      !IV_CREQUEST type USMD_CREQUEST
    exporting
      !ET_MESSAGE type USMD_T_MESSAGE
    returning
      value(RO_GOV_API) type ref to IF_USMD_GOV_API .
  class-methods GET_CR_MAIN_ENTITY
    importing
      !IV_MODEL type USMD_MODEL optional
      !IV_OTC type USMD_OTC optional
      !IV_CREQUEST type USMD_CREQUEST optional
      !IV_USMD_CREQUEST_TYPE type USMD_CREQUEST_TYPE optional
    returning
      value(RV_ENTITY) type USMD_ENTITY .
  class-methods GET_CR_MDG_CP_STATUS
    importing
      !IV_USMD_CREQUEST type USMD_CREQUEST
    returning
      value(RV_ALREADY_PROCESSED) type BOOLEAN .
  class-methods GET_CR_NOTES
    importing
      !IV_CREQUEST type USMD_CREQUEST
    returning
      value(RT_NOTE) type USMD_T_CREQUEST_NOTE .
  class-methods GET_CR_NUMBER
    returning
      value(RV_USMD_CREQUEST) type USMD_CREQUEST .
  class-methods GET_CR_NUMBER_FROM_URL
    returning
      value(RV_CREQUEST) type USMD_CREQUEST .
  class-methods GET_CR_SNAPSHOT_API
    returning
      value(RO_SNAPSHOT) type ref to IF_USMD_MODEL_SNAPSHOT .
  class-methods GET_CR_DELTA_BUFFER
    returning
      value(RO_INSTANCE) type ref to CL_USMD_DELTA_BUFFER .
  class-methods GET_CR_STATUS
    importing
      !IV_USMD_CREQUEST type USMD_CREQUEST optional
    exporting
      !ET_MESSAGE type USMD_T_MESSAGE
    returning
      value(RV_USMD_CREQUEST_STATUS) type USMD_CREQUEST_STATUS .
  class-methods GET_CR_STEP
    importing
      !IV_CR_ID type USMD_CREQUEST optional
    returning
      value(RV_USMD_CREQUEST_APPSTEP) type USMD_CREQUEST_APPSTEP .
  class-methods GET_CR_OTC
    importing
      !IV_MODEL type USMD_MODEL optional
      !IV_CR_ID type USMD_CREQUEST optional
    returning
      value(RV_OTC) type USMD_OTC .
  class-methods GET_CR_TYPE
    importing
      !IV_CREQUEST type USMD_CREQUEST optional
    returning
      value(RV_USMD_CREQUEST_TYPE) type USMD_CREQUEST_TYPE .
  class-methods GET_CR_TYPE_FROM_URL
    returning
      value(RV_CR_TYPE) type USMD_CREQUEST_TYPE .
  class-methods GET_CR_USMD_MODEL_API
    importing
      !IV_USMD_MODEL type USMD_MODEL optional
    exporting
      !ET_MESSAGE type USMD_T_MESSAGE
    returning
      value(RO_MODEL) type ref to IF_USMD_MODEL .
  class-methods GET_CR_USMD_MODEL_EXT_API
    importing
      !IV_CREQUEST type USMD_CREQUEST optional
      !IV_USMD_MODEL type USMD_MODEL optional
    exporting
      !ET_MESSAGE type USMD_T_MESSAGE
    returning
      value(RO_MODEL_EXT) type ref to IF_USMD_MODEL_EXT .
  class-methods GET_CR_CHANGED_FIELDS
    importing
      !IV_CREQUEST type USMD_CREQUEST optional
      !IV_ENTITY type USMD_ENTITY optional
      !IO_MODEL_EXT type ref to IF_USMD_MODEL_EXT
    exporting
      value(ET_ENTITY_FIELDNAME) type USMD_TS_ENTITY_FIELDNAME
    returning
      value(RT_CHANGED_FIELDS) type TT_CHANGED_FIELDS .
  class-methods GET_CR_CHANGED_ENTITY
    importing
      !IO_CHANGED_DATA type ref to IF_USMD_DELTA_BUFFER_READ optional
    returning
      value(RT_ENTITY) type USMD_T_ENTITY .
  class-methods GET_CURRENT_DQM_RULE_ID
    importing
      !IV_MDQLTYTECHNICALRULEUUID type C_MDQUALITYTECHNICALRULE-MDQLTYTECHNICALRULEUUID
    exporting
      value(EV_MDQUALITYBUSINESSRULEUUID) type C_MDQUALITYTECHNICALRULE-MDQUALITYBUSINESSRULEUUID
    returning
      value(RV_MDQUALITYBUSINESSRULE) type C_MDQUALITYTECHNICALRULE-MDQUALITYBUSINESSRULE .
  class-methods GET_CURRENT_EVENT
    returning
      value(RV_CURRENT_EVENT_ID) type FPM_EVENT_ID .
  class-methods GET_DATA_MODEL
    importing
      !IV_CREQUEST type USMD_CREQUEST optional
    returning
      value(RV_USMD_MODEL) type USMD_MODEL .
  methods GET_DECISION_TAB_DATA
    importing
      !IV_NAME type STRING
    returning
      value(RT_DECISION_TAB) type IF_FDT_DECISION_TABLE=>TS_TABLE_DATA .
  methods GET_DECISION_TAB_OBJECT
    importing
      !IV_NAME type STRING
    returning
      value(RO_OBJECT) type ref to CL_FDT_DECISION_TABLE .
  class-methods GET_DERIVE_WRITE_REFERENCES
    importing
      !IO_MODEL type ref to IF_USMD_MODEL_EXT
      !IV_FIELDNAME type USMD_FIELDNAME
      !IF_INCL_EDITION_FLD type USMD_FLG default SPACE
    exporting
      !ER_S_WRITE type ref to DATA
      !ER_T_WRITE type ref to DATA
      !ET_MESSAGE type USMD_T_MESSAGE .
  class-methods GET_DESCRIPTION
    importing
      !IV_CREQUEST type USMD_CREQUEST
    returning
      value(RV_DESCRIPTION) type STRING .
  class-methods GET_DYNAMIC_JOIN_CLAUSE
    importing
      !IT_ENTITY_ATTR type GTT_ENTITY_ATTR
    returning
      value(RT_JOIN_CLAUSE) type STRING .
  class-methods GET_DYNAMIC_SELECT_CLAUSE
    importing
      !IT_ENTITY_ATTR type GTT_ENTITY_ATTR
    returning
      value(RT_SELECT_CLAUSE) type STRING .
  class-methods GET_DYNAMIC_TABLE_REF
    importing
      !IS_TABLE_TYPE_DATA type DRF_S_TABLE_TYPE
    exporting
      !EV_ERROR type ABAP_BOOL
      !ER_TABLE type ref to DATA .
  class-methods GET_DYNAMIC_TABLE_STR
    importing
      !IT_ENTITY_ATTR type GTT_ENTITY_ATTR
    exporting
      !EO_DATAREF type ref to DATA .
  class-methods GET_DYNAMIC_TABLE_TYPE
    importing
      !IV_TABLE_TYPE_NAME type DRF_REL_OBJECT_TYPE
    exporting
      !EV_ERROR type ABAP_BOOL
      !ER_TABLE_TYPE type DRF_S_TABLE_TYPE
      !ET_KEYONLY_LINE_DESCR type ABAP_COMPONENT_TAB .
  class-methods GET_DYNAMIC_WHERE_CLAUSE
    importing
      !IT_ENTITY_ATTR type GTT_ENTITY_ATTR
    returning
      value(RT_WHERE_CLAUSE) type STRING .
  class-methods GET_JOB_FOR_USER
    importing
      !IV_USER type SYUNAME
    returning
      value(RT_DATA) type P1001TAB .
  class-methods GET_KEYS_OF_ENTITY
    importing
      !IV_ENTITY type USMD_ENTITY
    returning
      value(RT_ENTITY_KEYS) type USMD_T_ENTITY .
  class-methods GET_KEY_VALUE
    importing
      !IV_CREQUEST type USMD_CREQUEST optional
      !IV_ENTITY type USMD_ENTITY
      !IS_SELECTED_RECORDS type ANY
      !IV_KEY_STRING type BOOLEAN optional
      !IV_ENTITY_KEY_STRING type BOOLEAN optional
    exporting
      !ET_ENTITY_KEY type GTT_ENTITY_KEY_DATA
    returning
      value(RV_VALUE) type STRING .
  class-methods GET_KEY_VALUE_TABLE
    importing
      !IV_ENTITY type USMD_ENTITY
      !IS_RECORD type ANY
    returning
      value(RT_KEY_VALUE) type GTY_T_KEY_VALUE .
  class-methods GET_MAIL_TEXT
    importing
      !IV_SUBJECT type TDOBNAME
      !IV_BODY type TDOBNAME
      !IV_TDID type TDID default 'ST'
      !IV_TDOBJECT type TDOBJECT default 'TEXT'
      !IV_NAME1 type ANY optional
      !IV_VALUE1 type ANY optional
      !IV_NAME2 type ANY optional
      !IV_VALUE2 type ANY optional
      !IV_NAME3 type ANY optional
      !IV_VALUE3 type ANY optional
      !IV_NAME4 type ANY optional
      !IV_VALUE4 type ANY optional
      !IV_NAME5 type ANY optional
      !IV_VALUE5 type ANY optional
      !IV_SUB_NAME1 type ANY optional
      !IV_SUB_VALUE1 type ANY optional
      !IV_SUB_NAME2 type ANY optional
      !IV_SUB_VALUE2 type ANY optional
      !V_LANGUAGE type SPRAS optional
      !IV_SUB_HAS_IDENTIFIER type XFELD default ABAP_TRUE
      !IV_BODY_HAS_IDENTIFIER type XFELD default ABAP_TRUE
      !IV_SUB_NAME3 type ANY optional
      !IV_SUB_VALUE3 type ANY optional
    exporting
      !ET_SUBJECT type TLINE_TTYP
      !ET_BODY type TLINE_TTYP .
  class-methods GET_MESSAGE
    importing
      !IO_MODEL type ref to IF_USMD_MODEL_EXT optional
      !IS_DATA type ANY optional
      !IV_ENTITY type USMD_ENTITY optional
      !IV_FIELDNAME type USMD_FIELDNAME optional
      !IV_MSGTY type SYMSGTY
      !IV_MSGNO type SYMSGNO
      !IV_MSGV1 type ANY optional
      !IV_MSGV2 type ANY optional
      !IV_MSGV3 type ANY optional
      !IV_MSGV4 type ANY optional
      !IV_SYMSGID type SYMSGID
    exporting
      !ES_MESSAGE type USMD_S_MESSAGE .
  class-methods GET_MODEL_BY_CR
    importing
      value(IV_CREQUEST) type USMD_CREQUEST
    returning
      value(RV_USMD_MODEL) type USMD_MODEL .
  class-methods GET_NAVIGATION_DATA
    returning
      value(RT_NAVI_DATA) type USMD_T_VALUE .
  class-methods GET_NOTIF_CONFIG .
  class-methods GET_OTC_FROM_URL
    returning
      value(RV_OTC) type MDC_SOURCE_OTC .
  class-methods GET_PERNR_FROM_USERID
    importing
      !IV_USERID type XUBNAME
    returning
      value(RV_PERNR) type P_PERNR .
  class-methods GET_POSITION_FOR_USER
    importing
      !IV_USER type SYUNAME
    returning
      value(RT_DATA) type P1001TAB .
  class-methods GET_PP_ACCESS
    importing
      !IO_MODEL type ref to IF_USMD_MODEL
      !I_ENTITY type USMD_ENTITY
    returning
      value(EO_PP_ACCESS_ADAPTER) type ref to CL_USMD_PP_ACCESS_ADAPTER .
  class-methods GET_RANGE_TABLE_FOR_ANY_TYPE
    importing
      !IV_ANY type ANY
      !IV_PARAM_VALUE type ANY
      !IV_OPTION type BRR_OPERATOR
    exporting
      !ER_DATA type ref to DATA .
  methods GET_REFERENCE_DECISION_TAB
    importing
      !IV_CRTYPE type STRING .
  class-methods GET_ROLES_FOR_USER
    importing
      !IV_USER type SYUNAME
    returning
      value(RT_DATA) type TT_ROLES .
  class-methods GET_WF_WORKITEM_CONTEXT
    returning
      value(RO_WORKITEM_CONTEXT) type ref to IF_WAPI_WORKITEM_CONTEXT .
  class-methods GET_WF_WORKITEM_CONTAINER
    returning
      value(RE_CONTAINER) type ref to IF_SWF_IFS_PARAMETER_CONTAINER .
  class-methods GET_WF_ELEMENT_VALUE
    importing
      !NAME type SWFDNAME default 'CHANGE_REQUEST'
    exporting
      !VALUE type ANY
    returning
      value(RETURNCODE) type SYSUBRC .
  class-methods GET_SOM_GOV_API
    returning
      value(RO_MDG_API) type ref to IF_USMD_CONV_SOM_GOV_API .
  class-methods GET_STAGING_TABLE
    importing
      !IV_MODEL type USMD_MODEL
    returning
      value(RT_STAGING_TABLE) type IF_USMD_MODEL_GEN_ADAPTER=>T_LOG_PHYS_NAME .
  class-methods GET_TEXTS
    importing
      !IO_MODEL type ref to IF_USMD_MODEL_EXT
      !IV_ENTITY type USMD_ENTITY optional
      !IV_ATTRIBUTE type USMD_ATTRIBUTE optional
    exporting
      !EV_TXT_L type SCRTEXT_L
      !EV_TXT_M type SCRTEXT_M .
  class-methods GET_UMB_SERVICE_OWNER_NAME
    importing
      !IV_USER type USR03-BNAME
    returning
      value(RV_NAME) type USR03-NAME1 .
  class-methods GET_USER_ADDR_DETAIL
    importing
      !IV_USER type SYUNAME
    returning
      value(ES_ADDR_USR) type V_ADDR_USR .
  class-methods GET_YYORGUNIT
    importing
      !IV_CREQUEST type USMD_CREQUEST optional
      !IV_ENTITY type USMD_ENTITY optional
      !IV_READMODE type USMD_READMODE_EXT default YZ_INTF_MDG_UTILITY_CONST~GC_READMODE_ACT_INACT
      !IT_KEY_VALUE type YZTABL_T_KEY_VALUE optional
    exporting
      !ER_DATA type ref to DATA
      !ET_DATA type ANY TABLE .
  class-methods GET_YYUSAGE
    importing
      !IV_CREQUEST type USMD_CREQUEST optional
      !IV_ENTITY type USMD_ENTITY optional
      !IV_READMODE type USMD_READMODE_EXT default YZ_INTF_MDG_UTILITY_CONST~GC_READMODE_ACT_INACT
      !IT_KEY_VALUE type YZTABL_T_KEY_VALUE optional
    exporting
      !ER_DATA type ref to DATA
      !ET_DATA type ANY TABLE .
  class-methods IS_MY_OBJ_REGISTERED
    returning
      value(RV_RETURN) type XFELD .
  class-methods IS_USER_BELONG_TO_DEPARTMENT
    importing
      !IT_DEPARTMENT type TT_DEPARTMENT
    returning
      value(RV_RETURN) type BOOLE_D .
  class-methods IS_USER_BELONG_TO_FUNCTION
    importing
      !IT_FUNCTION type TT_FUNCTION
    returning
      value(RV_RETURN) type BOOLE_D .
  class-methods IS_USER_BELONG_TO_JOB_S
    importing
      !IT_JOBID type PIQ_HROBJID_T
    returning
      value(RV_RETURN) type BOOLE_D .
  class-methods IS_USER_BELONG_TO_ORG
    importing
      !IT_ORGID type PIQ_HROBJID_T
    returning
      value(RV_RESULT) type BOOLE_D .
  class-methods IS_USER_BELONG_TO_PERSON
    importing
      !IT_PERNR type HRPP_T_PERNR
    returning
      value(RV_RETURN) type BOOLE_D .
  class-methods IS_USER_BELONG_TO_POSITION
    importing
      !IT_POSITION_ID type PIQ_HROBJID_T
    exporting
      !ET_AGENT_FROM_POSITION type TT_USER_LIST_FROM_POSITION
    returning
      value(RV_RESULT) type BOOLE_D .
  class-methods IS_USER_BELONG_TO_ROLE
    importing
      !IT_ROLE type TT_AGR_NAME
    returning
      value(RV_RESULT) type BOOLE_D .
  class-methods IS_USMD_CR_BLOCK
    importing
      !IV_USMD_CREQUEST type USMD_CREQUEST optional
    returning
      value(RV_STATUS) type BOOLEAN .
  class-methods IS_WORKFLOW_USER_ID_LOCKED
    importing
      !IV_WFUSER type XUBNAME default 'SAP_WFRT'
    returning
      value(RV_STATUS) type BOOLEAN .
  class-methods MAIL_JOBS_ARE_RUNNING
    returning
      value(RV_STATUS) type BOOLEAN .
  class-methods MESSAGE_HYPERLINK
    importing
      !IS_ENTITY_DATA type DATA
      !IV_ENTITY type USMD_ENTITY
      !IV_ATTRIBUTE type USMD_FLD_SOURCE
    exporting
      !EV_ROW type MDG_MESSAGE_ROW .
  class-methods MODIFY_IDOC_SEGMENT_FIELD
    importing
      !I_SEGNAM type EDILSEGTYP
      !I_SEGFLD type CHAR30
      !I_FLDVAL type CHAR30 default '/'
      !I_FROMIDX type SYST_INDEX default 0
    changing
      !CT_IDOC_DATA type EDIDD_TT .
  class-methods READ_CREQUEST
    importing
      !IV_CREQUEST type USMD_CREQUEST
    returning
      value(RS_CREQUEST) type USMD_S_CREQUEST .
  class-methods READ_CR_DATA
    importing
      !IV_CR_NUMBER type USMD_CREQUEST .
  class-methods READ_CR_DETAILS
    returning
      value(RT_CRDETAILS) type USMD_TS_CREQUEST .
  class-methods READ_ENTITY
    importing
      !IV_CREQUEST type USMD_CREQUEST
      !IV_ENTITY type USMD_ENTITY
      !IV_READMODE type USMD_READMODE_EXT optional
    exporting
      !EO_DATA_TAB type ref to DATA .
  class-methods READ_ENTITY_DATA
    importing
      !IV_CR_NUMBER type USMD_CREQUEST
      !IV_READMODE type USMD_READMODE_EXT optional
      !IV_ENTITY_TYPE type FIELDNAME optional
    exporting
      !ET_MESSAGE type USMD_T_MESSAGE
      !ES_CREQUEST type USMD_S_CREQUEST
      !EO_DATA type ref to DATA .
  class-methods READ_GLOBAL_MESSAGE
    returning
      value(RT_MESSAGE) type CRMT_GENIL_MESSAGE_TAB .
  class-methods READ_INTO
    importing
      !COMPONENT_NAME type CHAR100
      !STRUCTURE type ANY
    exporting
      !VALUE type ANY
    returning
      value(VALUE_CHAR) type STRING .
  class-methods RESTART_WRKITEM_WITH_SELECTION
    importing
      !IV_USMD_CREQUEST type USMD_CREQUEST optional
      !IV_DAYS type CHAR3 optional
    exporting
      !ET_MESSAGE type USMD_T_MESSAGE .
  class-methods SELECTION_TABLE_AS_CONDITIONS
    importing
      !IT_SELECTION_TABLE type USMD_TS_SEL
    returning
      value(RT_CONDITIONS) type BST_WHERE_CLAUSE .
  class-methods SEND_MAIL_MDG
    importing
      !IV_CREQUEST type USMD_CREQUEST
      !IV_CREQUEST_STATUS type USMD_CREQUEST_STATUS optional
      !IV_CREQUEST_STEP type USMD_SSW_CREQUEST_STEP optional
      !IT_RCPT_SAPID type USMD_T_USER_AGENT optional .
  methods SET_BRF_INSTANCE .
  class-methods SET_MESSAGE_HYPERLINK
    importing
      !IV_MODEL type USMD_MODEL
      !IV_ENTITY type USMD_ENTITY
      !IS_ENTITY_DATA type DATA
      !IV_ATTRIBUTE type USMD_FLD_SOURCE optional
    returning
      value(EV_ROW) type MDG_MESSAGE_ROW .
  class-methods SET_YYORGUNIT
    importing
      !IT_DATA type ANY TABLE .
  class-methods SET_YYUSAGE
    importing
      !IT_DATA type ANY TABLE .
  class-methods UPDATE_CR_DESCRIPTION
    importing
      !IV_CREQUEST type USMD_CREQUEST .
  class-methods UPDATE_SNAPSHOT
    importing
      !IV_CREQUEST type USMD_CREQUEST
    exporting
      !ET_MESSAGE type USMD_T_MESSAGE .
  class-methods USMD_CREQUEST_SNAPSHOT_REFRESH
    importing
      !IV_CREQUEST type USMD_CREQUEST optional
    returning
      value(RT_MESSAGE) type USMD_T_MESSAGE .
  class-methods WITHDRAW_CR_WITH_SELECTION
    importing
      !IV_USMD_CREQUEST type USMD_CREQUEST optional
      !IV_DAYS type CHAR3 optional
    exporting
      !ET_MESSAGE type USMD_T_MESSAGE .
  class-methods WORKFLOW_JOBS_ARE_RUNNING
    exporting
      value(EV_SWWCLEAR) type BOOLEAN
      value(EV_WWCOND) type BOOLEAN
      value(EV_SWWDHEX) type BOOLEAN
      value(EV_SWWERRE) type BOOLEAN .
  class-methods EXECUTE_SELECT_EXCEPT
    importing
      !IV_TAB type STRING
      !IV_EXCEPT type STRING
    exporting
      !ET_DATA type ANY TABLE .
  class-methods VALIDATE_TABLE
    importing
      !IV_TAB_NAME type STRING
    returning
      value(RV_BOOLEAN) type BOOLEAN .
  class-methods COPY_ENTITY
    importing
      !IV_MODEL type USMD_MODEL
      !IV_ENTITY type USMD_ENTITY
    exporting
      !ET_DATA type ANY TABLE .
  class-methods COPY_RECORD
    importing
      !IV_MODEL type USMD_MODEL
      !IV_CREQUEST_TYPE type USMD_CREQUEST_TYPE .
  class-methods SET_PARAMETER_VALUE
    importing
      !IS_DATA type DATA optional
      !IT_DATA type DATA optional
      !IV_PARAM_NAME type MEMORYID
      !IV_COMPONENT type STRING
      !IV_LEAD_SELECTION type I optional
    exporting
      !ET_DATA type STANDARD TABLE
    returning
      value(RV_BOOLEAN) type BOOLEAN .
  class-methods CREATE_RANGE_TABLE
    importing
      !I_TYPENAME type STRING optional
      !I_LENGTH type I optional
      !I_DECIMALS type I optional
      !IV_DATA type ref to DATA optional
    returning
      value(RT_RANGE_TABLE) type ref to DATA .
  class-methods CREATE_ATTRIBUTE_RANGE_TABLE
    importing
      !IV_ATTRIBUTE type STRING
      !IT_DATA type ANY TABLE optional
      !IR_TABLE_FIELD type ref to DATA optional
    exporting
      !ER_DATA type ref to DATA .
  class-methods SEND_TEAMS_NOTIFICATION
    importing
      !IV_CREQUEST type USMD_CREQUEST optional
      !IV_CR_TYPE type USMD_CREQUEST_TYPE optional
      !IV_ROLE_DESC type CHAR255 optional
      !IV_CR_STATUS type USMD_CREQUEST_STATUS optional
      !IV_URL type STRING optional
    exporting
      !RV_BOOLEAN type BOOLE_D .
protected section.

  data MO_BRF_QUERY type ref to IF_FDT_QUERY .
  data MO_BRF_FACTORY type ref to IF_FDT_FACTORY .
  data MT_USER_AGENT type IF_FDT_DECISION_TABLE=>TS_TABLE_DATA .
  data MT_NON_USER_AGENT type IF_FDT_DECISION_TABLE=>TS_TABLE_DATA .
  data MT_SINGLE_VALUE type IF_FDT_DECISION_TABLE=>TS_TABLE_DATA .
  class-data GO_MAT_BO type ref to CL_MDG_BS_MAT_BO .
  class-data GO_MODEL_EXT type ref to IF_USMD_MODEL_EXT .
  class-data GV_CREQUEST_TYPE type USMD_CREQUEST_TYPE .
  class-data GT_REUSE_FMAP type MDG_HDB_TT_PP_FMAP .

  class-methods GET_JOIN_CONDITIONS
    importing
      !IT_REUSE_TABLE type TTY_REUSE_TABLE
    returning
      value(RT_JOIN_CONDITIONS) type MDG_HDB_TT_XML_JOIN_TABLE .
  class-methods SET_REUSE_MAPPING
    importing
      !IV_MODEL type USMD_MODEL
      !IV_OTC type USMD_OTC .
  class-methods GET_LONGTEXT_JOINS
    importing
      !IT_ENTITIES type USMD_T_ENTITY
    changing
      !CT_JOIN_CONDITIONS type MDG_HDB_TT_XML_JOIN_TABLE .
  class-methods GET_LONGTEXT_ATTR_MAPPING
    importing
      !IT_MODEL_ATTRIBUTES type USMD_TS_ENTITY_FIELDNAME
    changing
      !CT_REUSE_ATTRIBUTES type MDG_HDB_TT_REUSE_ATTRIBUTES .
  class-methods ADAPT_JOIN_CONDITION
    changing
      !CT_JOIN_CONDITIONS type MDG_HDB_TT_XML_JOIN_TABLE .
  class-methods FILTER_CURRENT_CONTEXT
    importing
      !IV_ENTITY type USMD_ENTITY
      !IT_KEY_VALUE type GTY_T_KEY_VALUE
    returning
      value(RT_KEY_VALUE) type GTY_T_KEY_VALUE .
  methods GET_ALL_ENTITIES
    returning
      value(RT_ALL_ENTITIES) type USMD_T_ENTITY .
  class-methods GET_ENTITY_REFERENCE
    importing
      !IV_ENTITY type USMD_ENTITY
    exporting
      !ER_ENTITY type ref to DATA .
  class-methods GET_WHERE_CONDITION
    importing
      !IT_KEY_VALUE type GTY_T_KEY_VALUE
    returning
      value(RV_WHERE) type STRING .
  methods INIT_DEPENDENT_ENTITIES .
  methods INIT_ENTITY_ATTRIBUTE_REL .
  methods INIT_ENTITY_KEYS
    importing
      !IV_MODEL type USMD_MODEL .
  methods INIT_MODEL
    importing
      !IV_MODEL type USMD_MODEL .
private section.

  class-data MT_AUTH_OBJECT type TY_T_AUTH_OBJECT .
  class-data MT_REUSE_ATTRIBUTES type GTY_T_REUSE_ATTR_MAP .
  class-data MT_MODEL_DATA type MDG_HDB_TT_MODEL_ENTITY_DATA .
  class-data MT_MODEL_ATTRIBUTES type USMD_TS_ENTITY_FIELDNAME .
  class-data MT_FLEX_TABLES type TTY_REUSE_TABLE .
  class-data MT_FLEX_JOIN_CONDITIONS type MDG_HDB_TT_XML_JOIN_TABLE .
  class-data MT_FLEX_ATTRIBUTES type GTY_T_REUSE_ATTR_MAP .
  class-data MT_ENTITIES type USMD_T_ENTITY .
  class-data GT_JOIN_CONDITIONS type MDG_HDB_TT_XML_JOIN_TABLE .
  class-data:
    gt_mapping TYPE STANDARD TABLE OF tys_data_2pp .
  class-data:
    gt_message TYPE          TABLE OF tys_message .
  class-data MT_FMAP type MDG_HDB_TT_PP_FMAP .
  class-data MO_MODEL_EXT type ref to IF_USMD_MODEL_EXT .
  class-data GT_REUSE_ATTR type GTY_T_REUSE_ATTR_MAP .

  class-methods GET_JOIN_CONDITION
    importing
      !IT_REUSE_TABLE type TTY_REUSE_TABLE
    returning
      value(RT_JOIN_CONDITIONS) type ref to MDG_HDB_TT_XML_JOIN_TABLE .
  class-methods GET_JOIN_COND_FOR_FLEX
    changing
      !CT_JOIN_CONDITIONS type MDG_HDB_TT_XML_JOIN_TABLE .
  class-methods GET_USER_MASTER_RECORDS
    importing
      !IV_NEW_BUFFERING type XUFLAG optional
      !IV_MANDANT type SY-MANDT optional
      !IV_USER_NAME type XUBNAME optional
      !IV_SEL_OBJECT type XUOBJECT
    exporting
      !ET_VALUES type TY_T_USVALUES
      !EV_EXCEPTION like SY-SUBRC .
  class-methods GET_AUTH_SEL_ATTRIBUTES
    importing
      !IT_VALUES type TY_T_USVALUES
      !IS_AUTH_DATA type TY_S_AUTH_OBJECT
    exporting
      !EV_NO_AUTHORIZATION type BOOLEAN
    changing
      !CT_AUTH_ATTRIBUTES type USMD_TS_SEL .
  class-methods ADD_AUTH_OBJECTS .
ENDCLASS.



CLASS YZ_CLAS_MDG_UTILITY IMPLEMENTATION.


  METHOD are_you_auth_for_cr_type.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
**************************************************************************************

    cl_checkbook_authority_check=>get_instance( )->authority_check(
      EXPORTING
        iv_auth_object      = 'USMD_CREQ'
        iv_auth_field       = 'CREQ_TYPE'
        iv_auth_actvt       = '01'
        iv_auth_field_value = CONV #(  iv_crequest_type )
      RECEIVING
        rv_status           = rv_bool
    ).
  ENDMETHOD.


  METHOD assign_to.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :

**************************************************************************************

    ASSIGN COMPONENT component_name OF STRUCTURE structure TO FIELD-SYMBOL(<fs_val>).
    rv_subrc = sy-subrc.
    IF <fs_val> IS ASSIGNED.
      <fs_val> = condense( value ).
    ENDIF.

  ENDMETHOD.


  METHOD assign_user_to_crequest.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    CLEAR et_message.

    DATA lt_agent       TYPE STANDARD TABLE OF  swhactor.
    DATA ls_agent       TYPE                    swhactor.
    DATA ls_workitem    TYPE                    swr_wihdr.
    DATA lv_new_status  TYPE                    sww_wistat.

    ls_agent-otype = 'US'.
    ls_agent-objid = iv_username.
    APPEND ls_agent TO lt_agent.

    cl_usmd_wf_service=>get_cr_wis( EXPORTING id_crequest = iv_crequest
                                    IMPORTING et_workitem = DATA(lt_workitem) ).

    LOOP AT lt_workitem INTO ls_workitem.

      CALL FUNCTION 'SWW_WI_FORWARD'
        EXPORTING
          wi_id                 = ls_workitem-wi_id
          do_commit             = abap_true
          preconditions_checked = abap_true
          admin_mode_no_x_check = abap_true
        IMPORTING
          new_status            = lv_new_status
        TABLES
          new_agents            = lt_agent
        EXCEPTIONS
          invalid_status        = 1
          update_failed         = 2
          invalid_type          = 3
          OTHERS                = 4.

      IF sy-subrc <> 0.
        "Collect Error and Pass it to ET Message
        RETURN.
      ENDIF.

    ENDLOOP.
  ENDMETHOD.


  METHOD check_cr_existance.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    SELECT SINGLE usmd_crequest FROM usmd120c INTO @DATA(lv_crequest) WHERE usmd_crequest EQ @iv_crequest.
    IF sy-subrc = 0.
      rv_exist = abap_true.
    ENDIF.
  ENDMETHOD.


  METHOD check_entity_lock_status.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    DATA lr_ent_key_struct TYPE REF TO data.

    DATA(lo_key_conv) = cl_usmd_key_conversion=>get_instance( ).

    CHECK lo_key_conv IS BOUND.

    DATA(lo_ext) = get_cr_usmd_model_ext_api( ).
    IF lo_ext IS BOUND.
      lo_ext->create_data_reference(
        EXPORTING
          i_fieldname      = CONV #( iv_entity_type )                 " Field Name
          i_struct         = if_usmd_model=>gc_struct_key
          if_table         = abap_false
        IMPORTING
          er_data          = lr_ent_key_struct
          et_message       = DATA(lt_message)                 " Messages
      ).

      ASSIGN lr_ent_key_struct->* TO FIELD-SYMBOL(<fs_entity_key>).
    ENDIF.

    CHECK <fs_entity_key> IS ASSIGNED.

    LOOP AT lo_ext->dt_fdep ASSIGNING FIELD-SYMBOL(<ls_fdep>) WHERE fieldname = iv_entity_type.
      ASSIGN COMPONENT <ls_fdep>-masterfield OF STRUCTURE <fs_entity_key> TO FIELD-SYMBOL(<lv_destination>).
      ASSIGN COMPONENT <ls_fdep>-masterfield OF STRUCTURE is_entity_row   TO FIELD-SYMBOL(<lv_source>).
      CHECK <lv_source> IS ASSIGNED AND <lv_destination> IS ASSIGNED.
      <lv_destination> = <lv_source>.
    ENDLOOP.

    CHECK <fs_entity_key> IS NOT INITIAL.

    CALL METHOD lo_key_conv->entity_key_2_string_tech
      EXPORTING
        iv_model       = gc_model
        iv_entity_type = iv_entity_type
        is_entity_key  = <fs_entity_key>
      IMPORTING
        ev_key_hash    = DATA(lv_hash).

    IF lv_hash IS NOT INITIAL.

      SELECT crequest_id , entity_type , entity_key
        FROM usmd1222
       WHERE entity_type = @iv_entity_type
         AND entity_key  = @lv_hash
    ORDER BY PRIMARY KEY
        INTO @DATA(ls_usmd1222)
UP TO 1 ROWS. ENDSELECT.

      IF sy-subrc = 0.
        rv_crequest = ls_usmd1222-crequest_id.
      ENDIF.
    ENDIF.

  ENDMETHOD.


  METHOD construct_url.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    CONSTANTS :
      lc_client   TYPE string VALUE 'SAP-CLIENT'.


    CLEAR ev_url.

    IF iv_wf_id IS NOT INITIAL OR im_cr IS NOT INITIAL.
      DATA(lo_navigation_handler) = cl_usmd_wf_navigation_handler=>get_instance( iv_workitem_id = iv_wf_id iv_crequest_id = im_cr ).

      DATA(ls_navigation_parameters) = lo_navigation_handler->get_navigation_parameters( ).

      READ TABLE ls_navigation_parameters-parameters INTO DATA(ls_navigation_parameter)
        WITH KEY key = cl_usmd_wf_navigation_handler=>gc_par_logical_action.

      IF sy-subrc = 0.
        DATA(lv_action) = ls_navigation_parameter-value.
      ELSE.
        lv_action = iv_action.
      ENDIF.
      DATA(key_value_pairs_for_mapping) = ls_navigation_parameters-parameters.
    ENDIF.

    DATA(lt_para) = VALUE tihttpnvp( FOR ls_param IN VALUE usmd_t_value( FOR ls_nav_param IN ls_navigation_parameters-parameters
                                                                        ( fieldname = ls_nav_param-key  value = ls_nav_param-value ) )
                                                  WHERE ( fieldname NE 'WDAPPLICATIONID' )
                                   ( name = ls_param-fieldname value = ls_param-value )
                                     ).
    lt_para = VALUE #( BASE lt_para (  name = lc_client value = sy-mandt   ) ).

    IF in_parameters IS SUPPLIED.
      APPEND LINES OF in_parameters TO lt_para.
    ENDIF.

    cl_wd_utilities=>construct_wd_url(
    EXPORTING
      application_name = CONV #( COND #( WHEN iv_application_name IS SUPPLIED THEN iv_application_name ELSE ls_navigation_parameters-ui_appl ) )
      in_parameters    = lt_para
    IMPORTING
      out_absolute_url = DATA(lv_url) ).

    CONCATENATE lv_url '&SAP-THEME=SAP_BELIZE' INTO lv_url.

    IF lv_url IS NOT INITIAL.
      MOVE lv_url TO ev_url.
      rv_url      = lv_url.
    ELSE.

*     RAISE URL_NOT_FOUND.
    ENDIF.
  ENDMETHOD.


  METHOD convert_message_usmd_to_fpm.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************

    rt_fpm_message = CORRESPONDING #( it_usmd_message MAPPING msgid       = msgid
                                                              msgno       = msgno
                                                              severity    = msgty
                                                              parameter_1 = msgv1
                                                              parameter_2 = msgv2
                                                              parameter_3 = msgv3
                                                              parameter_4 = msgv4
                                     ).
  ENDMETHOD.


  METHOD convert_note_string.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    : 01
*
**************************************************************************************
    DATA:
      ld_note           TYPE string,
      ld_note_body      TYPE string,
      ld_header         TYPE string,
      lo_br             TYPE REF TO cl_wd_formatted_text,
      lo_header_txt     TYPE REF TO cl_wd_formatted_text,
      ld_string         TYPE string,
      ld_created_by     TYPE string,
      ld_date           TYPE d,
      ld_time           TYPE t,
      ld_ts             TYPE usmd_created_at,
      ld_char_stamp(20).

    CONVERT TIME STAMP is_note-usmd_ncreated_at TIME ZONE sy-zonlo INTO DATE ld_date TIME ld_time.
    CONCATENATE ld_date ld_time INTO ld_string.

    ld_ts = ld_string.
    WRITE ld_ts TO ld_char_stamp.

    ld_created_by = cl_usmd_user_services=>get_user_name( is_note-usmd_ncreated_by ).
    IF ld_created_by IS INITIAL.
      ld_created_by = is_note-usmd_ncreated_by.
    ENDIF.

    CONCATENATE ld_char_stamp ld_created_by
      INTO ld_header SEPARATED BY space.

    lo_header_txt = cl_wd_formatted_text=>make_text( inner_text = ld_header tag = cl_wd_formatted_text=>e_tag-h3 ). "#EC NOTEXT
    lo_br = cl_wd_formatted_text=>make_text( tag = cl_wd_formatted_text=>e_tag-br ).

    ld_note_body = is_note-usmd_note.
    REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=>newline IN ld_note_body WITH ' &BR& '.
    CONCATENATE '&HEAD&' ld_note_body '&BR&' INTO ld_note SEPARATED BY space.
    ro_note_txt = cl_wd_formatted_text=>make_text( inner_text = ld_note ). "#EC NOTEXT
    ro_note_txt->replace_placeholder( name = 'HEAD'  formatted_text = lo_header_txt ).
    ro_note_txt->replace_placeholder( name = 'BR'  formatted_text = lo_br ).
  ENDMETHOD.


  METHOD delete_from_global_message.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
**************************************************************************************
    DATA(lo_bol_core) = cl_crm_bol_core=>get_instance( ).
    CHECK lo_bol_core IS BOUND.

    lo_bol_core->get_global_message_cont( ).
    DATA(lo_message_container) =  cl_crm_bol_core=>get_instance( )->get_global_message_cont( ).
    CHECK lo_message_container IS BOUND.

    LOOP AT it_message INTO DATA(ls_mesg).
      lo_message_container->if_genil_message_container~delete_messages(
      EXPORTING
        iv_msg_id      =  ls_mesg-msgid   " Message Class
        iv_msg_number  =  ls_mesg-msgno   " Message Number
          ).
    ENDLOOP.

    IF it_messages IS NOT INITIAL.
      lo_message_container->if_genil_message_container~delete_messages(
         EXPORTING
           it_messages    =  it_messages      " Message Table
             ).
    ENDIF.

  ENDMETHOD.


  METHOD execute_and_condition.
    rv_result = COND boole_d( WHEN iv_operand1 IS NOT INITIAL AND iv_operand2 IS NOT INITIAL THEN abap_true
                                                                                             ELSE abap_false ).
  ENDMETHOD.


  METHOD execute_or_condition.

    rv_result = COND boole_d( WHEN iv_operand1 IS NOT INITIAL OR iv_operand2 IS NOT INITIAL THEN abap_true
                                                                                            ELSE abap_false ).
  ENDMETHOD.


  METHOD get_agents_from_org_mgmt.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    DATA:
      lt_agents     TYPE TABLE OF swhactor. "agent table

    IF iv_position IS SUPPLIED.
      DATA(lv_position) = iv_position.
*    ELSE.
*      SELECT SINGLE mc_short FROM @gt_wf_agents AS agents WHERE cr_type = @cr_type AND cr_step = @cr_step INTO @lv_position.
    ENDIF.

    CHECK lv_position IS NOT INITIAL.

* Read org management
    SELECT DISTINCT otype , objid FROM hrp1000
      INTO TABLE @DATA(lt_hrp1000)
      WHERE mc_short EQ @lv_position
        AND begda    LE @sy-datum
        AND endda    GE @sy-datum
        AND plvar    EQ '01'.

    LOOP AT lt_hrp1000 INTO DATA(ls_hrp1000).

* Read users of the specific node
      CALL FUNCTION 'RH_STRUC_GET'
        EXPORTING
          act_otype       = ls_hrp1000-otype
          act_objid       = ls_hrp1000-objid
          act_wegid       = 'O-S-PEXT'
          authority_check = abap_false
        TABLES
          result_tab      = lt_agents
        EXCEPTIONS
          no_plvar_found  = 1
          no_entry_found  = 2
          OTHERS          = 3.

      IF sy-subrc <> 0.
        "Log Error
      ENDIF.

* Add assigned users to exporting table
      et_agents = VALUE #( BASE et_agents
                            FOR <fs_row> IN lt_agents WHERE ( otype = 'US' )
                              ( user_type = <fs_row>-otype user_value = <fs_row>-objid  )  ).

    ENDLOOP.

    IF lines( lt_hrp1000 ) = 1.
      rv_s_id = lt_hrp1000[ 1 ]-objid.
    ENDIF.

*    DATA(lv_crequest) = COND #( WHEN iv_crequest IS INITIAL THEN get_cr_number( ) ELSE iv_crequest ).
*    IF lv_crequest IS NOT INITIAL.
*      update_parallel_cr_entity_keys(
*        EXPORTING
*          iv_crequest    =  lv_crequest                " Change Request
*      ).

*Update CR Description
*      update_cr_description( iv_crequest = lv_crequest ).
*    ENDIF.




  ENDMETHOD.


  METHOD get_business_object_type.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************

    rv_usmd_otc = COND #( WHEN cl_usmd_app_context=>get_context( ) IS BOUND THEN cl_usmd_app_context=>get_context( )->mv_otc ).
  ENDMETHOD.


  METHOD get_country_from_compcode.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* User ID       :
* Release ID    :
*
* Change Description:
* Get Country from Company Code
**************************************************************************************
    CLEAR rv_country.

    SELECT SINGLE land1
      INTO rv_country
      FROM t001
     WHERE bukrs = iv_compcode.

  ENDMETHOD.


  METHOD get_country_from_salesorg.
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* User ID       :
* Release ID    :
*
* Change Description:
* Get Country from Sales Org
**************************************************************************************

    SELECT SINGLE land1
      INTO rv_country
      FROM tvko       "Sales Org
      INNER JOIN t001 "Company Codes
         ON tvko~bukrs = t001~bukrs
      WHERE vkorg = iv_salesorg.                       "#EC CI_BUFFJOIN

  ENDMETHOD.


  METHOD get_cr_action.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************

    rv_usmd_action = cl_usmd2_cust_access_service=>get_activity_by_process( get_cr_business_activity( get_cr_type( iv_crequest ) ) )-usmd_action.

  ENDMETHOD.


  METHOD get_cr_activation_status.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************

    DATA lv_usmd_creques TYPE usmd_crequest.
    lv_usmd_creques = COND #( WHEN iv_usmd_crequest IS INITIAL THEN get_cr_number( ) ELSE iv_usmd_crequest ).
    SELECT SINGLE usmd_data_active FROM usmd120c WHERE usmd_crequest = @lv_usmd_creques INTO  @rv_usmd_data_activated.

  ENDMETHOD.


  METHOD get_cr_api.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    cl_usmd_crequest_api=>get_instance(
      EXPORTING
        iv_crequest          = get_cr_number( )
        iv_model_name        = get_data_model( )
      IMPORTING
        et_message           = et_message
        re_inst_crequest_api = ro_cr_api
    ).

  ENDMETHOD.


  METHOD get_cr_attributes.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    DATA: lo_model           TYPE REF TO if_usmd_model,
          lo_usmd_model_util TYPE REF TO cl_usmd_crequest_util.
    TRY.
        DATA(lo_gov_api) =  get_cr_gov_api( iv_crequest = iv_crequest ).
      CATCH cx_usmd_gov_api.
    ENDTRY.

    IF lo_gov_api IS BOUND.
      TRY.
          rs_crequest_attributes = lo_gov_api->get_crequest_attributes( iv_crequest_id = iv_crequest ).
        CATCH cx_usmd_gov_api_core_error.
        CATCH cx_usmd_gov_api.
      ENDTRY.
    ENDIF.
    IF rs_crequest_attributes IS NOT INITIAL.
      gs_crequest_attributes = rs_crequest_attributes.
    ENDIF.

    IF gs_crequest_attributes IS INITIAL.
      CREATE OBJECT lo_usmd_model_util.
      lo_usmd_model_util->get_data_model(
          EXPORTING id_crequest = iv_crequest
          IMPORTING eo_model    = lo_model ).

      lo_usmd_model_util->get_crequest(
        EXPORTING id_crequest     = iv_crequest
                  io_model        = lo_model
        IMPORTING es_crequest     = gs_crequest_attributes ).

    ENDIF.
  ENDMETHOD.


  METHOD get_cr_business_activity.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************

    rv_process = COND #( WHEN cl_usmd_app_context=>get_context( ) IS BOUND THEN cl_usmd_app_context=>get_context( )->mv_process  ).

    IF rv_process IS INITIAL AND iv_crequest_type IS NOT INITIAL.
      rv_process = cl_usmd2_cust_access_service=>get_process_by_crequest_type( iv_crequest_type = iv_crequest_type )-usmd_process.
    ENDIF.

  ENDMETHOD.


  METHOD get_cr_change_document.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    DATA(lo_cd_doc) = cl_usmd_mdf_change_document=>get_instance( ).
    CHECK lo_cd_doc IS BOUND.

    lo_cd_doc->read_document_header(
      EXPORTING
        it_crequest               = VALUE #(  ( COND #(  WHEN iv_crequest IS INITIAL THEN get_cr_number( ) ELSE iv_crequest ) ) )
*       i_entity                  =
*       it_entity_value           =
        io_model                  =  COND #(  WHEN io_model IS BOUND THEN io_model ELSE get_cr_usmd_model_api( ) )
*       it_uname                  =
*       i_date_from               =
*       i_date_to                 =
*       i_time_from               =
*       i_time_to                 =
*       i_attribute               =
*       it_value_old              =
*       it_value_new              =
*       i_edition_reference       =
*       if_from_activation        = space
*       i_rec_num                 =
*       if_mark_rollback_entities = space
      IMPORTING
        et_document_header        = et_document_header
    ).

    CHECK et_document_header IS NOT INITIAL.

    LOOP AT et_document_header INTO DATA(ls_header).

      lo_cd_doc->read_document_lines(
        EXPORTING
          is_document_header = ls_header
*         i_entity           =
*         it_entity_value    =
          io_model           = COND #(  WHEN io_model IS BOUND THEN io_model ELSE get_cr_usmd_model_api( ) )
      IMPORTING
*         et_changed_value   =
          et_changed_detail  = DATA(lt_changed_details)
*         et_compound_value  =
*         et_message         =
      ).

      APPEND LINES OF lt_changed_details TO rt_changed_doc.
    ENDLOOP.
  ENDMETHOD.


  METHOD get_cr_context_api.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    ro_cr_context_api = cl_usmd_app_context=>get_context( ).
  ENDMETHOD.


  METHOD get_cr_conv_api.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    TRY.
        ro_cr_conv_api = cl_usmd_conv_som_gov_api=>get_instance( iv_model_name = get_data_model( ) ).
      CATCH cx_usmd_conv_som_gov_api.
      CATCH cx_usmd_app_context_cons_error.
      CATCH cx_usmd_gov_api.
    ENDTRY.

  ENDMETHOD.


  METHOD get_cr_entities_by_model.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    CALL METHOD cl_usmd_access_dm_read=>select_range_0020
      EXPORTING
        iv_model   = COND #( WHEN iv_model IS INITIAL THEN get_data_model( ) ELSE iv_model )
        iv_objstat = 'A'
      IMPORTING
        et_0020    = DATA(lt_0020)
        ev_error   = DATA(lv_error).

    IF lv_error IS INITIAL.
      rt_entity = VALUE #( FOR <fs_row> IN lt_0020 WHERE ( pp_domain IS NOT INITIAL  ) (   <fs_row>-usmd_entity )  ).
    ELSE.
      "Collect Error and pass it to ET Return
    ENDIF.

  ENDMETHOD.


  METHOD get_cr_entity_data.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    DATA lt_objlist        TYPE        usmd_t_crequest_entity.
    DATA lr_data_tab       TYPE REF TO data.
    DATA it_sel            TYPE usmd_ts_sel.

    FIELD-SYMBOLS <lt_data> TYPE ANY TABLE.

    FIELD-SYMBOLS:
      <lt_tabl>         TYPE ANY TABLE,
      <ls_tabl>         TYPE any,
      <lt_locked_table> TYPE ANY TABLE,
      <lt_entity_key>   TYPE ANY TABLE,
      <ls_entity_key>   TYPE any.

    IF iv_usmd_crequest IS NOT INITIAL.

      TRY.
          cl_usmd_app_context=>init_context(
            EXPORTING
              iv_model                 = get_data_model( )  " Data Model
              iv_crequest_id           = iv_usmd_crequest  " Change Request
          ).

        CATCH cx_usmd_app_context_cons_error. " Exception: Consistency Error in Design of Appl. Context

      ENDTRY.
    ENDIF.

    IF iv_usmd_crequest IS INITIAL.

      CALL METHOD cl_usmd_app_context=>get_context
        RECEIVING
          eo_context = DATA(lo_app_context).

      IF lo_app_context IS BOUND.
*Get Model Instance and CR ID from the application context
        CALL METHOD lo_app_context->get_attributes
          IMPORTING
*           eo_model       =
            ev_crequest_id = DATA(lv_crequest)
            ev_process     = DATA(lv_process).

      ENDIF.
    ENDIF.

    IF lv_crequest IS INITIAL AND iv_usmd_crequest IS NOT INITIAL.
      lv_crequest = iv_usmd_crequest.
    ENDIF.

    IF iv_update_snapshot IS NOT INITIAL AND lv_crequest IS NOT INITIAL.

      IF ( get_cr_step( ) = '00' AND check_cr_existance( iv_crequest = lv_crequest )
                                 AND get_cr_status( lv_crequest ) <> usmd0_cs_crequest_status-business_approved ).
*                               or
*       get_cr_type( iv_crequest = lv_crequest ) cs gc_mass.

        DATA(lo_snp) = get_cr_snapshot_api( ).
        IF lo_snp IS BOUND.

          lo_snp->write_snapshot(
             EXPORTING
              i_fieldname    =  CONV #( get_cr_main_entity( ) )
              it_sel         =  it_sel
              i_allow_update =  'X'  " X = allow overwriting of existing snapshots
             IMPORTING
              et_message     = DATA(lt_message)                 " Messages
                                          ).

        ENDIF.
      ELSE.
        usmd_crequest_snapshot_refresh( lv_crequest ).
      ENDIF.

    ENDIF.

    CALL METHOD cl_usmd_model_ext=>get_instance
      EXPORTING
        i_usmd_model = get_data_model( )
      IMPORTING
        eo_instance  = DATA(lo_model)
        et_message   = lt_message.

    lv_crequest = COND #( WHEN lv_crequest IS INITIAL THEN iv_usmd_crequest ELSE lv_crequest ).

    IF lo_model IS BOUND AND lv_crequest IS NOT INITIAL.

      IF get_cr_activation_status( iv_usmd_crequest = lv_crequest ) = abap_false.

        CALL METHOD lo_model->read_entity_data_all
          EXPORTING
            i_fieldname    = get_cr_main_entity( )
            i_crequest     = lv_crequest
*           it_sel         = lt_sel
            if_active      = abap_false
          IMPORTING
            et_message     = lt_message
            et_data_entity = rt_usmd_ts_data_entity.

*      filter_parallel_cr_objects( EXPORTING iv_crequest = lv_crequest CHANGING ct_entity_data = rt_usmd_ts_data_entity  ).

      ELSE.

        lo_model->read_char_value(
                 EXPORTING i_fieldname       = usmd0_cs_fld-crequest
                           it_sel            = VALUE #( ( fieldname = usmd0_cs_fld-crequest sign = 'I' option  = 'EQ' low = lv_crequest ) )
                           if_use_edtn_slice = abap_false
                 IMPORTING et_data           = lt_objlist ).



*loop at all entities
        LOOP AT get_cr_entities_by_model( iv_model = gc_model ) INTO DATA(ls_entity).

          lo_model->create_data_reference(
                 EXPORTING i_fieldname = CONV #(  ls_entity )
                           i_struct    = if_usmd_model=>gc_struct_key_attr
                           i_tabtype   = if_usmd_model=>gc_tabtype_standard
                 IMPORTING er_data     = lr_data_tab ).

          ASSIGN lr_data_tab->* TO <lt_data>.
          IF <lt_data> IS  NOT ASSIGNED.
            RETURN.
          ENDIF.

          lo_model->read_char_value(
            EXPORTING
              i_fieldname       = CONV #( ls_entity ) "'PIMNODE1'                 " Entity Type, Storage and Use Type 1
              it_sel            = VALUE #( ( fieldname = CONV #(  get_cr_main_entity( ) )
                                              sign      = 'I'
                                              option    = 'EQ'
                                              low       = CONV #( lt_objlist[ usmd_entity = CONV #(  get_cr_main_entity( ) ) ]-usmd_value ) ) ) " Sorted Table: Selection Condition (Range per Field)
*              i_readmode       = gc_readmode_default
*              if_no_flush      = abap_false
            IMPORTING
              et_data           =  <lt_data>
              et_message        =  lt_message               " Messages
          ).                                            "#EC CI_SORTSEQ

          IF <lt_data> IS ASSIGNED.
            rt_usmd_ts_data_entity = VALUE #( BASE rt_usmd_ts_data_entity
                                    ( usmd_entity = get_cr_main_entity( )
                                 usmd_entity_cont = COND #(  WHEN ls_entity <> get_cr_main_entity( ) THEN ls_entity )
                                         r_t_data = lr_data_tab  ) ).
          ENDIF.

          CLEAR lr_data_tab.
          UNASSIGN <lt_data>.

        ENDLOOP.

        update_snapshot(
          EXPORTING
            iv_crequest = lv_crequest
          IMPORTING
            et_message  = lt_message
               ).

      ENDIF.

    ENDIF.

  ENDMETHOD.


  METHOD get_cr_entity_key_data.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
**************************************************************************************
    DATA g_s_entity TYPE REF TO data .
    DATA g_t_entity TYPE REF TO data .

    DATA(lo_conv_api) = get_cr_conv_api( iv_crequest = iv_crequest ).
    CHECK lo_conv_api IS BOUND.

    lo_conv_api->get_entity_structure(
      EXPORTING
        iv_entity_name = iv_entity
        iv_struct_type = lo_conv_api->gc_struct_key_attr
      IMPORTING
        er_structure   = g_s_entity
        er_table       = g_t_entity
      ).

    ASSIGN g_s_entity->* TO FIELD-SYMBOL(<fs_entity>).
    ASSIGN g_t_entity->* TO FIELD-SYMBOL(<ft_entity>).

    <ft_entity> = it_data.

*--------------------------------------------------------------------*
*Prepare Key & Data
*--------------------------------------------------------------------*
    rt_key  = VALUE usmd_gov_api_ts_ent_tabl( ( entity = iv_entity tabl        = g_t_entity ) ).



  ENDMETHOD.


  METHOD get_cr_main_entity.

    cl_usmd_crequest_util=>get_crtype_main_entity(
     EXPORTING
       id_crequest_type =  COND #( WHEN iv_usmd_crequest_type IS INITIAL THEN get_cr_type( iv_crequest ) ELSE iv_usmd_crequest_type )  " Type of Change Request
     RECEIVING
       rd_entity        = rv_entity  ).

    CHECK rv_entity IS INITIAL.

    cl_usmd2_cust_access_service=>get_crequest_type(
     EXPORTING
       iv_usmd_crequest_type = COND #( WHEN  iv_usmd_crequest_type IS INITIAL THEN get_cr_type( iv_crequest ) ELSE iv_usmd_crequest_type )
     IMPORTING
       es_usmd_crequest_type = DATA(ls_crequest_type) ).

    rv_entity = ls_crequest_type-usmd_entity_main.

    IF rv_entity IS INITIAL AND iv_model IS NOT INITIAL AND iv_otc IS NOT INITIAL.
      SELECT SINGLE usmd_entity FROM usmd0050
              WHERE usmd_model      = @iv_model
                AND usmd_objstat    = 'A'
                AND usmd_otc        = @iv_otc
                AND usmd_is_root_et = @abap_true
                INTO @rv_entity.
    ENDIF.


  ENDMETHOD.


  METHOD get_cr_mdg_cp_status.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    WITH
    +cp AS (
      SELECT changepointer_id FROM mdgd_cp WHERE object_key = @iv_usmd_crequest )
      SELECT COUNT(*) FROM mdgd_cp_rep_stat WHERE changepointer_id IN ( SELECT changepointer_id FROM +cp )
                                             AND status = 'CP' INTO @DATA(lv_count).
    IF lv_count > 0.
      rv_already_processed = abap_true.
    ENDIF.

  ENDMETHOD.


  METHOD get_cr_notes.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    DATA(lv_crequest) =   COND #( WHEN iv_crequest IS INITIAL THEN get_cr_number( ) ELSE iv_crequest ).

    DATA(lo_model) = get_cr_usmd_model_api(  ).

    IF lo_model IS BOUND.

      CALL METHOD lo_model->read_char_value
        EXPORTING
          i_fieldname = usmd0_cs_fld-crequest
          it_sel      = VALUE #( ( fieldname = usmd0_cs_fld-crequest sign = 'I' option = 'EQ' low = lv_crequest ) )
        IMPORTING
          et_data     = rt_note.

    ENDIF.

    IF rt_note IS INITIAL.

* #FallBack API Code
      DATA(lo_api) = get_cr_gov_api( iv_crequest = lv_crequest ).
      CHECK lo_api IS BOUND.
      TRY.
          CALL METHOD lo_api->get_notes
            EXPORTING
              iv_crequest_id   = iv_crequest     " Change Request
            RECEIVING
              rt_crequest_note = rt_note. " Change Request Notes
        CATCH cx_usmd_gov_api_core_error. " CX_USMD_CORE_DYNAMIC_CHECK
      ENDTRY.

    ENDIF.
  ENDMETHOD.


  METHOD get_cr_number.

    TYPES:
      BEGIN OF tys_objkey,
        crequest TYPE usmd_crequest,
        cr_index TYPE swc_index,
      END OF tys_objkey.

    DATA: ls_objkey TYPE tys_objkey,
          ls_object TYPE swotobjid.

    rv_usmd_crequest = COND #( WHEN cl_usmd_app_context=>get_context( ) IS BOUND THEN cl_usmd_app_context=>get_context( )->mv_crequest_id  ).

    IF rv_usmd_crequest IS INITIAL.
      rv_usmd_crequest = get_cr_number_from_url( ).
    ENDIF.

    IF rv_usmd_crequest IS INITIAL.

      get_wf_element_value(
        EXPORTING
          name       = 'CHANGE_REQUEST'
        IMPORTING
          value      = ls_object ).

      ls_objkey        = cond #( WHEN ls_object IS NOT INITIAL THEN ls_object-objkey ).
      rv_usmd_crequest = ls_objkey-crequest.
    ENDIF.

  ENDMETHOD.


  METHOD get_cr_snapshot_api.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    ro_snapshot =  cl_usmd_model_snapshot=>get_instance( io_model = get_cr_usmd_model_api( )  ).
  ENDMETHOD.


  METHOD get_cr_status.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    DATA lt_crequest  TYPE SORTED TABLE OF usmd_s_crequest
                      WITH UNIQUE KEY      usmd_crequest.

    DATA(lo_context) = cl_usmd_app_context=>get_context( ).
    IF lo_context IS BOUND.

      lo_context->mo_model->read_char_value(
        EXPORTING
            i_fieldname = usmd0_cs_fld-crequest
            it_sel      = VALUE #( (
                                   fieldname = usmd0_cs_fld-crequest
                                   sign = 'I' option = 'EQ'
                                   low  =  COND #( WHEN iv_usmd_crequest IS INITIAL
                                                   THEN get_cr_number( ) ELSE iv_usmd_crequest ) ) )
          IMPORTING
            et_data     = lt_crequest
            et_message  = et_message ).

      IF lt_crequest IS NOT INITIAL.
        rv_usmd_crequest_status = lt_crequest[ 1 ]-usmd_creq_status.
      ENDIF.
    ENDIF.

* #FallBack API Code
    IF rv_usmd_crequest_status IS INITIAL.
      DATA(lo_gov_api) = get_cr_gov_api( iv_crequest = iv_usmd_crequest ).

      IF lo_gov_api IS BOUND.
        "Get CR attributes
        DATA(ls_crequest_attributes) = lo_gov_api->get_crequest_attributes( iv_crequest_id = iv_usmd_crequest  ).
      ENDIF.

      IF ls_crequest_attributes-usmd_creq_status IS NOT INITIAL.
        rv_usmd_crequest_status = ls_crequest_attributes-usmd_creq_status.
      ENDIF.
    ENDIF.

    DATA(lv_cr_number) = COND #( WHEN iv_usmd_crequest IS INITIAL
                                                       THEN get_cr_number( ) ELSE iv_usmd_crequest ).

* #FallBack DB Code
    IF rv_usmd_crequest_status IS INITIAL AND lv_cr_number IS NOT INITIAL.
      SELECT SINGLE usmd_creq_status FROM usmd120c WHERE usmd_crequest = @lv_cr_number INTO @rv_usmd_crequest_status.
    ENDIF.

    IF rv_usmd_crequest_status IS NOT INITIAL.
      gv_crequest_status = rv_usmd_crequest_status.
    ENDIF.
  ENDMETHOD.


  METHOD get_cr_step.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    DATA: lt_simp_cont         TYPE usmd4_t_swr_cont.
    rv_usmd_crequest_appstep = COND #( WHEN cl_usmd_app_context=>get_context( ) IS BOUND THEN cl_usmd_app_context=>get_context( )->mv_crequest_step  ).

*#FallBack API
    IF rv_usmd_crequest_appstep IS INITIAL.
      DATA(lo_wf_service) = cl_usmd_wf_service=>get_instance( ).
      IF lo_wf_service IS BOUND.
        lo_wf_service->get_crequest_step( EXPORTING id_crequest = get_cr_number( ) IMPORTING ed_step = rv_usmd_crequest_appstep ).
      ENDIF.
    ENDIF.

*#FallBack API
    IF rv_usmd_crequest_appstep IS INITIAL AND iv_cr_id IS NOT INITIAL.
      IF lo_wf_service IS BOUND.
        lo_wf_service->get_crequest_step( EXPORTING id_crequest = iv_cr_id IMPORTING ed_step = rv_usmd_crequest_appstep ).
      ENDIF.

    ENDIF.

*"CREQUESt MAPPER API New Code
    IF rv_usmd_crequest_appstep IS INITIAL AND iv_cr_id IS NOT INITIAL.
      DATA(lv_wiid) = cl_usmd_wf_crequest_mapper=>get_top_wi_by_crequest_single( iv_crequest = iv_cr_id ).
      cl_usmd4_crequest_protocol=>read_container( EXPORTING i_workitem_id        = lv_wiid
                                                  CHANGING  t_simple_container   = lt_simp_cont ).

      DATA(lv_step_action) = VALUE #( lt_simp_cont[ element = 'STEP_ACTION' ]-value OPTIONAL ).
      IF lv_step_action IS NOT INITIAL.
        rv_usmd_crequest_appstep = lv_step_action+0(2).
      ENDIF.
    ENDIF.
  ENDMETHOD.


  METHOD get_cr_type.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    rv_usmd_crequest_type = COND #( WHEN cl_usmd_app_context=>get_context( ) IS BOUND THEN cl_usmd_app_context=>get_context( )->mv_crequest_type  ).

* #FallBack API Code
    IF rv_usmd_crequest_type IS INITIAL.
      rv_usmd_crequest_type = read_crequest( iv_crequest = COND #( WHEN iv_crequest IS NOT INITIAL THEN iv_crequest ELSE get_cr_number( ) ) )-usmd_creq_type.
*    ls_process = cl_usmd2_cust_access_service=>get_process_by_crequest_type( iv_crequest_type = lv_crequest_type ).
    ENDIF.

* #Fallback API Code
    IF rv_usmd_crequest_type IS INITIAL.
      CALL METHOD cl_usmd_crequest_util=>get_cr_type_by_cr
        EXPORTING
          i_crequest = COND #( WHEN iv_crequest IS NOT INITIAL THEN iv_crequest ELSE get_cr_number( ) )
          io_model   = get_cr_usmd_model_api( )
        RECEIVING
          e_cr_type  = rv_usmd_crequest_type.
    ENDIF.

* #FallBack API Code
    IF rv_usmd_crequest_type IS INITIAL.
      DATA(lo_cr_api) = get_cr_api( iv_crequest = COND #( WHEN iv_crequest IS NOT INITIAL THEN iv_crequest ELSE get_cr_number( ) ) ).
      IF lo_cr_api IS BOUND.
        lo_cr_api->read_crequest( IMPORTING es_crequest = DATA(ls_crequest) ).
        rv_usmd_crequest_type = ls_crequest-usmd_creq_type.
      ENDIF.
    ENDIF.


* #FallBack API Code
    IF rv_usmd_crequest_type IS INITIAL.
      DATA(lo_gov) = get_cr_gov_api( iv_crequest = COND #( WHEN iv_crequest IS NOT INITIAL THEN iv_crequest ELSE get_cr_number( ) ) ).
      IF lo_gov IS BOUND.
        TRY.
            rv_usmd_crequest_type = lo_gov->get_crequest_attributes( iv_crequest_id =  COND #( WHEN iv_crequest IS NOT INITIAL THEN iv_crequest ELSE get_cr_number( ) ) )-usmd_creq_type.
          CATCH cx_usmd_gov_api_core_error. " CX_USMD_CORE_DYNAMIC_CHECK
          CATCH cx_usmd_gov_api.            " General Processing Error GOV_API
        ENDTRY.
      ENDIF.
    ENDIF.

    IF rv_usmd_crequest_type IS INITIAL.
      rv_usmd_crequest_type = get_cr_type_from_url( ).
    ENDIF.

*--------------------------------------------------------------------*
*While tesitng using Test Class since APIs are not Active we can check DB
*--------------------------------------------------------------------*
    IF rv_usmd_crequest_type IS INITIAL AND iv_crequest IS NOT INITIAL.
      SELECT SINGLE FROM usmd120c
                  FIELDS usmd_creq_type
                   WHERE usmd_crequest = @iv_crequest
                    INTO  @rv_usmd_crequest_type
                       .
    ENDIF.

*    if rv_usmd_crequest_type is not initial.
    gv_crequest_type = rv_usmd_crequest_type.
*    endif.


  ENDMETHOD.


  METHOD get_cr_usmd_model_ext_api.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    DATA  lo_model TYPE REF TO if_usmd_model.

    cl_usmd_model_ext=>get_instance( EXPORTING i_usmd_model = COND #( WHEN iv_usmd_model IS INITIAL THEN get_data_model( iv_crequest ) ELSE iv_usmd_model )
                                     IMPORTING eo_instance  = ro_model_ext ).

    IF ro_model_ext IS NOT BOUND.

      get_cr_usmd_model_api(
           EXPORTING
             iv_usmd_model = get_model_by_cr( iv_crequest = iv_crequest )
           IMPORTING
             et_message    = et_message
           RECEIVING
             ro_model      = lo_model
         ).

      CHECK NOT line_exists( et_message[ msgty = if_xo_const_message=>error ] ).

      ro_model_ext     = lo_model->get_instance_ext( ).

    ENDIF.

    IF ro_model_ext IS BOUND.
      go_model_ext = ro_model_ext.
    ENDIF.

  ENDMETHOD.


  METHOD get_data_model.
*****************************************************************************************
* Object Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  : Rahul Bhayani
* Release ID    :
**************************************************************************************
    rv_usmd_model = COND #( WHEN cl_usmd_app_context=>get_context( ) IS BOUND
                            THEN cl_usmd_app_context=>get_context( )->mv_usmd_model  ).

    DATA(lv_crequest) = COND #( WHEN iv_crequest IS NOT INITIAL THEN iv_crequest ELSE get_cr_number( ) ).

    IF rv_usmd_model IS INITIAL AND lv_crequest IS NOT INITIAL.
*Get data model by using change request number
      CALL METHOD cl_usmd_crequest_util=>get_model_by_cr
        EXPORTING
          i_crequest = lv_crequest
        IMPORTING
          e_model    = rv_usmd_model.
    ENDIF.

    IF rv_usmd_model IS INITIAL.
      get_application_parameter( IMPORTING ev_model  =  rv_usmd_model ).               " Change Request
    ENDIF.

  ENDMETHOD.


  METHOD get_description.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          : 06-01-2022
* Change No     : 8200004936
* WRICEF-ID     :
* Defect-ID     :
* Transport     : DDMK902368
* Developer ID  : ( EXT_BHAYANIR ) Rahul Bhayani
* Release ID    : 01
* Developed For Custom Data Model : ZP - Product Hierarchy
**************************************************************************************

*    field-symbols <ft_pimnode1> type any table. "type ty_pimnode1.
*    data           lt_pimnode1  type sorted table of zpmdg_s_zp_pp_pimnode1 with non-unique default key.
*
*    field-symbols <ft_zph_pim2> type any table. "ty_zph_pim2.
*    data           lt_zph_pim2  type sorted table of zpmdg_s_zp_pp_zph_pim2 with non-unique default key.
*
*    field-symbols <ft_zph_pim3> type any table. "ty_zph_pim3.
*    data           lt_zph_pim3  type sorted table of zpmdg_s_zp_pp_zph_pim3 with non-unique default key.

*    field-symbols <ft_zph_prd> type any table. "type ty_zph_prd.
*    data           lt_zph_prd  type sorted table of zpmdg_s_zp_zph_prd with non-unique default key.
    DATA           lv_string   TYPE string.
    DATA           lv_comma    TYPE char01.

    DATA lt_entity_data TYPE usmd_ts_data_entity.
    FIELD-SYMBOLS: <data>   TYPE ANY TABLE,
                   <struct> TYPE any,
                   <field>  TYPE any,
                   <name>   TYPE any.

    DATA(gov_ref) = get_cr_gov_api( iv_crequest = iv_crequest ).
    IF gov_ref IS BOUND.
      gov_ref->get_crequest_data(
        EXPORTING
          iv_crequest_id          = iv_crequest
        IMPORTING
          et_entity_data_inactive = DATA(inactive_t)
      ).
    ELSE.
      DATA(lo_conv) = get_som_gov_api( ).
      IF lo_conv IS BOUND.
        inactive_t = lo_conv->get_crequest_data( ).
      ENDIF.
    ENDIF.

    CHECK inactive_t IS NOT INITIAL.

*    lt_entity_data = value #( for ls_row in inactive_t ( usmd_entity = ls_row-usmd_entity usmd_entity_cont = ls_row-usmd_entity_cont struct = ls_row-struct r_t_data = ls_row-r_data ) ).
*    filter_parallel_cr_objects( exporting iv_crequest = iv_crequest changing ct_entity_data = lt_entity_data  ).
*
*    "check if key was reassigned
**   read table inactive_t with key struct = 'KATTR' usmd_entity_cont = 'ZPH_PRD' assigning field-symbol(<inactive>).
*    read table lt_entity_data with table key  usmd_entity      = gc_pimnode1
*                                              usmd_entity_cont = gc_zph_prd
*                                              struct           = if_usmd_conv_som_gov_api=>gc_struct_key_attr  assigning field-symbol(<inactive>).
*    if sy-subrc = 0.
**          assign <inactive>-r_data->* to <data>.
*      assign <inactive>-r_t_data->* to <data>.
*      lt_zph_prd  = <data>.
**      loop at <data> assigning <struct>.
*      loop at lt_zph_prd assigning field-symbol(<fs_row>)."<struct>.
*        check <fs_row>-pimnode4 na '$'.
*        check is_product_key_reassigned( iv_product_key = <fs_row>-pimnode4  iv_pim_node3 = <fs_row>-pimnode3  ) eq abap_true.
*        data(lv_reassign) = abap_true.
*        concatenate lv_string lv_comma <fs_row>-pimnode4 into lv_string separated by space.
*        lv_comma = ',' ##NO_TEXT .
*      endloop.
*      if lv_reassign = abap_true.
*        rv_description = |Reassign Key { lv_string }| ##NO_TEXT .
*        return.
*      endif.
*    endif.
*
*    "check if new product Type was created
**   read table inactive_t with key struct = 'KATTR' usmd_entity_cont = '' assigning <inactive>.
*    read table lt_entity_data with table key  usmd_entity      = gc_pimnode1
*                                              usmd_entity_cont = ''
*                                              struct           = if_usmd_conv_som_gov_api=>gc_struct_key_attr  assigning <inactive>.
*    if sy-subrc = 0.
**          assign <inactive>-r_data->* to <data>.
*      assign <inactive>-r_t_data->* to <data>.
*      loop at <data> assigning <struct>.
*        assign component gc_pimnode1 of structure <struct> to <field>.
*        if <field>(1) = '$'.
*          assign component gc_zp_pim1en  of structure <struct> to <name>.
*          rv_description = |New Type { <name> }| ##NO_TEXT .
*          return.
*        endif.
*      endloop.
*    endif.
*
*    "check if new product family was created
**   read table inactive_t with key struct = 'KATTR' usmd_entity_cont = 'ZPH_PIM2' assigning <inactive>.
*    read table lt_entity_data with table key  usmd_entity      = gc_pimnode1
*                                              usmd_entity_cont = gc_zph_pim2
*                                              struct           = if_usmd_conv_som_gov_api=>gc_struct_key_attr  assigning <inactive>.
*    if sy-subrc = 0.
**          assign <inactive>-r_data->* to <data>.
*      assign <inactive>-r_t_data->* to <data>.
*      loop at <data> assigning <struct>.
*        assign component gc_pimnode2 of structure <struct> to <field>.
*        if <field>(1) = '$'.
*          assign component gc_zp_pim2en  of structure <struct> to <name>.
*          rv_description = |New Family { <name> }| ##NO_TEXT .
*          return.
*        endif.
*      endloop.
*    endif.
*
*    "check if new product group was created
**   read table inactive_t with key struct = 'KATTR' usmd_entity_cont = 'ZPH_PIM3' assigning <inactive>.
*    read table lt_entity_data with table key  usmd_entity      = gc_pimnode1
*                                              usmd_entity_cont = gc_zph_pim3
*                                              struct           = if_usmd_conv_som_gov_api=>gc_struct_key_attr  assigning <inactive>.
*    if sy-subrc = 0.
**          assign <inactive>-r_data->* to <data>.
*      assign <inactive>-r_t_data->* to <data>.
*      loop at <data> assigning <struct>.
*        assign component gc_pimnode3 of structure <struct> to <field>.
*        if <field>(1) = '$'.
*          assign component 'ZP_PIM3EN' of structure <struct> to <name>.
*          rv_description = |New Group { <name> }| ##NO_TEXT .
*          return.
*        endif.
*      endloop.
*    endif.
*
*    "check if key was created
**   read table inactive_t with key struct = 'KATTR' usmd_entity_cont = 'ZPH_PRD' assigning <inactive>.
*    read table lt_entity_data with table key  usmd_entity      = gc_pimnode1
*                                              usmd_entity_cont = gc_zph_prd
*                                              struct           = if_usmd_conv_som_gov_api=>gc_struct_key_attr  assigning <inactive>.
*    if sy-subrc = 0.
**          assign <inactive>-r_data->* to <data>.
*      assign <inactive>-r_t_data->* to <data>.
*      loop at <data> assigning <struct>.
*        assign component gc_pimnode4 of structure <struct> to <field>.
*        if <field>(1) = '$'.
*          assign component gc_zp_prdnen of structure <struct> to <name>.
*          rv_description = |New Key { <name> }| ##NO_TEXT .
*          return.
*        endif.
*      endloop.
*    endif.
*
*    "last case something else was changed
**    read table inactive_t with key struct = 'KATTR' usmd_entity_cont = '' assigning <inactive>.
*    read table lt_entity_data with table key  usmd_entity      = gc_pimnode1
*                                              usmd_entity_cont = ''
*                                              struct = if_usmd_conv_som_gov_api=>gc_struct_key_attr  assigning <inactive>.
*    if sy-subrc = 0.
**          assign <inactive>-r_data->* to <data>.
*      assign <inactive>-r_t_data->* to <data>.
*      loop at <data> assigning <struct>.
*        assign component gc_zp_pim1en  of structure <struct> to <name>.
*        rv_description = |Change { <name> }| ##NO_TEXT .
*        return.
*      endloop.
*    endif.
*
*    if rv_description is initial.
*      data: lt_table type zcl_mdg_zp_tree_ui=>ty_cds_view.
*      data(lt_tree_ui_data) = zcl_mdg_zp_access_prdhry=>get_tree_data( importing et_tree_table =  lt_table  ).
*
*      read table lt_entity_data with table key  usmd_entity      = gc_pimnode1
*                                                usmd_entity_cont = ''
*                                                struct = if_usmd_conv_som_gov_api=>gc_struct_key  assigning <inactive>.
*      if sy-subrc = 0.
**          assign <inactive>-r_data->* to <data>.
*        assign <inactive>-r_t_data->* to <data>.
*        loop at <data> assigning <struct>.
*          assign component gc_pimnode1 of structure <struct> to <name>.
*          check <name> is assigned.
*          data(lv_descr) = value #( lt_table[ product_type = <name> ]-product_type_desc_en optional ).
*          rv_description = |Change { lv_descr }| ##NO_TEXT .
*          return.
*        endloop.
*      endif.
*    endif.

  ENDMETHOD.


  METHOD get_dynamic_table_ref.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    DATA ls_table_type            TYPE cl_drf_service_tools=>ty_s_table_type.

    MOVE-CORRESPONDING  is_table_type_data  TO ls_table_type.

    TRY.
        er_table = cl_drf_service_tools=>create_relevant_objects_table(
                   is_table_type            = ls_table_type
                   ).

      CATCH cx_sy_create_data_error.
        ev_error = abap_true.
    ENDTRY.




  ENDMETHOD.


  METHOD get_dynamic_table_type.
****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    DATA ls_table_type            TYPE cl_drf_service_tools=>ty_s_table_type.

    cl_drf_service_tools=>describe_relevant_objects_type(
      EXPORTING
        iv_relevant_objects_type = iv_table_type_name
      IMPORTING
        es_table_type            = ls_table_type
        ).

    IF ls_table_type-attributes-keys IS INITIAL.
      ev_error = abap_true.
    ENDIF.

    CHECK ev_error = abap_false.

    IF ls_table_type-attributes-line_contains_ref_to = abap_true.
      ev_error = abap_true.
    ENDIF.

    MOVE-CORRESPONDING ls_table_type TO er_table_type.
    et_keyonly_line_descr[] = ls_table_type-descriptions-keyonly_line_descr[].

  ENDMETHOD.


  METHOD get_key_value.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          : 06-01-2022
* Change No     : 8200004936
* WRICEF-ID     :
* Defect-ID     :
* Transport     : DDMK902368
* Developer ID  : ( EXT_BHAYANIR ) Rahul Bhayani
* Release ID    : 01
* Developed For Custom Data Model : ZP - Product Hierarchy
**************************************************************************************
    DATA lv_and TYPE string.

    CALL METHOD cl_usmd_mdf_model_generator=>get_data_model_info
      EXPORTING
        i_model             = get_data_model( )
      IMPORTING
        et_entity_fieldname = DATA(lt_entity_fieldname)
        et_fdep_r_entity    = DATA(lt_fdep_r_entity).

    cl_usmd_services=>get_entity_key_attributes(
      EXPORTING
        iv_model     = get_data_model( )       " Data Model
        iv_entity    = iv_entity               " Entity Type
      RECEIVING
        rt_attribute =  DATA(lt_keys)          " Attributes
    ).

    IF iv_entity_key_string IS INITIAL.

      DATA(lv_key) = VALUE #( lt_fdep_r_entity[ usmd_entity = iv_entity f_superordinate = space ]-master_entity OPTIONAL ).
      IF lv_key IS NOT INITIAL.
        CHECK line_exists( lt_keys[ table_line = lv_key ] ).
        ASSIGN COMPONENT lv_key OF STRUCTURE is_selected_records TO FIELD-SYMBOL(<fs_val>).
      ELSE.
        ASSIGN COMPONENT 1 OF STRUCTURE is_selected_records TO <fs_val>."Get Key of Root Entity
      ENDIF.

      IF <fs_val> IS ASSIGNED.
        rv_value = <fs_val>.
      ENDIF.

      IF iv_key_string EQ abap_true AND <fs_val> IS ASSIGNED.
        IF lv_key IS NOT INITIAL.
          rv_value = lv_key && ` = ` &&  ` ` && <fs_val>  &&  ` `.
        ELSE.
          rv_value = get_cr_main_entity(  ) && ` = ` &&  ` ` && <fs_val>  &&  ` `.
        ENDIF.
      ENDIF.

    ELSE.

      LOOP AT lt_keys INTO DATA(ls_keys).
        DATA(lv_value)  = read_into( component_name =  CONV #( ls_keys ) structure = is_selected_records ).
        et_entity_key  = VALUE #( BASE et_entity_key (  entity = iv_entity
                                                       ty_key  = VALUE #( fieldname = ls_keys value = lv_value )
                                                      ) ) .
        rv_value = rv_value && lv_and && ls_keys && ` = ` && `'` && read_into( component_name =  CONV #( ls_keys ) structure = is_selected_records  ) && `' ` .
        lv_and   = 'AND'.
      ENDLOOP.
    ENDIF.

  ENDMETHOD.


  METHOD get_mail_text.
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* User ID       :
* Release ID    :
*
* Change Description:
* Get mail text
**************************************************************************************

* Get email subject
    IF iv_subject IS NOT INITIAL.
* Read text for mail subject content
      CALL FUNCTION 'READ_TEXT'
        EXPORTING
          client                  = sy-mandt
          id                      = iv_tdid
          language                = v_language
          name                    = iv_subject
          object                  = iv_tdobject
          archive_handle          = 0
          local_cat               = ' '
        TABLES
          lines                   = et_subject
        EXCEPTIONS
          id                      = 1
          language                = 2
          name                    = 3
          not_found               = 4
          object                  = 5
          reference_check         = 6
          wrong_access_to_archive = 7
          OTHERS                  = 8.
      IF sy-subrc = 0 AND iv_sub_has_identifier = abap_true.
* Initialize Text Symbols
        CALL FUNCTION 'INIT_TEXTSYMBOL'.
* Replace Text Symbols
        IF iv_sub_name1 IS NOT INITIAL.
          CALL FUNCTION 'SET_TEXTSYMBOL'
            EXPORTING
              name    = iv_sub_name1
              value   = iv_sub_value1
              replace = abap_true.
        ENDIF.
        IF iv_sub_name2 IS NOT INITIAL.
          CALL FUNCTION 'SET_TEXTSYMBOL'
            EXPORTING
              name    = iv_sub_name2
              value   = iv_sub_value2
              replace = abap_true.
        ENDIF.
        IF iv_sub_name3 IS NOT INITIAL.
          CALL FUNCTION 'SET_TEXTSYMBOL'
            EXPORTING
              name    = iv_sub_name3
              value   = iv_sub_value3
              replace = abap_true.
        ENDIF.
        DESCRIBE TABLE et_subject LINES DATA(lv_lines).
* Replace variables in Text symbols
        CALL FUNCTION 'REPLACE_TEXTSYMBOL'
          EXPORTING
            endline     = lv_lines
            formatwidth = 132 ##NUMBER_OK
            startline   = 1 ##NUMBER_OK
          TABLES
            lines       = et_subject.
        CLEAR lv_lines.
      ENDIF.
    ENDIF.

    IF iv_body IS NOT INITIAL.
* Read text for mail subject content
      CALL FUNCTION 'READ_TEXT'
        EXPORTING
          client                  = sy-mandt
          id                      = iv_tdid
          language                = v_language
          name                    = iv_body
          object                  = iv_tdobject
          archive_handle          = 0
          local_cat               = ' '
        TABLES
          lines                   = et_body
        EXCEPTIONS
          id                      = 1
          language                = 2
          name                    = 3
          not_found               = 4
          object                  = 5
          reference_check         = 6
          wrong_access_to_archive = 7
          OTHERS                  = 8.
      IF sy-subrc = 0 AND iv_body_has_identifier = abap_true.
* Initialize Text Symbols
        CALL FUNCTION 'INIT_TEXTSYMBOL'.
* Replace Text Symbols
        IF iv_name1 IS NOT INITIAL.
          CALL FUNCTION 'SET_TEXTSYMBOL'
            EXPORTING
              name    = iv_name1
              value   = iv_value1
              replace = abap_true.
        ENDIF.
        IF iv_name2 IS NOT INITIAL.
          CALL FUNCTION 'SET_TEXTSYMBOL'
            EXPORTING
              name    = iv_name2
              value   = iv_value2
              replace = abap_true.
        ENDIF.
        IF iv_name3 IS NOT INITIAL.
          CALL FUNCTION 'SET_TEXTSYMBOL'
            EXPORTING
              name    = iv_name3
              value   = iv_value3
              replace = abap_true.
        ENDIF.
        IF iv_name4 IS NOT INITIAL.
          CALL FUNCTION 'SET_TEXTSYMBOL'
            EXPORTING
              name    = iv_name4
              value   = iv_value4
              replace = abap_true.
        ENDIF.
        IF iv_name5 IS NOT INITIAL.
          CALL FUNCTION 'SET_TEXTSYMBOL'
            EXPORTING
              name    = iv_name5
              value   = iv_value5
              replace = abap_true.
        ENDIF.
        DESCRIBE TABLE et_body LINES lv_lines.
* Replace variables in Text symbols
        CALL FUNCTION 'REPLACE_TEXTSYMBOL'
          EXPORTING
            endline     = lv_lines
            formatwidth = 132 ##NUMBER_OK
            startline   = 1 ##NUMBER_OK
          TABLES
            lines       = et_body.
      ENDIF.
    ENDIF.

  ENDMETHOD.


  METHOD get_model_by_cr.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
*Get data model by using change request number
    CHECK iv_crequest IS NOT INITIAL.

    CALL METHOD cl_usmd_crequest_util=>get_model_by_cr
      EXPORTING
        i_crequest = COND #( WHEN iv_crequest IS NOT INITIAL THEN iv_crequest ELSE get_cr_number( ) )
      IMPORTING
        e_model    = rv_usmd_model.

  ENDMETHOD.


  METHOD get_notif_config.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    DATA lv_uname              TYPE uname.
    DATA lv_user_login_langu   TYPE lang.

    IF gv_crequest_status IS NOT INITIAL.

      lv_uname = VALUE #( gt_rcpt_sapid[ 1 ]-user_value OPTIONAL ).

*--------------------------------------------------------------------*
*Should Not Happen - Only For Testing
*--------------------------------------------------------------------*
      IF lv_uname IS INITIAL.
        lv_uname = sy-uname.
      ENDIF.

      CALL FUNCTION 'LOGIN_LANG_GET'
        EXPORTING
          username          = lv_uname
        IMPORTING
          result_login_lang = lv_user_login_langu.

*--------------------------------------------------------------------*
*Should Not Happen
*--------------------------------------------------------------------*
      IF lv_user_login_langu IS INITIAL.
        lv_user_login_langu = 'E'.
      ENDIF.

      CALL FUNCTION 'CONVERSION_EXIT_ISOLA_OUTPUT'
        EXPORTING
          input  = lv_user_login_langu
        IMPORTING
          output = gv_user_langu.

*      select from zmdg_d_cnfmail
*           fields *
*            where usmd_creq_type    = @gv_crequest_type
*              and usmd_creq_status  = @gv_crequest_status
*              and langup_iso        = @gv_user_langu
*       into table @dt_cnfmail.

      IF sy-subrc <> 0.

        gv_user_langu = 'EN'."Always EN Should be Present

*        select from zmdg_d_cnfmail
*                   fields *
*                    where usmd_creq_type    = @gv_crequest_type
*                      and usmd_creq_status  = @gv_crequest_status
*                      and langup_iso        = @gv_user_langu
*               into table @dt_cnfmail.
      ENDIF.

    ENDIF.

    IF gv_crequest_step IS NOT INITIAL.

*      select from zmdg_d_cnfmail
*           fields *
*            where usmd_creq_type = @gv_crequest_type
*              and cr_step = @gv_crequest_step
*       into table @dt_cnfmail.

    ENDIF.
  ENDMETHOD.


  METHOD get_pp_access.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :

**************************************************************************************
    cl_usmd_pp_access_factory=>get_pp_access(
      EXPORTING
        io_model             = io_model
        i_entity             = i_entity                 " Entity Type
      RECEIVING
        eo_pp_access_adapter = eo_pp_access_adapter                 " Adapter for Access to Active Area
    ).
  ENDMETHOD.


  METHOD get_range_table_for_any_type.
****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    DATA : lo_elemdescr TYPE REF TO cl_abap_elemdescr.

    FIELD-SYMBOLS: <ft> TYPE table.

    DATA:
      lr_sign_descr   TYPE REF TO cl_abap_elemdescr,
      lr_option_descr TYPE REF TO cl_abap_elemdescr,
      lr_value_descr  TYPE REF TO cl_abap_elemdescr,
      lr_struct_descr TYPE REF TO cl_abap_structdescr,
      lr_table_descr  TYPE REF TO cl_abap_tabledescr,
      lt_components   TYPE cl_abap_structdescr=>component_table,
      rt_range_table  TYPE REF TO data.

    CLEAR er_data.

    lo_elemdescr    ?= cl_abap_elemdescr=>describe_by_data( iv_any ).
    lr_sign_descr   ?= cl_abap_elemdescr=>describe_by_name( 'DDSIGN' ).
    lr_option_descr ?= cl_abap_elemdescr=>describe_by_name( 'DDOPTION' ).

    CASE lo_elemdescr->type_kind.
      WHEN 'N'.
        lr_value_descr ?= cl_abap_elemdescr=>get_n( p_length = lo_elemdescr->output_length ).
      WHEN 'C'.
        lr_value_descr ?= cl_abap_elemdescr=>get_c( p_length = lo_elemdescr->output_length ).
      WHEN 'X'.
        lr_value_descr ?= cl_abap_elemdescr=>get_x( p_length = lo_elemdescr->output_length ).
      WHEN 'P'.
        lr_value_descr ?= cl_abap_elemdescr=>get_p( p_length = lo_elemdescr->output_length p_decimals = lo_elemdescr->decimals ).
      WHEN OTHERS.
        lr_value_descr ?= cl_abap_elemdescr=>describe_by_name( lo_elemdescr->absolute_name+6 ).
    ENDCASE.

    lt_components = VALUE #( ( name = 'SIGN'   type = lr_sign_descr   )
                             ( name = 'OPTION' type = lr_option_descr )
                             ( name = 'LOW'    type = lr_value_descr  )
                             ( name = 'HIGH'   type = lr_value_descr  )  ).


    lr_struct_descr = cl_abap_structdescr=>create( p_components = lt_components p_strict = abap_true ).
    lr_table_descr  = cl_abap_tabledescr=>create( p_line_type = lr_struct_descr ).

    CREATE DATA rt_range_table TYPE HANDLE lr_table_descr.

    ASSIGN rt_range_table->* TO <ft>.

    IF <ft> IS ASSIGNED.
      INSERT INITIAL LINE INTO <ft> ASSIGNING FIELD-SYMBOL(<fs_row>) INDEX 1.
      CHECK <fs_row> IS ASSIGNED.
      ASSIGN COMPONENT 'SIGN' OF STRUCTURE <fs_row> TO  FIELD-SYMBOL(<fv_sign>).
      CHECK <fv_sign> IS ASSIGNED.
      <fv_sign> = 'I'.
      ASSIGN COMPONENT 'OPTION' OF STRUCTURE <fs_row> TO  FIELD-SYMBOL(<fv_option>).
      CHECK <fv_option> IS ASSIGNED.
      <fv_option> = iv_option.
      ASSIGN COMPONENT 'LOW' OF STRUCTURE <fs_row> TO  FIELD-SYMBOL(<fv_low>).
      CHECK <fv_low> IS ASSIGNED.
      <fv_low> = iv_param_value.
      er_data = rt_range_table.
    ENDIF.
  ENDMETHOD.


  METHOD get_som_gov_api.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          : 06-01-2022
* Change No     : 8200004936
* WRICEF-ID     :
* Defect-ID     :
* Transport     : DDMK902368
* Developer ID  : ( EXT_BHAYANIR ) Rahul Bhayani
* Release ID    : 01
*
**************************************************************************************
    ro_mdg_api = COND #( WHEN go_mdg_api IS NOT BOUND THEN cl_usmd_search_assist=>get_mdg_api( ) ELSE go_mdg_api ).

    go_mdg_api = COND #( WHEN go_mdg_api IS NOT BOUND THEN ro_mdg_api ).


  ENDMETHOD.


  METHOD get_umb_service_owner_name.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    CALL FUNCTION 'UMB_SERVICE_OWNER_NAME'
      EXPORTING
        i_owner   = iv_user
      IMPORTING
        e_name    = rv_name
      EXCEPTIONS
        not_found = 1
        OTHERS    = 2.

    IF sy-subrc <> 0.
* #Log
    ENDIF.

  ENDMETHOD.


  METHOD is_my_obj_registered.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* User ID       :
* Release ID    :
*
* Change Description:
* Check Customer exist in Active area of MDG
**************************************************************************************

    DATA : lv_update_flag TYPE boole_d.

    DATA(lt_formatted_stack) = cl_abap_get_call_stack=>format_call_stack_with_struct(
                               cl_abap_get_call_stack=>get_call_stack( ) ).
    "check if the object is registerd - only for Enhancement
    "below logic will work only for ENHO object type

    IF lt_formatted_stack[ 2 ]-includename CS '=E'.
      DATA(lv_caller_enho_name) = substring_before( val = lt_formatted_stack[ 2 ]-includename sub = '=' ).
      "validate if the caller method and User entry maintined in the YZTABL_code_deb
      SELECT SINGLE COUNT(*)
          FROM yztabl_code_deb
         WHERE pgmid    = 'R3TR'
           AND objtype  = 'ENHO'
           AND obj_name = @lv_caller_enho_name.

      rv_return = COND boole( WHEN sy-subrc EQ 0 THEN abap_true
                                                 ELSE abap_false ).
      DO.
        SELECT SINGLE COUNT(*)
           FROM yztabl_code_deb
*           INTO @DATA(lv_active)
           WHERE  pgmid = 'R3TR'
            AND   objtype = 'ENHO'
            AND   obj_name = @lv_caller_enho_name
            AND   uname = @sy-uname
            AND   restrict_debug = @abap_false
            AND   active = @abap_true.
        IF sy-subrc EQ 0.
          lv_update_flag = abap_true.
          IF sy-batch IS INITIAL.
            BREAK-POINT sy-uname.
          ENDIF.
        ELSE.
          EXIT.
        ENDIF.

      ENDDO.
      IF lv_update_flag IS NOT INITIAL.
        MODIFY yztabl_code_deb FROM @( VALUE #( pgmid = 'R3TR'
                                                 objtype = 'ENHO'
                                                 obj_name = lv_caller_enho_name
                                                 uname = sy-uname
                                                 restrict_debug = abap_false
                                                 active         = abap_true ) ).
      ENDIF.


      RETURN.

    ENDIF.
    "for non-enhancement objects
    CASE lt_formatted_stack[ 2 ]-kind.
      WHEN 'METHOD'.
        DATA(lv_caller_method_name) = substring_after( val = lt_formatted_stack[ 2 ]-event sub = '=>' ).
        DATA(lv_caller_class_name) =  substring_before( val = lt_formatted_stack[ 2 ]-event sub = '=>' ).

        "validate if the caller method and USer entry maintined in the YZTABL_code_deb
        DO.
          SELECT SINGLE restrict_debug,active
             FROM yztabl_code_deb
             INTO ( @DATA(lv_restrict_debug),@DATA(lv_active) )
             WHERE  pgmid = 'R3TR'
              AND   objtype = 'CLAS'
              AND   obj_name = @lv_caller_class_name
              AND   uname    = @sy-uname
              AND   sobj_name = @lv_caller_method_name
              AND   restrict_debug = @abap_false.
          IF sy-subrc EQ 0 AND lv_active IS NOT INITIAL AND sy-batch IS INITIAL.
            lv_update_flag = abap_true. "foreground
            BREAK-POINT sy-uname.
          ELSEIF lv_active IS INITIAL.
            EXIT.
          ENDIF.
          lv_update_flag = abap_true.   "back ground

        ENDDO.

        IF lv_update_flag IS NOT INITIAL.
          MODIFY yztabl_code_deb FROM @( VALUE #( pgmid = 'R3TR'
                                                   objtype = 'CLAS'
                                                   obj_name = lv_caller_class_name
                                                   uname = sy-uname
                                                   sobj_name = lv_caller_method_name
                                                   restrict_debug = abap_true
                                                   active = abap_true ) ).
        ENDIF.

      WHEN 'FUNCTION'.
        DATA(lv_caller_funct_name) = lt_formatted_stack[ 2 ]-event.

        "validate if the caller Function and USer entry maintined in the YZTABL_code_deb
        DO.

          SELECT SINGLE restrict_debug,active
             FROM yztabl_code_deb
             INTO (@lv_restrict_debug,@lv_active )
             WHERE pgmid = 'R3TR'
              AND objtype = 'FUGR'
              AND obj_name = @lv_caller_funct_name
              AND uname    = @sy-uname
              AND restrict_debug = @abap_false.
          IF sy-subrc EQ 0 AND lv_active IS NOT INITIAL AND sy-batch IS INITIAL.
            lv_update_flag = abap_true. "foreground
            BREAK-POINT sy-uname.
          ELSEIF lv_active IS INITIAL.
            EXIT.
          ENDIF.
          lv_update_flag = abap_true. "background

        ENDDO.
        IF lv_update_flag IS NOT INITIAL.
          MODIFY yztabl_code_deb FROM @( VALUE #(  pgmid = 'R3TR'
                                                   objtype = 'FUGR'
                                                   obj_name = lv_caller_class_name
                                                   uname = sy-uname
                                                   sobj_name = lv_caller_method_name
                                                   restrict_debug = abap_true
                                                   active = abap_true ) ).
        ENDIF.
      WHEN OTHERS.
    ENDCASE.





  ENDMETHOD.


  METHOD message_hyperlink.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    DATA lo_model   TYPE REF TO if_usmd_model_ext.
    DATA lo_key_ref TYPE REF TO data.

    FIELD-SYMBOLS <ls_key> TYPE any.

    cl_usmd_model_ext=>get_instance(
      EXPORTING i_usmd_model = get_data_model( )
      IMPORTING eo_instance  = lo_model ).

    lo_model->create_data_reference(
      EXPORTING i_fieldname = iv_entity && ''
                i_struct    = if_usmd_model_ext=>gc_struct_key
                if_table    = abap_false
      IMPORTING er_data     = lo_key_ref ).

    ASSIGN lo_key_ref->* TO <ls_key>.
    MOVE-CORRESPONDING is_entity_data TO <ls_key>.

    cl_mdg_bs_key_row_map_service=>set_key(
      EXPORTING is_key       = lo_key_ref
                iv_entity    = iv_entity
                iv_fieldname = iv_attribute
      RECEIVING rv_row       = ev_row ).
  ENDMETHOD.


  METHOD read_crequest.

*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************

    DATA lo_usmd_model_util TYPE REF TO cl_usmd_crequest_util.
    DATA lo_model           TYPE REF TO if_usmd_model.

    CREATE OBJECT lo_usmd_model_util.

    lo_usmd_model_util->get_data_model(
      EXPORTING id_crequest = iv_crequest
      IMPORTING eo_model    = lo_model ).

    lo_usmd_model_util->get_crequest(
      EXPORTING id_crequest     = iv_crequest
                io_model        = lo_model
      IMPORTING es_crequest     = rs_crequest ).
  ENDMETHOD.


  METHOD read_cr_data.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    DATA : lr_model    TYPE REF TO if_usmd_model_ext,
           lt_sel      TYPE usmd_ts_sel,
           lt_objlist  TYPE usmd_t_crequest_entity,
           ls_objlist  TYPE usmd_s_crequest_entity,
           lv_readmode TYPE usmd_readmode_ext.

    CONSTANTS: lc_incl  TYPE ddsign   VALUE 'I',
               lc_equal TYPE ddoption VALUE 'EQ'.

    CHECK iv_cr_number IS NOT INITIAL.

    CALL METHOD cl_usmd_model_ext=>get_instance
      EXPORTING
        i_usmd_model = gc_model               " Data model
      IMPORTING
        eo_instance  = lr_model.

    lt_sel = VALUE #( ( sign = lc_incl option = lc_equal fieldname = usmd0_cs_fld-crequest low = iv_cr_number ) ).

    lv_readmode = '2'.

    CHECK lr_model IS BOUND.

    CALL METHOD lr_model->read_char_value
      EXPORTING
        i_fieldname       = usmd0_cs_fld-crequest                 " Field Name
        it_sel            = lt_sel
*       i_readmode        = lv_readmode
        if_use_edtn_slice = abap_false
      IMPORTING
        et_data           = lt_objlist.

    READ TABLE lt_objlist INTO ls_objlist INDEX 1.

*  rv_root_entity_key = ls_objlist-usmd_value.

  ENDMETHOD.


  METHOD read_cr_details.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    CALL METHOD go_model_ext->read_char_value
      EXPORTING
        i_fieldname       = usmd0_cs_fld-crequest
        it_sel            = VALUE #( ( sign = 'I' option = 'EQ' fieldname = usmd0_cs_fld-crequest low = gv_crequest ) )
        if_use_edtn_slice = abap_false
      IMPORTING
        et_data           = rt_crdetails.

    CHECK  rt_crdetails IS NOT INITIAL.
    gs_crequest_attributes = VALUE #( rt_crdetails[ 1 ] OPTIONAL ).


  ENDMETHOD.


  METHOD read_entity_data.

    DATA:lts_sel     TYPE usmd_ts_sel,
         lif_model   TYPE REF TO if_usmd_model_ext,
         lts_objlist TYPE usmd_t_crequest_entity,
         lt_crequest TYPE TABLE OF usmd_s_crequest.

    CONSTANTS: lc_incl  TYPE ddsign   VALUE 'I',
               lc_equal TYPE ddoption VALUE 'EQ'.

    DATA lo_data1  TYPE REF TO data.
    FIELD-SYMBOLS <lt_data> TYPE ANY TABLE.

    CLEAR eo_data.
** Get Read-only access to USMD Model data
    cl_usmd_model_ext=>get_instance(
    EXPORTING
      i_usmd_model = get_data_model( )
    IMPORTING
      eo_instance  = lif_model
      et_message   = et_message ).

** Get CR No.
    lts_sel = VALUE usmd_ts_sel( ( fieldname = usmd0_cs_fld-crequest sign = lc_incl option = lc_equal low = iv_cr_number ) ).

** Get CR Details (CR Types, Text, Created/Changed By etc.) based on CR No.
    lif_model->read_char_value(
    EXPORTING
      i_fieldname       = usmd0_cs_fld-crequest
      it_sel            = lts_sel
      if_use_edtn_slice = abap_false
    IMPORTING
      et_data           = lt_crequest ).

    TRY .
        es_crequest = lt_crequest[ 1 ].
      CATCH cx_sy_itab_line_not_found ##NO_HANDLER.
    ENDTRY.

    TRY.

** Based on Entity & CR No.: Get Details
        lif_model->read_char_value(
        EXPORTING
          i_fieldname       = usmd0_cs_fld-crequest
          it_sel            = lts_sel
          if_use_edtn_slice = abap_false
        IMPORTING
          et_data           = lts_objlist ).

        lif_model->create_data_reference(
    EXPORTING i_fieldname = iv_entity_type && ''
              i_struct    = if_usmd_model=>gc_struct_key_attr
              i_tabtype   = if_usmd_model=>gc_tabtype_standard
    IMPORTING er_data     = lo_data1 ).

** Get Attributes Data
        IF iv_entity_type IS NOT INITIAL.


          ASSIGN lo_data1->* TO <lt_data>.
          IF <lt_data> IS  NOT ASSIGNED.
            RETURN.

          ENDIF.
          LOOP AT lts_objlist INTO DATA(ls_objlist) ##INTO_OK. "#EC CI_LOOP_INTO_WA
            CHECK ls_objlist-usmd_entity = iv_entity_type.

            INSERT VALUE #( fieldname = iv_entity_type
                                   sign      = 'I'
                                   option    = 'EQ'
                                   low       = ls_objlist-usmd_value )
                    INTO TABLE lts_sel.
          ENDLOOP.

          lif_model->read_char_value(
            EXPORTING
              i_fieldname = iv_entity_type && ''
              it_sel      = lts_sel
              i_readmode  = iv_readmode
              if_use_edtn_slice = abap_false
            IMPORTING
            et_data     = <lt_data>
            et_message  = et_message ).

        ENDIF.

      CATCH cx_sy_itab_line_not_found ##NO_HANDLER.

    ENDTRY.
    eo_data = lo_data1.


  ENDMETHOD.


  METHOD read_global_message.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    DATA(lo_bol_core) = cl_crm_bol_core=>get_instance( ).
    CHECK lo_bol_core IS BOUND.

    lo_bol_core->get_global_message_cont( ).
    DATA(lo_message_container) =  cl_crm_bol_core=>get_instance( )->get_global_message_cont( ).
    CHECK lo_message_container IS BOUND.


    lo_message_container->if_genil_message_container~get_messages(
      EXPORTING
        iv_message_type = if_genil_message_container=>mt_all  " Messages, Message Type
      IMPORTING
         et_messages     =  rt_message  ).                " Message Table

  ENDMETHOD.


  METHOD read_into.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    ASSIGN COMPONENT component_name OF STRUCTURE structure TO FIELD-SYMBOL(<fs_val>).

    IF <fs_val> IS ASSIGNED.
*Try To Return Value as String as Most of the case we need value in Char/String
      value_char = CONV #( <fs_val> ).
      value      = <fs_val>.
    ENDIF.

  ENDMETHOD.


  METHOD selection_table_as_conditions.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          : 06-01-2022
* Change No     : 8200004936
* WRICEF-ID     :
* Defect-ID     :
* Transport     : DDMK902368
* Developer ID  : ( EXT_BHAYANIR ) Rahul Bhayani
* Release ID    : 01
* Developed For Custom Data Model : ZP - Product Hierarchy
**************************************************************************************

*! Transfer the given selection table into corresponding WHERE clauses.
    CONSTANTS:
      and TYPE c LENGTH 3 VALUE 'AND',
      or  TYPE c LENGTH 2 VALUE 'OR'.

    DATA:
      ls_selection_line        LIKE LINE OF it_selection_table,
      lv_condition             TYPE string,
      lv_h_search_pattern(100) TYPE c,
      lv_helpfield1(100),
      lv_helpfield2(100),
      lv_index                 TYPE sy-tabix,
      lv_length                TYPE i,
      lv_offset                TYPE i,
      lv_previous_field        TYPE fieldname,
      lv_previous_operator     TYPE string,
      one_hochkomma(1)         TYPE c VALUE '''',
      two_hochkomma(2)         TYPE c VALUE ''''''.

    FIELD-SYMBOLS:
      <lv_condition> LIKE LINE OF rt_conditions.

    "convert the MDG selection table that contains fieldnames and range-like selection options
    "to a list of dynamic logical conditions that can be used in a WHERE clause
    CLEAR: lv_previous_field, lv_previous_operator.
    LOOP AT it_selection_table INTO ls_selection_line.
      lv_index = sy-tabix.
      "replace_1_qoute_to_2_qoutes
      IF ls_selection_line-low CS one_hochkomma.
        lv_h_search_pattern = ls_selection_line-low.
        lv_helpfield1 = lv_h_search_pattern.
        WHILE lv_helpfield1 CS one_hochkomma.
          lv_length = strlen( lv_h_search_pattern ).
          lv_offset = lv_offset + sy-fdpos.
          lv_helpfield2 = lv_helpfield1+sy-fdpos.
          REPLACE one_hochkomma WITH two_hochkomma INTO lv_helpfield2.
          lv_helpfield1 = lv_helpfield2+2.
          lv_h_search_pattern+lv_offset = lv_helpfield2.
          lv_offset = lv_offset + 2.
        ENDWHILE.
        ls_selection_line-low = lv_h_search_pattern.
      ENDIF.

      "'BT' and 'NB' need special treatment as they can not be used directly as operator
      IF ls_selection_line-option = 'BT' OR ls_selection_line-option = 'NB'.
        lv_condition = ls_selection_line-fieldname && ' BETWEEN ''' && ls_selection_line-low &&
                       ''' AND ''' && ls_selection_line-high && ''''.
        "take care of the NOT operator
        IF ( ls_selection_line-sign = 'E' AND ls_selection_line-option = 'BT' )
       OR ( ls_selection_line-sign = 'I' AND ls_selection_line-option = 'NB' ).
          lv_condition = 'NOT ' && lv_condition.
        ENDIF.
      ELSE.
        "all the rest of the existing operators can be used directly within a WHERE clause
        lv_condition = ls_selection_line-option && ' ''' && ls_selection_line-low && ''''.
        CONCATENATE ls_selection_line-fieldname lv_condition INTO lv_condition SEPARATED BY space.
        "take care of the NOT operator
        IF ls_selection_line-sign = 'E'.
          lv_condition = 'NOT ' && lv_condition.
        ENDIF.
      ENDIF.

      "Multiple lines require a valid WHERE clause operator. Different
      "fields are concatenated by AND, same fields by OR including
      "surrounding brackets ( )!
      IF lv_index > 1.
        IF lv_previous_field EQ ls_selection_line-fieldname.
          CONCATENATE or lv_condition INTO lv_condition SEPARATED BY space.
          IF lv_previous_operator NE or.
            "the previous line needs an opening bracket (
            READ TABLE rt_conditions INDEX ( lv_index - 1 )
              ASSIGNING <lv_condition>.
            IF lv_previous_operator IS INITIAL.
              "relates to the first line w/o operator
              <lv_condition> = |( { <lv_condition> }|.
            ELSE.
              "relates to a line with AND operator
              <lv_condition> = replace( val = <lv_condition> off = 3 len = 1 with = | ( | ).
            ENDIF.
          ENDIF.
          lv_previous_operator = or.
        ELSE.
          CONCATENATE and lv_condition INTO lv_condition SEPARATED BY space.
          IF lv_previous_operator EQ or.
            "the previous line needs a closing bracket )
            READ TABLE rt_conditions INDEX ( lv_index - 1 )
              ASSIGNING <lv_condition>.
            <lv_condition> = |{ <lv_condition> } )|.
          ENDIF.
          lv_previous_operator = and.
        ENDIF.
      ENDIF.

      "add condition
      APPEND lv_condition TO rt_conditions.
      lv_previous_field = ls_selection_line-fieldname.
    ENDLOOP.

    "if the last condition has been an OR, add the closing bracket )
    IF lv_previous_operator EQ or.
      READ TABLE rt_conditions INDEX lv_index
        ASSIGNING <lv_condition>.
      <lv_condition> = |{ <lv_condition> } )|.
    ENDIF.

  ENDMETHOD.


  METHOD send_mail_mdg.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
**************************************************************************************
*--------------------------------------------------------------------*
*    Set Global Variables
*--------------------------------------------------------------------*
    gv_crequest = COND #( WHEN iv_crequest IS NOT INITIAL THEN iv_crequest ).
    get_cr_usmd_model_ext_api( EXPORTING iv_crequest = iv_crequest  IMPORTING et_message = DATA(lt_message) ).
    get_cr_type( iv_crequest ).
    gv_crequest_status = COND #( WHEN iv_crequest_status IS NOT INITIAL THEN iv_crequest_status ELSE get_cr_status( iv_crequest  ) ).
*   get_cr_step( ).

* Set additional SAP users for email receipiants
    gt_rcpt_sapid[] = it_rcpt_sapid[].

* GET CONFIGURATION DATA FROM TABLE ZMDG_D_CNFMAIL
    get_notif_config( ).

*    loop at dt_cnfmail assigning field-symbol(<ls_cnfmail>).
* Call the Email method to populate the template and trigger mail
*      call method (<ls_cnfmail>-email_method)
*        exporting
*          is_zmdg_d_cnfmail = <ls_cnfmail>.
*    endloop.

  ENDMETHOD.


  METHOD update_cr_description.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :

**************************************************************************************
*  check  get_cr_type( iv_crequest = iv_crequest ) ne 'ZPMASSL'.

    DATA(lv_description) = COND usmd_txtlg( WHEN get_cr_status( iv_usmd_crequest = iv_crequest ) = usmd0_cs_crequest_status-finally_rejected THEN 'Withdrawed CR' ELSE get_description( iv_crequest ) ) ##NO_TEXT .

*    data(gov_ref) = get_gov_api( iv_crequest = iv_crequest ).
*    if gov_ref is bound.
*      try.
*          gov_ref->enqueue_crequest( iv_crequest_id = iv_crequest ).
*          gov_ref->set_crequest_attributes(
*            exporting
*              iv_crequest_id     =   iv_crequest
*              iv_crequest_text   =   conv #( cond #( when lv_description is not initial then lv_description else 'No Changes in Hierarchy' ) )
*          ).
**          gov_ref->dequeue_crequest( iv_crequest_id = iv_crequest ). "No Need if you are calling While SAVE / SUBMIT CR
**          gov_ref->save( ).                                          "No Need if you are calling While SAVE / SUBMIT CR
*        catch cx_usmd_gov_api_core_error.
*        catch cx_usmd_gov_api.
*      endtry.
*    endif.

*#FallBack API code
*    if gov_ref is initial.
    TRY.
        DATA(lo_api) = get_som_gov_api( ).
        IF lo_api IS BOUND.
          CHECK lo_api->is_cr_changeable( ) = abap_true.
          IF lo_api->mv_crequest_locked = abap_false.       "Check if Lock is already then Donot Add Lock Again
            lo_api->enqueue_crequest( iv_lock_mode = 'E' ).
          ENDIF.
          IF lv_description IS NOT INITIAL.
            lo_api->set_crequest_attributes(
              EXPORTING
                iv_crequest_text   = CONV #( COND #( WHEN lv_description IS NOT INITIAL THEN lv_description ELSE 'No Changes in Hierarchy' ) ) ##NO_TEXT
            ).
          ENDIF.
*            lo_api->dequeue_crequest( ). "No Need if you are calling While SAVE / SUBMIT CR
*            lo_api->save( ).             "No Need if you are calling While SAVE / SUBMIT CR
        ENDIF.
      CATCH cx_usmd_gov_api_core_error.
      CATCH cx_usmd_gov_api.
    ENDTRY.
*    endif.

*#FallBack API code
*    cl_usmd_crequest_api=>get_instance(
*      exporting
*        iv_crequest          = iv_crequest
*      importing
*        re_inst_crequest_api =  data(lo_cr_api)                " Change Request API Interface
*    ).
*
*    if lo_cr_api is bound.
*      lo_cr_api->set_attributes( exporting iv_crequest_txt = conv #( get_description( iv_crequest ) ) ).
*      lo_cr_api->save_crequest(
*        exporting
*          if_commit   = ' '              " Financial MDM: General Indicator
*          if_check    = ' '              " MDGAF: General Indicator
*        importing
*          ev_crequest = data(lv_cr)
*          et_message  = data(lt_message)                 " Messages
*      ).
*    endif.


  ENDMETHOD.


  METHOD update_snapshot.

*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************

    DATA lo_ui_services   TYPE REF TO if_usmd_ui_services.
    DATA lo_model         TYPE REF TO if_usmd_model.
    DATA lo_snapshot_ext  TYPE REF TO if_usmd_model_snapshot_ext.
    DATA lt_message       TYPE        usmd_t_message.
    DATA lv_error         TYPE        usmd_flg.

    CLEAR et_message.

    cl_usmd_factory_ext=>get_snapshot_instance(
      EXPORTING i_usmd_model = get_data_model( )
      IMPORTING eo_instance  = lo_snapshot_ext
                et_message   = lt_message ).

    APPEND LINES OF lt_message TO et_message.
    CLEAR lt_message.

    lo_snapshot_ext->update_cr_snapshot(
      EXPORTING i_crequest_id = iv_crequest
      IMPORTING et_message    = lt_message ).

    APPEND LINES OF lt_message TO et_message.
    CLEAR lt_message.

    lo_ui_services = cl_usmd_ui_services=>get_instance( ).

    cl_usmd_model=>get_instance(
      EXPORTING i_usmd_model = get_data_model( )
      IMPORTING eo_instance  = lo_model
                et_message   = lt_message ).

    APPEND LINES OF lt_message TO et_message.
    CLEAR lt_message.

    lo_ui_services->save(
    EXPORTING i_mode     = if_usmd_ui_services=>gc_save_mode_save_only
      io_model   = lo_model
    IMPORTING et_message = lt_message
      ef_error   = lv_error ).

    APPEND LINES OF lt_message TO et_message.
    CLEAR lt_message.

  ENDMETHOD.


  METHOD usmd_crequest_snapshot_refresh.
    TRY.
        cl_usmd_app_context=>init_context(
          EXPORTING
            iv_crequest_id = COND #( WHEN iv_crequest IS INITIAL THEN get_cr_number( ) ELSE iv_crequest ) ).
      CATCH cx_usmd_app_context_cons_error .
    ENDTRY.

    cl_usmd_snapshot_tools=>refresh_snapshot_for_cr(
     EXPORTING
       iv_change_request = COND #( WHEN iv_crequest IS INITIAL THEN get_cr_number( ) ELSE iv_crequest )
     IMPORTING
       et_message        = rt_message
       ev_failed         = DATA(lv_error)
          ).

  ENDMETHOD.


  METHOD execute_conditional_operator.

    rv_result = COND boole_d( WHEN iv_operator = 'AND' THEN execute_and_condition( iv_operand1 = iv_operand1
                                                                                   iv_operand2 = iv_operand2 )
                              WHEN iv_operator = 'OR'  THEN execute_or_condition( iv_operand1 = iv_operand1
                                                                                  iv_operand2 = iv_operand2 )
                              ELSE iv_operand2 ).


  ENDMETHOD.


  METHOD read_entity.

    DATA lts_objlist   TYPE        usmd_t_crequest_entity.
    DATA lo_data_tab   TYPE REF TO data.

    FIELD-SYMBOLS <lt_data> TYPE ANY TABLE.
    CLEAR eo_data_tab.

    cl_usmd_model_ext=>get_instance( EXPORTING i_usmd_model = get_data_model( iv_crequest = iv_crequest )
                                     IMPORTING eo_instance  = DATA(lif_model) ).

    CHECK iv_crequest IS NOT INITIAL.

    DATA(lt_sel) = VALUE usmd_ts_sel( ( fieldname = usmd0_cs_fld-crequest
                        sign      = 'I'
                        option    = 'EQ'
                        low       = iv_crequest ) ).

    CHECK lif_model IS BOUND.

    lif_model->read_char_value(
      EXPORTING i_fieldname       = usmd0_cs_fld-crequest
                it_sel            = lt_sel
                if_use_edtn_slice = abap_false
                if_no_flush       = abap_true
      IMPORTING et_data           = lts_objlist ).

    CHECK lts_objlist IS NOT INITIAL.

    lif_model->create_data_reference(
      EXPORTING i_fieldname = CONV #( iv_entity )
                i_struct    = if_usmd_model=>gc_struct_key_attr
                i_tabtype   = if_usmd_model=>gc_tabtype_standard
      IMPORTING er_data     = lo_data_tab ).

    ASSIGN lo_data_tab->* TO <lt_data>.

    IF <lt_data> IS NOT ASSIGNED.
      RETURN.
    ENDIF.

    DATA(lv_cr_main_entity) = get_cr_main_entity( iv_usmd_crequest_type = get_cr_type( iv_crequest = iv_crequest ) ).

    LOOP AT lts_objlist INTO DATA(ls_objlist).

      CHECK ls_objlist-usmd_entity = lv_cr_main_entity.

      INSERT VALUE #( fieldname = lv_cr_main_entity
                      sign      = 'I'
                      option    = 'EQ'
                      low       = ls_objlist-usmd_value )
       INTO TABLE lt_sel.
    ENDLOOP.

    lif_model->read_char_value(
      EXPORTING i_fieldname       = CONV #( iv_entity )
                it_sel            = lt_sel
                i_readmode        = iv_readmode
                if_use_edtn_slice = abap_false
                if_no_flush       = abap_true
      IMPORTING et_data           = <lt_data> ).

    eo_data_tab = lo_data_tab.

  ENDMETHOD.


  METHOD append_entity_keys_derivation.

    " This method stores the key values of an CR type in a global internal table.
    " gt_entity_key

    DATA : ls_entity_key       TYPE gty_entity_key.

    ASSIGN it_data TO FIELD-SYMBOL(<it_data>).

    IF <it_data> IS ASSIGNED AND <it_data> IS NOT INITIAL.

      LOOP AT <it_data> ASSIGNING FIELD-SYMBOL(<ls_data>).

        get_key_value( EXPORTING iv_crequest          = get_cr_number( )
                                 iv_entity            = iv_entity
                                 is_selected_records  = <ls_data>
                                 iv_key_string        =  abap_true              " Boolean Variable (X = True, - = False, Space = Unknown)
                                 iv_entity_key_string =  abap_true
                       IMPORTING et_entity_key =    DATA(lt_entity_key_data) ).

        LOOP AT lt_entity_key_data INTO DATA(ls_entity_key_data).
          ls_entity_key-entity  =  ls_entity_key_data-entity.
          ASSIGN COMPONENT 'TY_KEY' OF STRUCTURE ls_entity_key_data TO FIELD-SYMBOL(<fs_key>).

          IF <fs_key> IS ASSIGNED AND <fs_key> IS NOT INITIAL.

            IF <fs_key> IS ASSIGNED AND <fs_key> IS NOT INITIAL.
              ASSIGN COMPONENT 'FIELDNAME' OF STRUCTURE <fs_key> TO FIELD-SYMBOL(<fv_fieldname>).
              IF <fv_fieldname> IS ASSIGNED.
                ls_entity_key-field = <fv_fieldname>.
              ENDIF.

              ASSIGN COMPONENT 'VALUE' OF STRUCTURE <fs_key> TO FIELD-SYMBOL(<fv_value>).
              IF <fv_value> IS ASSIGNED.
                ls_entity_key-key_value = <fv_value>.
              ENDIF.
            ENDIF.

            READ TABLE yz_clas_mdg_utility=>gt_entity_key TRANSPORTING NO FIELDS
                                                          WITH KEY entity     = ls_entity_key-entity
                                                                   field      = ls_entity_key-field
                                                                   key_value  = ls_entity_key-key_value.

            IF sy-subrc NE 0. " If the entry is not present we are adding it
              APPEND ls_entity_key TO gt_entity_key.
            ENDIF.
          ENDIF.
        ENDLOOP.

      ENDLOOP.
    ENDIF.

  ENDMETHOD.


  METHOD get_brf_element_id.
    DATA:
      lv_application_id TYPE if_fdt_types=>id,
      lo_brf_factory    TYPE REF TO if_fdt_factory,
      lo_brf_query      TYPE REF TO if_fdt_query,
      lt_selection      TYPE if_fdt_query=>ts_selection,
      ls_selection      LIKE LINE OF lt_selection,
      ls_obj_category   TYPE if_fdt_query=>s_object_category_sel,
      lt_names          TYPE if_fdt_query=>ts_name,
      ls_names          TYPE if_fdt_query=>s_name.

    DATA: ls_context       TYPE usmd_s_fdt_context_value.
    FIELD-SYMBOLS: <value> TYPE any.

*--------------------------------------------------------------------*

    CHECK iv_cr_number IS NOT INITIAL.
    CHECK iv_name    IS NOT INITIAL.


* get the ID of the brf+ application depending on the CR type
    lv_application_id = cl_usmd_wf_ssw_rule_service=>get_cr_type_app_id(  get_cr_type( iv_crequest = iv_cr_number ) ).
    IF lv_application_id IS INITIAL.
      MESSAGE x000(usmd1).   "no brf+ application exists for this cr type
    ENDIF.

    lo_brf_factory = cl_fdt_factory=>if_fdt_factory~get_instance( ).

* create a query object instance ...
    lo_brf_query = lo_brf_factory->get_query(
      iv_object_type      = if_fdt_constants=>gc_object_type_data_object
      iv_data_object_type = if_fdt_constants=>gc_data_object_type_element ).

* ... and define the selection criteria
    ls_selection-queryfield = if_fdt_admin_data_query=>gc_fn_name.
    ls_selection-sign       = 'I'.
    ls_selection-option     = 'EQ'.
    ls_selection-low        = iv_name.
    INSERT ls_selection INTO TABLE lt_selection.

    ls_selection-queryfield = if_fdt_admin_data_query=>gc_fn_application_id.
    ls_selection-sign       = 'I'.
    ls_selection-option     = 'EQ'.
    ls_selection-low        = lv_application_id.
    INSERT ls_selection INTO TABLE lt_selection.

    ls_obj_category-system_objects      = abap_true.
    ls_obj_category-customizing_objects = abap_true.
    ls_obj_category-masterdata_objects  = abap_false.

* select the data
    lo_brf_query->select_data(
      EXPORTING
        its_selection          = lt_selection
        is_object_category_sel = ls_obj_category
      IMPORTING
        eta_data               = lt_names ).

    READ TABLE lt_names INTO ls_names INDEX 1.
    ls_context-id = ls_names-id.


    CREATE DATA ls_context-value TYPE boole_d.
    ASSIGN  ls_context-value->* TO <value>.
    <value> = iv_framework_result.
    APPEND ls_context TO et_rule_context_value.

  ENDMETHOD.


  METHOD get_dynamic_select_clause.

    rt_select_clause = REDUCE #( INIT text = ` ` FOR <ls_fields> IN it_entity_attr
                                 NEXT text = text && <ls_fields>-tabname && '~' && <ls_fields>-fieldname && ',' ).

    REPLACE REGEX ',$' IN rt_select_clause WITH ' '.
  ENDMETHOD.


  METHOD get_dynamic_where_clause.

    rt_where_clause = REDUCE #( INIT text = ` ` FOR <ls_fields> IN it_entity_attr
                                NEXT text = text && | | && 'UPPER(' && | | && <ls_fields>-tabname && '~' && <ls_fields>-fieldname && ' )'
                                     && | | && '=' && | | && |'{ <ls_fields>-attr_value }'| && | | && 'AND' ).
*
    REPLACE REGEX 'AND$' IN rt_where_clause WITH ' '.
  ENDMETHOD.


  METHOD get_dynamic_table_str.

    IF it_entity_attr IS NOT INITIAL.

      SELECT tabname,fieldname,rollname,datatype FROM dd03l
        FOR ALL ENTRIES IN @it_entity_attr
        WHERE tabname = @it_entity_attr-tabname
        INTO TABLE @DATA(lt_dd03l).
    ENDIF.

    DATA(lt_comp) = VALUE abap_component_tab( FOR ls_entity_attr IN it_entity_attr
                       FOR ls_dd03l IN lt_dd03l WHERE ( tabname = ls_entity_attr-tabname AND fieldname = ls_entity_attr-fieldname )
                      (  name = |{ ls_entity_attr-fieldname }|
                         type = COND  #( WHEN  ls_dd03l-rollname IS NOT INITIAL THEN  CAST cl_abap_datadescr( cl_abap_datadescr=>describe_by_name( |{ ls_dd03l-rollname }|  ) )
                                           ELSE CAST cl_abap_datadescr( cl_abap_datadescr=>describe_by_name( |{ ls_dd03l-datatype }|  ) )  ) ) ) .

    IF lt_comp IS NOT INITIAL.
      TRY .
          DATA(lo_structtype) = CAST cl_abap_structdescr( cl_abap_structdescr=>create( lt_comp ) ).
        CATCH cx_sy_struct_creation INTO DATA(lo_str_creation).
          DATA(lv_str_error) = lo_str_creation->get_text( ).
      ENDTRY.
      CHECK lv_str_error IS INITIAL.
      TRY.
          DATA(lo_tabletype) = cl_abap_tabledescr=>create( p_line_type   = lo_structtype
                                                           p_table_kind  = cl_abap_tabledescr=>tablekind_std ).
        CATCH cx_sy_table_creation INTO DATA(lo_table_ceration).
          DATA(lv_table_error) = lo_table_ceration->get_text( ).
      ENDTRY.
      CHECK lv_table_error IS  INITIAL.
      CREATE DATA eo_dataref TYPE HANDLE lo_tabletype.

    ENDIF.
  ENDMETHOD.


  METHOD get_brf_element.
    DATA:
      lv_application_id TYPE if_fdt_types=>id,
      lo_brf_factory    TYPE REF TO if_fdt_factory,
      lo_brf_query      TYPE REF TO if_fdt_query,
      lt_selection      TYPE if_fdt_query=>ts_selection,
      ls_selection      LIKE LINE OF lt_selection,
      ls_obj_category   TYPE if_fdt_query=>s_object_category_sel,
      lt_names          TYPE if_fdt_query=>ts_name,
      ls_names          TYPE if_fdt_query=>s_name.

    DATA: ls_context       TYPE usmd_s_fdt_context_value.
    FIELD-SYMBOLS: <value> TYPE any.

*--------------------------------------------------------------------*

    CHECK iv_cr_number IS NOT INITIAL.
    CHECK iv_name    IS NOT INITIAL.


* get the ID of the brf+ application depending on the CR type
    lv_application_id = cl_usmd_wf_ssw_rule_service=>get_cr_type_app_id(  get_cr_type( iv_crequest = iv_cr_number ) ).
    IF lv_application_id IS INITIAL.
      MESSAGE x000(usmd1).   "no brf+ application exists for this cr type
    ENDIF.

    lo_brf_factory = cl_fdt_factory=>if_fdt_factory~get_instance( ).

* create a query object instance ...
    lo_brf_query = lo_brf_factory->get_query(
      iv_object_type      = if_fdt_constants=>gc_object_type_data_object
      iv_data_object_type = if_fdt_constants=>gc_data_object_type_element ).

* ... and define the selection criteria
    ls_selection-queryfield = if_fdt_admin_data_query=>gc_fn_name.
    ls_selection-sign       = 'I'.
    ls_selection-option     = 'EQ'.
    ls_selection-low        = iv_name.
    INSERT ls_selection INTO TABLE lt_selection.

    ls_selection-queryfield = if_fdt_admin_data_query=>gc_fn_application_id.
    ls_selection-sign       = 'I'.
    ls_selection-option     = 'EQ'.
    ls_selection-low        = lv_application_id.
    INSERT ls_selection INTO TABLE lt_selection.

    ls_obj_category-system_objects      = abap_true.
    ls_obj_category-customizing_objects = abap_true.
    ls_obj_category-masterdata_objects  = abap_false.

* select the data
    lo_brf_query->select_data(
      EXPORTING
        its_selection          = lt_selection
        is_object_category_sel = ls_obj_category
      IMPORTING
        eta_data               = lt_names ).
    TRY .
        rv_fdt_uuid = lt_names[ 1 ]-id.
      CATCH cx_sy_itab_line_not_found.

    ENDTRY.

  ENDMETHOD.


  METHOD get_cr_details.
    SELECT SINGLE * FROM usmd120c INTO @rv_crequest WHERE usmd_crequest = @iv_cr_number.
  ENDMETHOD.


  METHOD get_current_event.

    IF cl_fpm_factory=>get_instance( ) IS BOUND.
      cl_fpm_factory=>get_instance( )->read_event_queue( IMPORTING et_event_queue = DATA(lt_event_queue)  ).
      rv_current_event_id = VALUE #( lt_event_queue[ 1 ]-id OPTIONAL ).
    ENDIF.

  ENDMETHOD.


  METHOD activate_cr_with_selection.

    DATA:lv_crequest_sta TYPE usmd_crequest_status,
         lv_creq_type    TYPE usmd_crequest_type,
         ls_message      TYPE usmd_s_message.

    SELECT SINGLE cccategory FROM t000
  INTO @DATA(lv_role) WHERE mandt = @sy-mandt.
    IF lv_role NE 'P'.


      GET TIME STAMP FIELD DATA(lv_current_time).
      IF iv_usmd_crequest IS NOT INITIAL OR iv_days IS NOT INITIAL.
        SELECT
         FROM            usmd120c  AS cr_master
         LEFT OUTER JOIN usmd2400  AS cr_request ON cr_request~usmd_crequest = cr_master~usmd_crequest
         LEFT OUTER JOIN swwwihead AS cr_workitem   ON cr_request~top_wi_id = cr_workitem~top_wi_id AND cr_workitem~wi_stat = 'READY'
         FIELDS
               cr_master~usmd_crequest,
               cr_master~usmd_creq_status,
               cr_master~usmd_creq_type,
               cr_request~top_wi_id       AS top_wi_id,
               cr_workitem~wi_id          AS wi_id
         WHERE cr_master~usmd_crequest EQ @iv_usmd_crequest
           AND usmd_created_at < @( cl_abap_tstmp=>subtractsecs( tstmp = lv_current_time secs  = ( iv_days * 24 * 60 * 60  ) ) )
          INTO TABLE @DATA(lt_data).

        LOOP AT lt_data INTO DATA(ls_data).
*Get Model
          DATA(lv_model) = cl_usmd_crequest_api=>get_model_from_crtype( iv_creq_type = ls_data-usmd_creq_type ).

*Check whether Its Locked or not
          cl_usmd_model=>get_instance(
             EXPORTING
               i_usmd_model = lv_model
             IMPORTING
               eo_instance  = DATA(do_model)
               et_message   = DATA(lt_message) ).

*If Model is Bound
          IF do_model IS BOUND.
            do_model->enqueue(
              EXPORTING
                i_fieldname  = usmd0_cs_fld-crequest
                if_hry       = space
                it_value     = VALUE #( ( fieldname = usmd0_cs_fld-crequest value = ls_data-usmd_crequest  ) )
              IMPORTING
                et_message   = lt_message ).

            IF line_exists( lt_message[ msgty = 'E' ] ).
              ls_message-msgid = 'YZMSG_MDG_ACC'.
              ls_message-msgno = '014'.
              ls_message-msgty = 'E'.
              ls_message-msgv1 = ls_data-usmd_crequest.
              APPEND ls_message TO et_message.
              CLEAR ls_message.
              CONTINUE."Go For Next CR Processing
            ELSE.
              do_model->dequeue(
                EXPORTING
              i_fieldname  = usmd0_cs_fld-crequest
              if_hry       = space
              it_value     = VALUE #( ( fieldname = usmd0_cs_fld-crequest value = ls_data-usmd_crequest  ) )
              ).
            ENDIF.
          ENDIF.

          IF ls_data-usmd_crequest EQ '02'.
            ls_message-msgid = 'YZMSG_MDG_ACC'.
            ls_message-msgno = '022'.
            ls_message-msgty = 'E'.
            ls_message-msgv1 = ls_data-usmd_crequest.
            APPEND ls_message TO et_message.
            CLEAR ls_message.
          ELSE.
            IF do_model IS BOUND.
              CLEAR lt_message.
              do_model->crequest_activate(
                EXPORTING
                  i_crequest               =  iv_usmd_crequest                " Change Request
                IMPORTING
                    et_message             =  lt_message                          " Messages
              ).
              IF line_exists( lt_message[ msgty = 'E' ] ).
                ls_message-msgid = 'YZMSG_MDG_ACC'.
                ls_message-msgno = '023'.
                ls_message-msgty = 'E'.
                ls_message-msgv1 = ls_data-usmd_crequest.
                APPEND ls_message TO et_message.
                CLEAR ls_message.
              ELSE.
                ls_message-msgid = 'YZMSG_MDG_ACC'.
                ls_message-msgno = '024'.
                ls_message-msgty = 'S'.
                ls_message-msgv1 = ls_data-usmd_crequest.
                APPEND ls_message TO et_message.
                CLEAR ls_message.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDLOOP.

      ELSE.
        ls_message-msgno = '013'.
        ls_message-msgid = 'YZMSG_MDG_ACC'.
        ls_message-msgty = 'E'.
        APPEND ls_message TO et_message.
        CLEAR ls_message.
      ENDIF.

    ELSE.
      ls_message-msgno = '025'.
      ls_message-msgid = 'YZMSG_MDG_ACC'.
      ls_message-msgty = 'E'.
      APPEND ls_message TO et_message.
      CLEAR ls_message.
    ENDIF.

  ENDMETHOD.


  METHOD add_to_global_message.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          : 06-01-2022
* Change No     : 8200004936
* WRICEF-ID     :
* Defect-ID     :
* Transport     : DDMK902368
* Developer ID  : ( EXT_BHAYANIR ) Rahul Bhayani
* Release ID    : 01
**************************************************************************************

    rv_event_result = COND fpm_event_result( WHEN ( line_exists( it_message[ msgty = if_xo_const_message~abort ] )
                                               OR   line_exists( it_message[ msgty = if_xo_const_message~exit  ] )
                                               OR   line_exists( it_message[ msgty = if_xo_const_message~error ] ) ) THEN if_fpm_constants=>gc_event_result-failed
                                                                                                                     ELSE if_fpm_constants=>gc_event_result-ok ).


    DATA(lo_fpm) = COND #( WHEN io_fpm IS BOUND THEN io_fpm ELSE cl_fpm_factory=>get_instance( ) ).

    IF lo_fpm IS NOT BOUND.
      DATA(lo_bol_core) = cl_crm_bol_core=>get_instance( ).
      CHECK lo_bol_core IS BOUND.

      lo_bol_core->get_global_message_cont( ).
      DATA(lo_message_container) =  cl_crm_bol_core=>get_instance( )->get_global_message_cont( ).
    ENDIF.

    LOOP AT it_message INTO DATA(ls_mesg).

      IF lo_fpm IS BOUND.
        lo_fpm->mo_message_manager->report_t100_message(
          EXPORTING
            iv_msgid                     = ls_mesg-msgid                             " Message indentification (Class)
            iv_msgno                     = ls_mesg-msgno                             " Message number
            iv_severity                  = COND #( WHEN ls_mesg-msgty = 'E' THEN if_fpm_message_manager=>gc_severity_error
                                                                            ELSE if_fpm_message_manager=>gc_severity_warning )" Report the severity of the message
            iv_parameter_1               = ls_mesg-msgv1                             " 1st parameter
            iv_parameter_2               = ls_mesg-msgv2                             " 2nd parameter
            iv_parameter_3               = ls_mesg-msgv3                             " 3rd parameter
            iv_parameter_4               = ls_mesg-msgv4                             " 4th Parameter
        ).

      ELSE.
        IF lo_message_container IS BOUND.
          lo_message_container->add_message(
                  iv_msg_type       = ls_mesg-msgty
                  iv_msg_id         = ls_mesg-msgid
                  iv_msg_number     = ls_mesg-msgno
                  iv_msg_v1         = ls_mesg-msgv1
                  iv_msg_v2         = ls_mesg-msgv2
                  iv_msg_v3         = ls_mesg-msgv3
                  iv_msg_v4         = ls_mesg-msgv4
                  iv_show_only_once = abap_true ).
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.


  METHOD copy_cr_from_systems.

    CALL FUNCTION 'YZ_FUNC_COPY_CHANGE_REQUEST'
      DESTINATION iv_rfcdest
      EXPORTING
        iv_crequest = iv_crequest
        iv_rfcdest  = iv_rfcdest
        iv_crtype   = yz_clas_mdg_utility=>get_cr_type( iv_crequest )
      IMPORTING
        ev_crequest = rv_crequest
        et_message  = et_message.

  ENDMETHOD.


  METHOD copy_decision_table.


    DATA : o_decision_table TYPE REF TO cl_fdt_decision_table.
    TRY.
        o_decision_table = get_decision_tab_object( iv_name  ).
        o_decision_table->if_fdt_transaction~enqueue( ).
        o_decision_table->if_fdt_decision_table~set_table_data( EXPORTING its_data = it_decision_tab ).
        o_decision_table->if_fdt_transaction~activate(
            EXPORTING iv_deep              = abap_true
            IMPORTING et_message           = DATA(messages)
            ev_activation_failed = DATA(lv_actv_failed) ).
        IF lv_actv_failed = abap_true.
*          MESSAGE e000(zmdg) WITH 'Error updating' iv_name INTO zcl_messages=>sv_message_text.
*          RAISE EXCEPTION TYPE zcx_mdg
*            EXPORTING
*              mo_messages = NEW zcl_messages( )->set_system_message( ).
        ENDIF.

        o_decision_table->if_fdt_transaction~save( ).
        o_decision_table->if_fdt_transaction~dequeue( ).
      CATCH cx_fdt.
*        MESSAGE e000(zmdg) WITH 'Error updating' iv_name INTO zcl_messages=>sv_message_text.
*        RAISE EXCEPTION TYPE zcx_mdg
*          EXPORTING
*            mo_messages = NEW zcl_messages( )->set_system_message( ).
    ENDTRY.
  ENDMETHOD.


  METHOD copy_to.

    copy_decision_table( iv_name = |DT_USER_AGT_GRP_{ iv_crtype }|
                         it_decision_tab =  mt_user_agent ).

    copy_decision_table( iv_name = |DT_NON_USER_AGT_GRP_{ iv_crtype }|
                         it_decision_tab =  mt_non_user_agent ).

    copy_decision_table( iv_name = |DT_SINGLE_VAL_{ iv_crtype }|
                         it_decision_tab =  mt_single_value ).

  ENDMETHOD.


  METHOD delete_cr_with_selection.
    DATA:lv_crequest_sta TYPE usmd_crequest_status,
         lv_creq_type    TYPE usmd_crequest_type,
         ls_message      TYPE usmd_s_message.
    DATA : lr_crequest TYPE RANGE OF usmd_crequest.
    GET TIME STAMP FIELD DATA(lv_current_time).
    IF iv_usmd_crequest IS NOT INITIAL OR iv_days IS NOT INITIAL.
      SELECT
       FROM            usmd120c  AS cr_master
       LEFT OUTER JOIN usmd2400  AS cr_request ON cr_request~usmd_crequest = cr_master~usmd_crequest
       LEFT OUTER JOIN swwwihead AS cr_workitem   ON cr_request~top_wi_id = cr_workitem~top_wi_id AND cr_workitem~wi_stat = 'READY'
       FIELDS
             cr_master~usmd_crequest,
             cr_master~usmd_creq_status,
             cr_master~usmd_creq_type,
             cr_request~top_wi_id       AS top_wi_id,
             cr_workitem~wi_id          AS wi_id
       WHERE cr_master~usmd_crequest EQ @iv_usmd_crequest
         AND usmd_created_at < @( cl_abap_tstmp=>subtractsecs( tstmp = lv_current_time secs  = ( iv_days * 24 * 60 * 60  ) ) )
        INTO TABLE @DATA(lt_data).

      LOOP AT lt_data INTO DATA(ls_data).

*Get Model
        DATA(lv_model) = cl_usmd_crequest_api=>get_model_from_crtype( iv_creq_type = ls_data-usmd_creq_type ).

*Check whether Its Locked or not
        cl_usmd_model=>get_instance(
           EXPORTING
             i_usmd_model = lv_model
           IMPORTING
             eo_instance  = DATA(do_model)
             et_message   = DATA(lt_message) ).

*If Model is Bound
        IF do_model IS BOUND.
          do_model->enqueue(
            EXPORTING
              i_fieldname  = usmd0_cs_fld-crequest
              if_hry       = space
              it_value     = VALUE #( ( fieldname = usmd0_cs_fld-crequest value = ls_data-usmd_crequest  ) )
            IMPORTING
              et_message   = lt_message ).

          IF line_exists( lt_message[ msgty = 'E' ] ).
            ls_message-msgid = 'YZMSG_MDG_ACC'.
            ls_message-msgno = '014'.
            ls_message-msgty = 'E'.
            ls_message-msgv1 = ls_data-usmd_crequest.
            APPEND ls_message TO et_message.
            CLEAR ls_message.
            CONTINUE."Go For Next CR Processing
          ELSE.
            do_model->dequeue(
              EXPORTING
            i_fieldname  = usmd0_cs_fld-crequest
            if_hry       = space
            it_value     = VALUE #( ( fieldname = usmd0_cs_fld-crequest value = ls_data-usmd_crequest  ) )
            ).
          ENDIF.
        ENDIF.
        lr_crequest = VALUE #( ( sign = 'I' option = 'EQ' low = ls_data-usmd_crequest ) ).
*        SUBMIT usmd_delete_crequest WITH model = lv_model WITH crequest-low = ls_data-usmd_crequest AND RETURN.
        SUBMIT usmd_delete_crequest WITH model = lv_model WITH crequest IN lr_crequest AND RETURN.
        IF sy-subrc = 0.
          SELECT COUNT(*) FROM usmd120c WHERE usmd_crequest = ls_data-usmd_crequest.
          IF sy-subrc <> 0.
            ls_message-msgid = 'YZMSG_MDG_ACC'.
            ls_message-msgno = '028'.
            ls_message-msgty = 'S'.
            ls_message-msgv1 = ls_data-usmd_crequest.
            APPEND ls_message TO et_message.
            CLEAR ls_message.
          ELSE.
            ls_message-msgid = 'YZMSG_MDG_ACC'.
            ls_message-msgno = '029'.
            ls_message-msgty = 'E'.
            ls_message-msgv1 = ls_data-usmd_crequest.
            APPEND ls_message TO et_message.
            CLEAR ls_message.
          ENDIF.
        ELSE.
          ls_message-msgid = 'YZMSG_MDG_ACC'.
          ls_message-msgno = '029'.
          ls_message-msgty = 'E'.
          ls_message-msgv1 = ls_data-usmd_crequest.
          APPEND ls_message TO et_message.
          CLEAR ls_message.
        ENDIF.
      ENDLOOP.
    ELSE.
      ls_message-msgno = '013'.
      ls_message-msgid = 'YZMSG_MDG_ACC'.
      ls_message-msgty = 'E'.
      APPEND ls_message TO et_message.
      CLEAR ls_message.
    ENDIF.
  ENDMETHOD.


  METHOD execute_badi_control_call.

    DATA lo_badi TYPE REF TO yz_mdg_badi_control.

    DATA(lv_data_model) = get_data_model( ).
    DATA(lv_cr_type)    = get_cr_type( ).

    TRY.
        GET BADI lo_badi
          FILTERS
            data_model       = lv_data_model
            entity           = '' "id_entitytype
            custom_badi_call = 'X'
            process          = 'MDG_CR'
            crtype           = lv_cr_type
            crstep           = ''
            edition          = ''. "id_edition.

      CATCH cx_badi_not_implemented.
        CLEAR lo_badi.
        RETURN.

    ENDTRY.

    CASE iv_method_name.
      WHEN 'CHECK_ENTITY'.
        CALL BADI lo_badi->if_ex_usmd_rule_service~check_entity
          EXPORTING
            id_edition      = id_edition
            id_crequest     = id_crequest
            id_entitytype   = id_entitytype
            io_model        = io_model
            if_online_check = if_online_check
            it_data         = it_data
          IMPORTING
            et_message      = et_message.

        rv_badi_executed = abap_true.

      WHEN 'DERIVE_ENTITY'.
        CALL BADI lo_badi->if_ex_usmd_rule_service~derive_entity
          EXPORTING
            io_model      = io_model                  " MDM Data Model for Access from Non-SAP Standard
            id_edition    = id_edition                 " Edition
            id_entitytype = id_entitytype                  " Entity Type
          IMPORTING
            et_message    = et_message                 " Messages
          CHANGING
            ct_data       = ct_data.                 " Master Data

        rv_badi_executed = abap_true.

      WHEN 'DERIVE'.
        CALL BADI lo_badi->if_ex_usmd_rule_service2~derive
          EXPORTING
            io_model        = io_model
            io_changed_data = io_changed_data
            io_write_data   = io_write_data
          IMPORTING
            et_message_info = et_message_info.

        rv_badi_executed = abap_true.

      WHEN OTHERS.

    ENDCASE.
  ENDMETHOD.


  METHOD forward_cr_with_selection.
    DATA:lv_creuest_stat TYPE usmd_crequest_status,
         lv_days         TYPE c LENGTH 3,
         ls_message      TYPE usmd_s_message.
    DATA:
      lv_return     TYPE sy-subrc,
      lv_swr_wistat TYPE swr_wistat,
      lt_swr_messag TYPE TABLE OF swr_messag,
      lt_swr_mstruc TYPE TABLE OF swr_mstruc,
      lt_swragent   TYPE TABLE OF swragent,
      lv_msg        TYPE string.

    GET TIME STAMP FIELD DATA(lv_current_time).
    IF iv_usmd_crequest IS NOT INITIAL OR iv_days IS NOT INITIAL.
      SELECT
       FROM            usmd120c  AS cr_master
       LEFT OUTER JOIN usmd2400  AS cr_request ON cr_request~usmd_crequest = cr_master~usmd_crequest
       LEFT OUTER JOIN swwwihead AS cr_workitem   ON cr_request~top_wi_id = cr_workitem~top_wi_id AND cr_workitem~wi_stat = 'READY'
       FIELDS
             cr_master~usmd_crequest,
             cr_master~usmd_creq_status,
             cr_master~usmd_creq_type,
             cr_request~top_wi_id       AS top_wi_id,
             cr_workitem~wi_id          AS wi_id
       WHERE cr_master~usmd_crequest EQ @iv_usmd_crequest
         AND usmd_created_at < @( cl_abap_tstmp=>subtractsecs( tstmp = lv_current_time secs  = ( iv_days * 24 * 60 * 60  ) ) )
        INTO TABLE @DATA(lt_data).

      LOOP AT lt_data INTO DATA(ls_data).
*Clear Local Loop Attributes
        CLEAR: lv_return, lv_swr_wistat, lt_swr_messag, lt_swr_mstruc, lt_swragent.

*Get Model
        DATA(lv_model) = cl_usmd_crequest_api=>get_model_from_crtype( iv_creq_type = ls_data-usmd_creq_type ).

*Check whether Its Locked or not
        cl_usmd_model=>get_instance(
           EXPORTING
             i_usmd_model = lv_model
           IMPORTING
             eo_instance  = DATA(do_model)
             et_message   = DATA(lt_message) ).

*If Model is Bound
        IF do_model IS BOUND.
          do_model->enqueue(
            EXPORTING
              i_fieldname  = usmd0_cs_fld-crequest
              if_hry       = space
              it_value     = VALUE #( ( fieldname = usmd0_cs_fld-crequest value = ls_data-usmd_crequest  ) )
            IMPORTING
              et_message   = lt_message ).

          IF line_exists( lt_message[ msgty = 'E' ] ).
            ls_message-msgid = 'YZMSG_MDG_ACC'.
            ls_message-msgno = '014'.
            ls_message-msgty = 'E'.
            ls_message-msgv1 = ls_data-usmd_crequest.
            APPEND ls_message TO et_message.
            CLEAR ls_message.
            CONTINUE."Go For Next CR Processing
          ELSE.
            do_model->dequeue(
              EXPORTING
            i_fieldname  = usmd0_cs_fld-crequest
            if_hry       = space
            it_value     = VALUE #( ( fieldname = usmd0_cs_fld-crequest value = ls_data-usmd_crequest  ) )
            ).
          ENDIF.
        ENDIF.
        IF ls_data-usmd_creq_status EQ '2'.
          ls_message-msgid = 'YZMSG_MDG_ACC'.
          ls_message-msgno = '015'.
          ls_message-msgty = 'E'.
          ls_message-msgv1 = ls_data-usmd_crequest.
          APPEND ls_message TO et_message.
          CLEAR ls_message.
        ELSE.
          CALL FUNCTION 'SAP_WAPI_FORWARD_WORKITEM'
            EXPORTING
              workitem_id             = ls_data-wi_id
              user_id                 = iv_user
              language                = 'E'
              do_commit               = 'X'
              current_user            = sy-uname
              check_inbox_restriction = ' '
            IMPORTING
              return_code             = lv_return
              new_status              = lv_swr_wistat
            TABLES
              message_lines           = lt_swr_messag
              message_struct          = lt_swr_mstruc
              user_ids                = lt_swragent.

          IF lv_return = 0.
            ls_message-msgid = 'YZMSG_MDG_ACC'.
            ls_message-msgno = '016'.
            ls_message-msgty = 'E'.
            ls_message-msgv1 = ls_data-usmd_crequest.
            APPEND ls_message TO et_message.
            CLEAR ls_message.
          ELSE.
            ls_message-msgid = 'YZMSG_MDG_ACC'.
            ls_message-msgno = '017'.
            ls_message-msgty = 'E'.
            ls_message-msgv1 = ls_data-usmd_crequest.
            APPEND ls_message TO et_message.
            CLEAR ls_message.
          ENDIF.
        ENDIF.
      ENDLOOP.
    ELSE.
      ls_message-msgno = '013'.
      ls_message-msgid = 'YZMSG_MDG_ACC'.
      ls_message-msgty = 'E'.
      APPEND ls_message TO et_message.
      CLEAR ls_message.
    ENDIF.
  ENDMETHOD.


  METHOD get_decision_tab_data.
    DATA : o_decision_table TYPE REF TO cl_fdt_decision_table.
    mo_brf_query->get_ids(
      EXPORTING
        iv_name   = CONV #( iv_name )
        iv_object_type = if_fdt_constants=>gc_object_type_expression
      IMPORTING
        ets_object_id = DATA(app_ids) ).
    o_decision_table ?= mo_brf_factory->get_expression( app_ids[ 1 ] ) .
    o_decision_table->if_fdt_decision_table~get_table_data( IMPORTING ets_data = rt_decision_tab ).
  ENDMETHOD.


  METHOD get_decision_tab_object.
    mo_brf_query->get_ids(
      EXPORTING
        iv_name   = CONV #( iv_name )
        iv_object_type = if_fdt_constants=>gc_object_type_expression
      IMPORTING
        ets_object_id = DATA(app_ids) ).
    ro_object ?= mo_brf_factory->get_expression( app_ids[ 1 ] ) .
  ENDMETHOD.


  METHOD get_derive_write_references.
*! This method creates the needed data references for the
*  structure and table to be written in derivation.

    CLEAR: er_s_write, er_t_write.
    IF io_model IS NOT BOUND
      OR iv_fieldname IS INITIAL.
      RETURN.
    ENDIF.

    "get the table reference
    io_model->create_data_reference(
      EXPORTING
        i_fieldname          = iv_fieldname
        i_struct             = io_model->gc_struct_key_attr
        if_incl_edition_fld  = if_incl_edition_fld
        if_table             = abap_true
      IMPORTING
        er_data              = er_t_write
        et_message           = DATA(lt_message) ).
    IF er_t_write IS NOT BOUND.
      RETURN.
    ENDIF.

    "get the structure reference
    io_model->create_data_reference(
      EXPORTING
        i_fieldname          = iv_fieldname
        i_struct             = io_model->gc_struct_key_attr
        if_incl_edition_fld  = if_incl_edition_fld
        if_table             = abap_false
      IMPORTING
        er_data              = er_s_write
        et_message           = lt_message ).

    IF er_s_write IS NOT BOUND.
      RETURN.
    ENDIF.
  ENDMETHOD.


  METHOD get_job_for_user.

    DATA : lt_jobs   TYPE p1001tab.
    DATA : lt_objtab TYPE hrobject_t.
    DATA : lv_otype  TYPE otype.
    DATA : lv_objid  TYPE objektid.

    DATA(lt_positions) = get_position_for_user( iv_user  ).

    LOOP AT lt_positions INTO DATA(ls_position).

      lv_otype = 'S'.
      lv_objid = ls_position-sobid.
      lt_objtab = VALUE #( ( plvar = '01' otype = lv_otype objid = lv_objid ) ).

      CALL FUNCTION 'HR_GET_JOB_FOR_POSITION'
        EXPORTING
          objecttab         = lt_objtab
          begda             = sy-datum
          endda             = sy-datum
          istat             = '1'
          svect             = '1'
        IMPORTING
          relation_data_tab = lt_jobs
        EXCEPTIONS
          read_1001_error   = 1
          OTHERS            = 2.

      IF sy-subrc = 0.
        rt_data = VALUE #( BASE rt_data FOR ls_jobs IN lt_jobs ( ls_jobs ) ).
        CLEAR : lt_jobs,lt_objtab,ls_position.
      ELSE.
*        Raise Exception
      ENDIF.

    ENDLOOP.

  ENDMETHOD.


  METHOD get_pernr_from_userid.

    CALL FUNCTION 'HR_GETEMPLOYEEDATA_FROMUSER'
      EXPORTING
        username                  = iv_userid
        validbegin                = sy-datum
      IMPORTING
        employeenumber            = rv_pernr
      EXCEPTIONS
        user_not_found            = 1
        countrygrouping_not_found = 2
        infty_not_found           = 3
        OTHERS                    = 4.

  ENDMETHOD.


  METHOD get_position_for_user.

    DATA : lt_objtab TYPE hrobject_t.
    DATA : lv_otype  TYPE otype.
    DATA : lv_objid  TYPE objektid.

    DATA(lv_pernr) = get_pernr_from_userid( iv_user ).

    lv_otype  = 'P'.
    lv_objid  = lv_pernr.
    lt_objtab = VALUE #( ( plvar = '01' otype = lv_otype objid = lv_objid ) ).

    CALL FUNCTION 'HR_GET_POSITIONS_FOR_EMPLOYEE'
      EXPORTING
        objecttab         = lt_objtab
        begda             = sy-datum
        endda             = sy-datum
        istat             = '1'
        svect             = '1'
      IMPORTING
        relation_data_tab = rt_data
      EXCEPTIONS
        read_1001_error   = 1
        OTHERS            = 2.

  ENDMETHOD.


  METHOD  get_reference_decision_tab.
    DATA : o_ref_decision_table TYPE REF TO cl_fdt_decision_table.
    mt_user_agent     = get_decision_tab_data( |DT_USER_AGT_GRP_{ iv_crtype }| ).
    mt_non_user_agent = get_decision_tab_data( |DT_NON_USER_AGT_GRP_{ iv_crtype }| ).
    mt_single_value   = get_decision_tab_data( |DT_SINGLE_VAL_{ iv_crtype }| ).
  ENDMETHOD.


  METHOD get_roles_for_user.

    SELECT agr_name,
           uname
      FROM agr_users
     WHERE uname EQ @iv_user
       AND from_dat LE @sy-datum
       AND to_dat   GT @sy-datum
      INTO TABLE @DATA(lt_data) BYPASSING BUFFER .

    DATA(lv_pernr) = get_pernr_from_userid( iv_user ).

    rt_data = VALUE #( FOR ls_data IN lt_data  ( uname = ls_data-uname agr_name = ls_data-agr_name pernr = lv_pernr ) ).

  ENDMETHOD.


  METHOD get_user_addr_detail.

    CALL FUNCTION 'SUSR_SHOW_USER_DETAILS'
      EXPORTING
        bname      = iv_user
        mandt      = sy-mandt
        no_display = 'X'
      IMPORTING
        addr_usr   = es_addr_usr.

  ENDMETHOD.


  METHOD is_user_belong_to_department.

    DATA : lv_addr_usr TYPE v_addr_usr.

    CALL FUNCTION 'SUSR_SHOW_USER_DETAILS'
      EXPORTING
        bname      = sy-uname
        mandt      = sy-mandt
        no_display = 'X'
      IMPORTING
        addr_usr   = lv_addr_usr.

    DATA(lv_department) = lv_addr_usr-department.
    TRANSLATE lv_department TO UPPER CASE.
    IF line_exists( it_department[ table_line = lv_department ] ).
      rv_return = abap_true.
    ENDIF.

  ENDMETHOD.


  METHOD is_user_belong_to_function.

    DATA : lv_addr_usr TYPE v_addr_usr.

    CALL FUNCTION 'SUSR_SHOW_USER_DETAILS'
      EXPORTING
        bname      = sy-uname
        mandt      = sy-mandt
        no_display = 'X'
      IMPORTING
        addr_usr   = lv_addr_usr.

    DATA(lv_function) = lv_addr_usr-function.
    TRANSLATE lv_function TO UPPER CASE.
    IF line_exists( it_function[ table_line = lv_function ] ).
      rv_return = abap_true.
    ENDIF.

  ENDMETHOD.


  METHOD is_user_belong_to_job_s.


    DATA : lt_objecttab TYPE hrobject_t.
    DATA : lt_data_tab TYPE p1001tab.
    DATA : lv_position_id TYPE hrobjid.
    DATA : lt_objid_s TYPE piq_hrobjid_t.

*lt_objecttab = VALUE #( ( plvar = '01' otype = 'C' objid = iv_jobid ) ).

    lt_objecttab = VALUE #( FOR ls_jobid IN it_jobid ( plvar = '01' otype = 'C' objid = ls_jobid ) ).

    CALL FUNCTION 'HR_GET_POSITIONS_ON_JOB'
      EXPORTING
        objecttab         = lt_objecttab
        begda             = sy-datum
        endda             = sy-datum
        istat             = '1'
        svect             = '1'
      IMPORTING
        relation_data_tab = lt_data_tab
      EXCEPTIONS
        read_1001_error   = 1
        OTHERS            = 2.

*LOOP AT lt_data_tab INTO DATA(ls_data) WHERE sclas = 'S' .
*  lv_position_id = ls_data-sobid.
    lt_objid_s = VALUE #( FOR ls_data IN lt_data_tab ( CONV #( ls_data-sobid ) ) ).
    rv_return = is_user_belong_to_position( it_position_id = lt_objid_s ).
  ENDMETHOD.


  METHOD is_user_belong_to_org.

    DATA : lv_otyp    TYPE otype.
    DATA : lt_objects TYPE STANDARD TABLE OF objec WITH NON-UNIQUE KEY primary_key COMPONENTS plvar otype.
    DATA : lt_objid_s TYPE piq_hrobjid_t.
    DATA : lv_objid_s TYPE hrobjid.

    "first check in the PERNR table
    SELECT SINGLE pernr
             FROM pa0105
            WHERE usrty = '0001'
              AND usrid = @sy-uname
              AND begda LE @sy-datum
              AND endda GT @sy-datum
       INTO @DATA(lv_pernr).

    lv_otyp = 'O'.

    LOOP AT it_orgid INTO DATA(ls_orgid).

      CALL FUNCTION 'RH_PM_GET_STRUCTURE'
        EXPORTING
          plvar           = '01'
          otype           = lv_otyp
          objid           = ls_orgid
          begda           = sy-datum
          endda           = sy-datum
          wegid           = 'AI_ORGUS'
        TABLES
          objec_tab       = lt_objects
        EXCEPTIONS
          not_found       = 1
          ppway_not_found = 2
          OTHERS          = 3.

      SELECT * FROM @lt_objects AS itab WHERE otype = 'S' INTO TABLE @DATA(lt_object_s) .
      SELECT * FROM @lt_objects AS itab WHERE otype = 'P' INTO TABLE @DATA(lt_object_p) .

      IF line_exists( lt_object_p[ realo = lv_pernr ] ).
        rv_result = abap_true.
        EXIT.
      ENDIF.

      CHECK rv_result IS INITIAL.  "onlt if it is not found in the above selection
      "get the user details from the Position
      lt_objid_s = VALUE #( FOR ls_object_s IN lt_object_s ( CONV #( ls_object_s-realo ) ) ).
      rv_result = is_user_belong_to_position( it_position_id =  lt_objid_s ).

      IF rv_result IS NOT INITIAL.
        EXIT.
      ENDIF.

    ENDLOOP.

  ENDMETHOD.


  METHOD is_user_belong_to_person.

    DATA(lv_pernr) = get_pernr_from_userid( iv_userid = sy-uname  ).
    IF line_exists( it_pernr[ pernr = lv_pernr ] ).
      rv_return = abap_true.
    ENDIF.
  ENDMETHOD.


  METHOD is_user_belong_to_position.


    DATA : lv_otyp TYPE otype.
    DATA : lt_disp TYPE STANDARD TABLE OF tree_objec.


    SELECT SINGLE pernr FROM pa0105 INTO @DATA(lv_pernr)
       WHERE usrty = '0001'
       AND usrid = @sy-uname
      AND begda LE @sy-datum AND endda GT @sy-datum.

    lv_otyp = 'S'.
    LOOP AT it_position_id INTO DATA(ls_position_id).
      CALL FUNCTION 'RH_OM_GET_HOLDER_OF_POSITION'
        EXPORTING
          plvar           = '01'
          otype           = lv_otyp
          objid           = ls_position_id
        TABLES
          disp_tab        = et_agent_from_position
        EXCEPTIONS
          no_active_plvar = 1
          OTHERS          = 2.

      IF line_exists( et_agent_from_position[ otype = 'US' realo = sy-uname ] ).
        rv_result = abap_true.
        EXIT.
      ENDIF.

      IF line_exists( et_agent_from_position[ otype = 'P' realo = lv_pernr ] ).
        rv_result = abap_true.
        EXIT.
      ENDIF.

      CLEAR : et_agent_from_position,ls_position_id.

    ENDLOOP.

  ENDMETHOD.


  METHOD is_user_belong_to_role.
    IF it_role IS NOT INITIAL.
      SELECT agr_name, uname FROM  agr_users
        FOR ALL ENTRIES IN @it_role
        WHERE agr_name EQ @it_role-agr_name
        AND   uname EQ @sy-uname
        AND   from_dat LE @sy-datum
        AND   to_dat   GT @sy-datum
      INTO TABLE @DATA(lt_users).

      IF sy-subrc EQ 0.
        rv_result = abap_true.
      ENDIF.
    ENDIF.
  ENDMETHOD.


  METHOD is_usmd_cr_block.
    DATA:lv_creq_type TYPE usmd_crequest_type,
         ls_message   TYPE usmd_s_message.
*    *Get CR Type
    CALL METHOD yz_clas_mdg_utility=>get_cr_type
      EXPORTING
        iv_crequest           = iv_usmd_crequest
      RECEIVING
        rv_usmd_crequest_type = lv_creq_type.

*    *Get Model
    DATA(lv_model) = cl_usmd_crequest_api=>get_model_from_crtype( iv_creq_type = lv_creq_type ).
    SELECT SINGLE *
    FROM usmd_cr_block
      WHERE usmd_model = @lv_model
      INTO @DATA(ls_cr_block).
    IF ls_cr_block-adjust_status = abap_true.
      rv_status = abap_true.
    ELSE.
      rv_status = abap_false.
    ENDIF.
  ENDMETHOD.


  METHOD is_workflow_user_id_locked.
    SELECT SINGLE bname,
           uflag
      FROM usr02
      WHERE bname EQ @iv_wfuser
      INTO @DATA(ls_usr02).
    IF ls_usr02-uflag NE 0.
      rv_status = abap_true.
    ENDIF.

  ENDMETHOD.


  METHOD mail_jobs_are_running.
    SUBMIT rsconn01 WITH mode = 'INT' WITH output = 'X' AND RETURN.
    IF sy-subrc EQ 0.
      rv_status = abap_true.
    ELSE.
      rv_status = abap_false.
    ENDIF.
  ENDMETHOD.


  METHOD restart_wrkitem_with_selection.
    DATA:ls_message  TYPE usmd_s_message.
    GET TIME STAMP FIELD DATA(lv_current_time).
    IF iv_usmd_crequest IS NOT INITIAL OR iv_days IS NOT INITIAL.
      SELECT
      FROM            usmd120c  AS cr_master
      LEFT OUTER JOIN usmd2400  AS cr_request ON cr_request~usmd_crequest = cr_master~usmd_crequest
      LEFT OUTER JOIN swwwihead AS cr_workitem   ON cr_request~top_wi_id = cr_workitem~top_wi_id AND cr_workitem~wi_stat = 'READY'
      FIELDS
            cr_master~usmd_crequest,
            cr_master~usmd_creq_status,
            cr_master~usmd_creq_type,
            cr_request~top_wi_id       AS top_wi_id,
            cr_workitem~wi_id          AS wi_id
      WHERE cr_master~usmd_crequest EQ @iv_usmd_crequest
        AND usmd_created_at < @( cl_abap_tstmp=>subtractsecs( tstmp = lv_current_time secs  = ( iv_days * 24 * 60 * 60  ) ) )
       INTO TABLE @DATA(lt_data).
      LOOP AT lt_data INTO DATA(ls_data).
*Get Model
        DATA(lv_model) = cl_usmd_crequest_api=>get_model_from_crtype( iv_creq_type = ls_data-usmd_creq_type ).

*Check whether Its Locked or not
        cl_usmd_model=>get_instance(
           EXPORTING
             i_usmd_model = lv_model
           IMPORTING
             eo_instance  = DATA(do_model)
             et_message   = DATA(lt_message) ).
*If Model is Bound
        IF do_model IS BOUND.
          do_model->enqueue(
            EXPORTING
              i_fieldname  = usmd0_cs_fld-crequest
              if_hry       = space
              it_value     = VALUE #( ( fieldname = usmd0_cs_fld-crequest value = ls_data-usmd_crequest  ) )
            IMPORTING
              et_message   = lt_message ).

          IF line_exists( lt_message[ msgty = 'E' ] ).
            ls_message-msgno = '014'.
            ls_message-msgid = 'YZMSG_MDG_ACC'.
            ls_message-msgty = 'E'.
            APPEND ls_message TO et_message.
            CLEAR ls_message.
            CONTINUE."Go For Next CR Processing
          ELSE.
            do_model->dequeue(
              EXPORTING
            i_fieldname  = usmd0_cs_fld-crequest
            if_hry       = space
            it_value     = VALUE #( ( fieldname = usmd0_cs_fld-crequest value =  ls_data-usmd_crequest ) )
            ).
          ENDIF.
        ENDIF.
        CALL FUNCTION 'SWW_WI_ADMIN_ERROR_RESTART'
          EXPORTING
            wi_id                 = ls_data-top_wi_id
            do_commit             = abap_true
            authorization_checked = abap_true
            enable_implicitly     = abap_true
          EXCEPTIONS
            OTHERS                = 99.
        IF sy-subrc = 0.
          ls_message-msgid = 'YZMSG_MDG_ACC'.
          ls_message-msgno = '026'.
          ls_message-msgty = 'S'.
          ls_message-msgv1 = ls_data-top_wi_id.
          ls_message-msgv2 = ls_data-usmd_crequest.
          APPEND ls_message TO et_message.
          CLEAR ls_message.
        ELSE.
          ls_message-msgid = 'YZMSG_MDG_ACC'.
          ls_message-msgno = '027'.
          ls_message-msgty = 'E'.
          ls_message-msgv1 = ls_data-top_wi_id.
          ls_message-msgv2 = ls_data-usmd_crequest.
          APPEND ls_message TO et_message.
          CLEAR ls_message.
        ENDIF.
      ENDLOOP.
    ELSE.
      ls_message-msgno = '013'.
      ls_message-msgid = 'YZMSG_MDG_ACC'.
      ls_message-msgty = 'E'.
      APPEND ls_message TO et_message.
      CLEAR ls_message.
    ENDIF.
  ENDMETHOD.


  METHOD set_brf_instance.
    mo_brf_factory ?= cl_fdt_factory=>if_fdt_factory~get_instance(  ).
    mo_brf_query ?= mo_brf_factory->get_query( ).
  ENDMETHOD.


  METHOD withdraw_cr_with_selection.
    DATA:lv_crequest_sta TYPE usmd_crequest_status,
         lv_creq_type    TYPE usmd_crequest_type,
         ls_message      TYPE usmd_s_message.
    DATA : lr_crequest TYPE RANGE OF usmd_crequest.
    GET TIME STAMP FIELD DATA(lv_current_time).
    IF iv_usmd_crequest IS NOT INITIAL OR iv_days IS NOT INITIAL.
      SELECT
       FROM            usmd120c  AS cr_master
       LEFT OUTER JOIN usmd2400  AS cr_request ON cr_request~usmd_crequest = cr_master~usmd_crequest
       LEFT OUTER JOIN swwwihead AS cr_workitem   ON cr_request~top_wi_id = cr_workitem~top_wi_id AND cr_workitem~wi_stat = 'READY'
       FIELDS
             cr_master~usmd_crequest,
             cr_master~usmd_creq_status,
             cr_master~usmd_creq_type,
             cr_request~top_wi_id       AS top_wi_id,
             cr_workitem~wi_id          AS wi_id
       WHERE cr_master~usmd_crequest EQ @iv_usmd_crequest
         AND usmd_created_at < @( cl_abap_tstmp=>subtractsecs( tstmp = lv_current_time secs  = ( iv_days * 24 * 60 * 60  ) ) )
        INTO TABLE @DATA(lt_data).

      LOOP AT lt_data INTO DATA(ls_data).

*Get Model
        DATA(lv_model) = cl_usmd_crequest_api=>get_model_from_crtype( iv_creq_type = ls_data-usmd_creq_type ).

*Check whether Its Locked or not
        cl_usmd_model=>get_instance(
           EXPORTING
             i_usmd_model = lv_model
           IMPORTING
             eo_instance  = DATA(do_model)
             et_message   = DATA(lt_message) ).

*If Model is Bound
        IF do_model IS BOUND.
          do_model->enqueue(
            EXPORTING
              i_fieldname  = usmd0_cs_fld-crequest
              if_hry       = space
              it_value     = VALUE #( ( fieldname = usmd0_cs_fld-crequest value = ls_data-usmd_crequest  ) )
            IMPORTING
              et_message   = lt_message ).

          IF line_exists( lt_message[ msgty = 'E' ] ).
            ls_message-msgid = 'YZMSG_MDG_ACC'.
            ls_message-msgno = '014'.
            ls_message-msgty = 'E'.
            ls_message-msgv1 = ls_data-usmd_crequest.
            APPEND ls_message TO et_message.
            CLEAR ls_message.
            CONTINUE."Go For Next CR Processing
          ELSE.
            do_model->dequeue(
              EXPORTING
            i_fieldname  = usmd0_cs_fld-crequest
            if_hry       = space
            it_value     = VALUE #( ( fieldname = usmd0_cs_fld-crequest value = ls_data-usmd_crequest  ) )
            ).
          ENDIF.
        ENDIF.

        IF ls_data-usmd_creq_status EQ '02'.

          SELECT COUNT(*) FROM usmd130c BYPASSING BUFFER WHERE usmd_creq_status = ls_data-usmd_creq_status AND usmd_creq_obmain = 'O'.
          IF sy-subrc = 0.
            lr_crequest = VALUE #( ( sign = 'I' option = 'EQ' low = ls_data-usmd_crequest ) ).
*            SUBMIT usmd_delete_crequest WITH model = lv_model WITH crequest-low = ls_data-usmd_crequest AND RETURN.
            SUBMIT usmd_delete_crequest WITH model = lv_model WITH crequest IN lr_crequest AND RETURN.
            IF sy-subrc = 0.
              SELECT COUNT(*) FROM usmd120c WHERE usmd_crequest = ls_data-usmd_crequest.
              IF sy-subrc <> 0.
                ls_message-msgid = 'YZMSG_MDG_ACC'.
                ls_message-msgno = '018'.
                ls_message-msgty = 'E'.
                ls_message-msgv1 = ls_data-usmd_crequest.
                APPEND ls_message TO et_message.
                CLEAR ls_message.
              ELSE.
                ls_message-msgid = 'YZMSG_MDG_ACC'.
                ls_message-msgno = '019'.
                ls_message-msgty = 'E'.
                ls_message-msgv1 = ls_data-usmd_crequest.
                APPEND ls_message TO et_message.
                CLEAR ls_message.
              ENDIF.
            ELSE.
              ls_message-msgid = 'YZMSG_MDG_ACC'.
              ls_message-msgno = '019'.
              ls_message-msgty = 'E'.
              ls_message-msgv1 = ls_data-usmd_crequest.
              APPEND ls_message TO et_message.
              CLEAR ls_message.
            ENDIF.
          ENDIF.
        ELSE.

          DATA(lo_wf_bo) = cl_usmd_wf_bo_service=>get_instance( ).

          IF lo_wf_bo IS BOUND.
            REFRESH lt_message.
            lo_wf_bo->rollback_crequest(
              EXPORTING
                id_crequest      = ls_data-usmd_crequest               " Change Request
                id_released_by   = sy-uname                 " User Name
              IMPORTING
                et_message       = lt_message                  " Messages
                ed_result        = DATA(lv_result)                 " Financials MDM: General Indicator
            ).

            IF lv_result EQ '0'.
              ls_message-msgid = 'YZMSG_MDG_ACC'.
              ls_message-msgno = '019'.
              ls_message-msgty = 'E'.
              ls_message-msgv1 = ls_data-usmd_crequest.
              APPEND ls_message TO et_message.
              CLEAR ls_message.

            ELSE.
              IF line_exists( lt_message[ msgty = 'E' ] ).
                ls_message-msgid = 'YZMSG_MDG_ACC'.
                ls_message-msgno = '019'.
                ls_message-msgty = 'E'.
                ls_message-msgv1 = ls_data-usmd_crequest.
                APPEND ls_message TO et_message.
                CLEAR ls_message.
              ENDIF.
            ENDIF.
          ELSE.
            ls_message-msgid = 'YZMSG_MDG_ACC'.
            ls_message-msgno = '021'.
            ls_message-msgty = 'E'.
            ls_message-msgv1 = ls_data-usmd_crequest.
            APPEND ls_message TO et_message.
            CLEAR ls_message.
          ENDIF.
        ENDIF.
        CLEAR ls_data.
      ENDLOOP.
    ELSE.
      ls_message-msgno = '013'.
      ls_message-msgid = 'YZMSG_MDG_ACC'.
      ls_message-msgty = 'E'.
      APPEND ls_message TO et_message.
      CLEAR ls_message.
    ENDIF.

  ENDMETHOD.


  METHOD workflow_jobs_are_running.
    DATA:lv_status TYPE tbtcjob-status.
    SELECT SINGLE jobname,
           MAX( jobcount ) AS max
      FROM tbtco
      INTO  @DATA(ls_tbtco)
      WHERE jobname = 'SWWCLEAR'
      GROUP BY jobname.
    CALL FUNCTION 'BP_JOB_STATUS_GET'
      EXPORTING
        jobcount                   = ls_tbtco-max
        jobname                    = 'SWWCLEAR'
*       READ_ONLY_STATUS           =
      IMPORTING
        status                     = lv_status
*       HAS_CHILD                  =
      EXCEPTIONS
        job_doesnt_exist           = 1
        unknown_error              = 2
        parent_child_inconsistency = 3
        OTHERS                     = 4.
    IF sy-subrc <> 0.
* Implement suitable error handling here
    ENDIF.
    IF lv_status = 'F'.
      ev_swwclear = abap_false.
    ELSE.
      ev_swwclear = abap_true.
    ENDIF.
    CLEAR:lv_status,
          ls_tbtco.
    SELECT SINGLE jobname,
       MAX( jobcount ) AS max
  FROM tbtco
  INTO  @ls_tbtco
  WHERE jobname = 'SWWCOND'
  GROUP BY jobname.
    CALL FUNCTION 'BP_JOB_STATUS_GET'
      EXPORTING
        jobcount                   = ls_tbtco-max
        jobname                    = 'SWWCOND'
*       READ_ONLY_STATUS           =
      IMPORTING
        status                     = lv_status
*       HAS_CHILD                  =
      EXCEPTIONS
        job_doesnt_exist           = 1
        unknown_error              = 2
        parent_child_inconsistency = 3
        OTHERS                     = 4.
    IF sy-subrc <> 0.
* Implement suitable error handling here
    ENDIF.
    IF lv_status = 'F'.
      ev_wwcond = abap_false.
    ELSE.
      ev_wwcond = abap_true.
    ENDIF.
    CLEAR:lv_status,
      ls_tbtco.
    SELECT SINGLE jobname,
       MAX( jobcount ) AS max
  FROM tbtco
  INTO  @ls_tbtco
  WHERE jobname = 'SWWERRE'
  GROUP BY jobname.
    CALL FUNCTION 'BP_JOB_STATUS_GET'
      EXPORTING
        jobcount                   = ls_tbtco-max
        jobname                    = 'SWWERRE'
*       READ_ONLY_STATUS           =
      IMPORTING
        status                     = lv_status
*       HAS_CHILD                  =
      EXCEPTIONS
        job_doesnt_exist           = 1
        unknown_error              = 2
        parent_child_inconsistency = 3
        OTHERS                     = 4.
    IF sy-subrc <> 0.
* Implement suitable error handling here
    ENDIF.
    IF lv_status = 'F'.
      ev_swwerre = abap_false.
    ELSE.
      ev_swwerre = abap_true.
    ENDIF.
    CLEAR:lv_status,
      ls_tbtco.
    SELECT SINGLE jobname,
       MAX( jobcount ) AS max
  FROM tbtco
  INTO  @ls_tbtco
  WHERE jobname = 'SWWDHEX'
  GROUP BY jobname.
    CALL FUNCTION 'BP_JOB_STATUS_GET'
      EXPORTING
        jobcount                   = ls_tbtco-max
        jobname                    = 'SWWDHEX'
*       READ_ONLY_STATUS           =
      IMPORTING
        status                     = lv_status
*       HAS_CHILD                  =
      EXCEPTIONS
        job_doesnt_exist           = 1
        unknown_error              = 2
        parent_child_inconsistency = 3
        OTHERS                     = 4.
    IF sy-subrc <> 0.
* Implement suitable error handling here
    ENDIF.
    IF lv_status = 'F'.
      ev_swwdhex = abap_false.
    ELSE.
      ev_swwdhex = abap_true.
    ENDIF.



  ENDMETHOD.


  METHOD get_class_by_impl_interface.

    CALL FUNCTION 'SEO_INTERFACE_IMPLEM_GET_ALL'
      EXPORTING
        intkey       = iv_interface_name
      IMPORTING
        impkeys      = rt_class_name
      EXCEPTIONS
        not_existing = 1
        OTHERS       = 2.

  ENDMETHOD.


  METHOD get_yyorgunit.


    CREATE DATA er_data TYPE tt_yyorgunit.

    ASSIGN er_data->* TO FIELD-SYMBOL(<ft_data>).
    IF <ft_data> IS ASSIGNED.
      <ft_data> = gt_yyorgunit.
    ENDIF.
*fall back API
  ENDMETHOD.


  METHOD get_yyusage.

    CREATE DATA er_data TYPE tt_yyusage.

    ASSIGN er_data->* TO FIELD-SYMBOL(<ft_data>).
    IF <ft_data> IS ASSIGNED.
      <ft_data> = gt_yyusage.
    ENDIF.
*fall back API
  ENDMETHOD.


  METHOD set_yyorgunit.

    gt_yyorgunit = CORRESPONDING #( it_data ).
  ENDMETHOD.


  METHOD set_yyusage.
    gt_yyusage = CORRESPONDING #( it_data ).
  ENDMETHOD.


  METHOD get_dynamic_join_clause.

    DATA : lt_tabname    TYPE tt_tabnames.
    DATA : lt_join_final TYPE STANDARD TABLE OF yzc_ddls_uniq.

    SELECT COUNT( DISTINCT tabname ) FROM @it_entity_attr AS itab INTO @DATA(lv_count). "get number of tables involved in the join
    IF lv_count EQ 1.
      TRY .
          rt_join_clause = it_entity_attr[ 1 ]-tabname.
        CATCH cx_sy_itab_line_not_found.
      ENDTRY.
      RETURN.
    ENDIF.

    IF it_entity_attr IS NOT INITIAL.
      SELECT DISTINCT botype
         FROM yzc_usmd_mdl_attrib
     INTO TABLE @DATA(lt_bo)
        FOR ALL ENTRIES IN @it_entity_attr
        WHERE entity EQ @it_entity_attr-entity.

      IF lt_bo IS NOT INITIAL.
        SELECT left_table,right_table,left_field,right_field
          FROM yzc_ddls_uniq
          INTO TABLE @DATA(lt_join_list)
          FOR ALL ENTRIES IN @lt_bo
         WHERE otc EQ @lt_bo-botype.

      ENDIF.
      IF lt_join_list IS NOT INITIAL.
        SELECT left_table,right_table
          FROM yzc_ddls_uniq
          INTO TABLE @DATA(gt_table_list)
            FOR ALL ENTRIES IN @it_entity_attr
            WHERE right_table = @it_entity_attr-tabname.
      ENDIF.



      lt_tabname = VALUE #( FOR ls_entity_attr IN it_entity_attr ( ls_entity_attr-tabname ) ).
**      LOOP AT gt_table_list INTO DATA(ls_table_list).
**        APPEND : ls_table_list-left_table TO lt_tabname,ls_table_list-right_table TO lt_tabname.
**      ENDLOOP.
      lt_tabname = VALUE #( BASE lt_tabname FOR ls_table_list IN gt_table_list ( ls_table_list-left_table ) ( ls_table_list-right_table ) ).
*        SELECT left_table as table_name FROM @gt_table_list as table_left
*            UNION DISTINCT
*        SELECT right_table as table_name FROM @gt_table_list as table_right
*          INTO TABLE @lt_tabname.
      SORT lt_tabname.
      DELETE ADJACENT DUPLICATES FROM lt_tabname COMPARING ALL FIELDS.
    ENDIF.
    IF lt_tabname IS NOT INITIAL.
      LOOP AT lt_tabname INTO DATA(ls_tabname).
        SELECT * FROM @lt_join_list AS itab
          WHERE left_table =  @ls_tabname OR right_table = @ls_tabname
          APPENDING TABLE @DATA(lt_subjoin_list).
      ENDLOOP.
    ENDIF.

*ENDLOOP.
    LOOP AT lt_subjoin_list INTO DATA(ls_subjoin_list).

      TRY .
          IF line_exists( lt_tabname[ table_line = ls_subjoin_list-right_table ] ).

            lt_join_final = VALUE #( BASE lt_join_final  ( left_table  = ls_subjoin_list-left_table
                                                           right_table = ls_subjoin_list-right_table
                                                           left_field = ls_subjoin_list-left_field
                                                           right_field = ls_subjoin_list-right_field ) ).
          ENDIF.
        CATCH cx_sy_itab_line_not_found.
      ENDTRY.
    ENDLOOP.

    SORT lt_join_final.
    DELETE ADJACENT DUPLICATES FROM lt_join_final COMPARING ALL FIELDS.

    LOOP AT lt_join_final INTO DATA(ls_join_final_temp).
      DATA(ls_join_final) = ls_join_final_temp.
      AT FIRST.
        rt_join_clause = rt_join_clause && | | && ls_join_final-left_table.
      ENDAT.
      AT NEW right_table.
        rt_join_clause = rt_join_clause && | | && | | && 'JOIN' && | | && ls_join_final-right_table &&
                       | | && 'ON' && | |.
      ENDAT.

      rt_join_clause = rt_join_clause && | | && ls_join_final-left_table && '~' && ls_join_final-left_field  && | | && '=' && | | &&
                                   ls_join_final-right_table && '~' && ls_join_final-right_field && | | && 'AND'.
      AT END OF right_table.
        REPLACE REGEX 'AND$' IN rt_join_clause WITH ' '.
      ENDAT.

      CLEAR : ls_join_final_temp,ls_join_final.
    ENDLOOP.

    REPLACE REGEX 'AND$' IN rt_join_clause WITH ' '.

    CLEAR : lv_count.",lv_join_type.
  ENDMETHOD.


  METHOD get_keys_of_entity.
    READ TABLE gt_entity_keys WITH KEY usmd_entity = iv_entity ASSIGNING FIELD-SYMBOL(<ls_entity_keys>).
    IF sy-subrc = 0.
      APPEND LINES OF <ls_entity_keys>-t_entity_key TO rt_entity_keys.
    ENDIF.
  ENDMETHOD.


  METHOD get_key_value_table.

    LOOP AT get_keys_of_entity( iv_entity ) ASSIGNING FIELD-SYMBOL(<lv_entity_key>).
      ASSIGN COMPONENT <lv_entity_key> OF STRUCTURE is_record TO FIELD-SYMBOL(<lv_value>).
      IF sy-subrc = 0.
        rt_key_value = VALUE #( BASE rt_key_value ( key_field = <lv_entity_key> value = <lv_value> ) ).
      ENDIF.
    ENDLOOP.

  ENDMETHOD.


  METHOD get_message.
    DATA:
      ls_ui_message TYPE usmd_s_message,
      lr_key        TYPE REF TO data,
      lo_strucdesc  TYPE REF TO cl_abap_structdescr,
      lt_components TYPE abap_component_tab,
      ls_components TYPE LINE OF abap_component_tab,
      lv_fieldname  TYPE usmd_fieldname.

    FIELD-SYMBOLS:
      <ls_key>    TYPE any,
      <lv_source> TYPE any,
      <lv_dest>   TYPE any.

* populate message components in UI message format
    ls_ui_message-msgid = iv_symsgid.
    ls_ui_message-msgty = iv_msgty.
    ls_ui_message-msgno = iv_msgno.
    IF iv_msgv1 IS NOT INITIAL.
      ls_ui_message-msgv1 = iv_msgv1.
    ENDIF.
    IF iv_msgv2 IS NOT INITIAL.
      ls_ui_message-msgv2 = iv_msgv2.
    ENDIF.
    IF iv_msgv3 IS NOT INITIAL.
      ls_ui_message-msgv3 = iv_msgv3.
    ENDIF.
    IF iv_msgv4 IS NOT INITIAL.
      ls_ui_message-msgv4 = iv_msgv4.
    ENDIF.

* if called from validations enhance with message navigation
    IF      io_model     IS SUPPLIED
        AND iv_entity    IS SUPPLIED
        AND iv_fieldname IS SUPPLIED
        AND is_data      IS SUPPLIED.

      lv_fieldname = iv_entity.
      CALL METHOD io_model->create_data_reference
        EXPORTING
          i_fieldname = lv_fieldname
          i_struct    = if_usmd_model_ext=>gc_struct_key
          if_table    = abap_false
        IMPORTING
          er_data     = lr_key.

      ASSIGN lr_key->* TO <ls_key>.
      IF sy-subrc IS NOT INITIAL.
        RETURN.
      ENDIF.

      lo_strucdesc ?= cl_abap_structdescr=>describe_by_data( p_data = <ls_key> ).
      lt_components = lo_strucdesc->get_components( ).
      LOOP AT lt_components INTO ls_components.
        ASSIGN COMPONENT ls_components-name OF STRUCTURE <ls_key> TO <lv_dest>.
        IF sy-subrc <> 0.
          RETURN.
        ENDIF.

        ASSIGN COMPONENT ls_components-name OF STRUCTURE is_data TO <lv_source>.
        IF sy-subrc <> 0.
          RETURN.
        ENDIF.
        <lv_dest> = <lv_source>.
      ENDLOOP.

      ls_ui_message-row = cl_mdg_bs_key_row_map_service=>set_key(
        is_key       = lr_key
        iv_entity    = iv_entity
        iv_fieldname = iv_fieldname ).

      CONCATENATE iv_entity '-' iv_fieldname INTO ls_ui_message-fieldname.
    ENDIF.

    es_message = ls_ui_message.
  ENDMETHOD.


  METHOD get_staging_table.
    DATA: lo_model_gen_adapter TYPE REF TO if_usmd_model_gen_adapter,
          lt_message           TYPE usmd_t_message,
          lt_log_phys_name     TYPE if_usmd_model_gen_adapter=>t_log_phys_name,
          lv_sid               TYPE usmd_flg,
          lv_former_versions   TYPE usmd_flg.

    ""determine the staging table to read mapping
    CALL METHOD cl_usmd_adapter_provider=>get_model_generation_adapter
      EXPORTING
        i_usmd_model         = iv_model
      IMPORTING
        eo_model_gen_adapter = lo_model_gen_adapter
        et_message           = lt_message.

    LOOP AT lt_message TRANSPORTING NO FIELDS WHERE msgty CA 'AEX'  ##NEEDED.
    ENDLOOP.
    IF sy-subrc IS INITIAL.
      RETURN.
    ENDIF.

    CALL METHOD lo_model_gen_adapter->get_generated_objects
      EXPORTING
        if_former_versions = lv_former_versions
        if_sid_tab         = lv_sid
      IMPORTING
        et_message         = lt_message
        et_log_phys_name   = lt_log_phys_name.

    LOOP AT lt_message TRANSPORTING NO FIELDS WHERE msgty CA 'AEX' ##NEEDED.
    ENDLOOP.
    IF sy-subrc IS INITIAL.
      RETURN.
    ENDIF.

    IF lt_log_phys_name IS NOT INITIAL.
      rt_staging_table = lt_log_phys_name.
    ENDIF.
  ENDMETHOD.


  METHOD get_texts.
* this method would provide descriptions assocaited with either entity or attribute
* Either iventity or iv_attribute has to be provided
    FIELD-SYMBOLS: <ls_attr_prop>   TYPE usmd_s_fprop_ext.

    DATA:ls_enty TYPE usmd_s_entity_prop_ext.
    IF iv_entity IS NOT INITIAL.
      READ TABLE io_model->dt_entity_prop INTO ls_enty WITH KEY usmd_entity = iv_entity.
      CHECK sy-subrc EQ 0.

      ASSIGN ls_enty-r_fprop->* TO <ls_attr_prop>.
      CHECK sy-subrc EQ 0.


    ELSEIF iv_attribute IS NOT INITIAL.
      READ TABLE io_model->dt_fprop ASSIGNING <ls_attr_prop> WITH KEY fieldname = iv_attribute.
      CHECK sy-subrc EQ 0.
    ELSEIF iv_attribute IS NOT INITIAL AND iv_entity IS NOT INITIAL.
*    To do error handling
    ENDIF.
    CHECK <ls_attr_prop> IS ASSIGNED.
    ev_txt_l = <ls_attr_prop>-scrtext_l.
    ev_txt_m = <ls_attr_prop>-scrtext_m.
  ENDMETHOD.


  METHOD get_where_condition.
    DATA:
       lv_key TYPE string.

    FIELD-SYMBOLS:
     <ls_key_value> TYPE gty_s_key_value.

    CLEAR rv_where.

    IF it_key_value IS NOT INITIAL.
      LOOP AT it_key_value ASSIGNING <ls_key_value>.
        IF <ls_key_value>-value IS NOT INITIAL.
          lv_key = <ls_key_value>-value.
          IF rv_where IS NOT INITIAL.
            CONCATENATE rv_where ' AND ' INTO rv_where RESPECTING BLANKS.
          ENDIF.
          CONCATENATE rv_where  '( ' INTO rv_where RESPECTING BLANKS.
          CONCATENATE rv_where <ls_key_value>-key_field ' = ' '''' lv_key INTO rv_where RESPECTING BLANKS.
          CONCATENATE rv_where  ''' )' INTO rv_where RESPECTING BLANKS.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.


  METHOD init_entity_attribute_rel.
    DATA:
      lr_new_table            TYPE REF TO data,
      lr_entity               TYPE REF TO data,
      lr_new_record           TYPE REF TO data,
      lo_strucdescr           TYPE REF TO cl_abap_structdescr,
      lt_components           TYPE abap_compdescr_tab,
      ls_entity_attribute_rel TYPE gty_s_entity_attributes_rel,
      ls_attribute_entity_rel TYPE gty_s_attribute_entity_rel,
      lv_attrbiute            TYPE usmd_attribute.

    FIELD-SYMBOLS:
      <lt_entity>      TYPE SORTED TABLE,
      <lv_entity_name> TYPE usmd_entity,
      <lt_new_records> TYPE SORTED TABLE,
      <ls_new_record>  TYPE any,
      <ls_component>   TYPE abap_compdescr.

    LOOP AT get_all_entities( ) ASSIGNING <lv_entity_name>.
      CALL METHOD get_entity_reference
        EXPORTING
          iv_entity = <lv_entity_name>
        IMPORTING
          er_entity = lr_entity.

*      IF lr_entity IS NOT BOUND AND <lv_entity_name> <> 'ZGEOCODE'.
*        RAISE entity_attribute_not_found.
*      ENDIF.

      ASSIGN lr_entity->* TO <lt_entity>.

      CREATE DATA lr_new_table LIKE <lt_entity>.
      ASSIGN lr_new_table->* TO <lt_new_records>.

      CREATE DATA lr_new_record LIKE LINE OF <lt_new_records>.
      ASSIGN lr_new_record->* TO <ls_new_record>.

      lo_strucdescr ?= cl_abap_typedescr=>describe_by_data( p_data = <ls_new_record> ).
      lt_components = lo_strucdescr->components.

      CLEAR: ls_entity_attribute_rel.
      ls_entity_attribute_rel-entity = <lv_entity_name>.

      LOOP AT lt_components ASSIGNING <ls_component>.
        CLEAR: ls_attribute_entity_rel.
        lv_attrbiute = <ls_component>-name.

        INSERT lv_attrbiute INTO TABLE ls_entity_attribute_rel-attributes.

        ls_attribute_entity_rel-attribute = lv_attrbiute.
        ls_attribute_entity_rel-entity = <lv_entity_name>.
        INSERT ls_attribute_entity_rel INTO TABLE gt_attribute_entity_rel.
      ENDLOOP.

      INSERT ls_entity_attribute_rel INTO TABLE gt_entity_attributes_rel.
    ENDLOOP.
  ENDMETHOD.


  METHOD init_entity_keys.

    DATA:
      lo_structdescr TYPE REF TO cl_abap_structdescr,
      lr_data        TYPE REF TO data,
      ls_entity_cont TYPE usmd_s_entity_cont,
      lt_entities    TYPE usmd_t_entity,
      lt_components  TYPE abap_compdescr_tab,
      lv_fieldname   TYPE usmd_fieldname.

    FIELD-SYMBOLS:
      <lv_entity>    TYPE usmd_entity,
      <ls_component> TYPE abap_compdescr,
      <lv_component> TYPE any.

* loop over all type 1 and 4 entites to build table with keys
    LOOP AT get_all_entities( ) ASSIGNING <lv_entity>.
      CLEAR: lv_fieldname, lt_components,
             ls_entity_cont, lt_entities, lr_data.
      UNASSIGN: <lv_component>.

      lv_fieldname = <lv_entity>.

**    get key structure reference of current entity
      get_cr_usmd_model_ext_api( iv_usmd_model = iv_model  )->create_data_reference(
        EXPORTING
          i_fieldname = lv_fieldname
          i_struct    = if_usmd_model=>gc_struct_key
          if_table    = abap_false
        IMPORTING
          er_data     = lr_data ).

      lo_structdescr ?= cl_abap_typedescr=>describe_by_data_ref( p_data_ref = lr_data ).
      lt_components = lo_structdescr->components.

**     write all key entities of current entity into entity list
      LOOP AT lt_components ASSIGNING <ls_component>.
        ASSIGN COMPONENT 'NAME' OF STRUCTURE <ls_component> TO <lv_component>.
        IF <lv_component> IS ASSIGNED.
          APPEND <lv_component> TO lt_entities.
        ENDIF.
      ENDLOOP.

**      build entity key table
      ls_entity_cont-usmd_entity = <lv_entity>.
      APPEND LINES OF lt_entities TO ls_entity_cont-t_entity_key.
      INSERT ls_entity_cont INTO TABLE gt_entity_keys.
    ENDLOOP.

  ENDMETHOD.


  METHOD init_model.
    CALL METHOD cl_usmd_model_ext=>get_instance
      EXPORTING
        i_usmd_model = iv_model
      IMPORTING
        eo_instance  = go_model.
  ENDMETHOD.


  METHOD modify_idoc_segment_field.
    FIELD-SYMBOLS:
      <lv_value>     TYPE any,
      <ls_idoc_data> TYPE edidd,
      <ls_segm_data> TYPE any.

    TRY .

        DATA:
          lo_structdescr TYPE REF TO cl_abap_structdescr,
          lr_segm_data   TYPE REF TO data.

        LOOP AT ct_idoc_data ASSIGNING <ls_idoc_data> FROM i_fromidx WHERE segnam = i_segnam.
          IF sy-subrc = 0.
            " create data of type of current parent segment
            lo_structdescr ?= cl_abap_structdescr=>describe_by_name( p_name = i_segnam ).
            CREATE DATA lr_segm_data TYPE HANDLE lo_structdescr.
            ASSIGN lr_segm_data->* TO <ls_segm_data>.
            IF sy-subrc = 0.
              MOVE <ls_idoc_data>-sdata TO <ls_segm_data>.
              ASSIGN COMPONENT i_segfld OF STRUCTURE <ls_segm_data> TO <lv_value>.
              IF <lv_value> IS ASSIGNED.
                MOVE i_fldval TO <lv_value>.
                MOVE <ls_segm_data> TO <ls_idoc_data>-sdata.
              ENDIF.
            ENDIF.
          ENDIF.
        ENDLOOP.

      CATCH cx_root INTO DATA(ex_root).
*        MESSAGE ex_root->get_longtext( ) TYPE zcl_mdg_general_functions=>gc_message_type.
    ENDTRY.
  ENDMETHOD.


  METHOD create_dependent_entities.

    DATA:
      lt_key_value             TYPE gty_t_key_value,
      lr_dependent_entity_data TYPE REF TO data,
      lr_new_record            TYPE REF TO data,
      lt_entity_keys           TYPE usmd_t_entity,
      lv_found                 TYPE abap_bool VALUE abap_false.

    FIELD-SYMBOLS:
      <ls_dependent_entities>    TYPE gty_s_dependent_entities,
      <lv_dependent_entity>      TYPE usmd_entity,
      <lt_dependent_entity_data> TYPE ANY TABLE,
      <ls_new_record>            TYPE any,
      <lv_source>                TYPE any,
      <lv_target>                TYPE any,
      <lv_key>                   TYPE usmd_entity,
      <ls_data>                  TYPE any.

    READ TABLE gt_dependent_entities WITH TABLE KEY entity = iv_entity ASSIGNING <ls_dependent_entities> .

    IF sy-subrc = 0.

      LOOP AT <ls_dependent_entities>-dependent_entities ASSIGNING <lv_dependent_entity>.
        UNASSIGN: <lt_dependent_entity_data>, <ls_new_record>.
        CLEAR: lt_entity_keys.

        CALL METHOD get_entity_reference
          EXPORTING
            iv_entity = <lv_dependent_entity>
          IMPORTING
            er_entity = lr_dependent_entity_data.

        ASSIGN lr_dependent_entity_data->* TO <lt_dependent_entity_data>.

        IF sy-subrc = 0.
          DATA(lv_where) = get_where_condition( get_key_value_table( iv_entity = iv_entity is_record = is_record ) ).


          LOOP AT <lt_dependent_entity_data> ASSIGNING <ls_data> WHERE (lv_where).
            lv_found = abap_true.
            EXIT.
          ENDLOOP.

          IF lv_found = abap_false.

            CREATE DATA lr_new_record LIKE LINE OF <lt_dependent_entity_data>.
            ASSIGN lr_new_record->* TO <ls_new_record>.

            LOOP AT get_keys_of_entity( <lv_dependent_entity> ) ASSIGNING <lv_key>.
              ASSIGN COMPONENT <lv_key> OF STRUCTURE is_record TO <lv_source>.
              ASSIGN COMPONENT <lv_key> OF STRUCTURE <ls_new_record> TO <lv_target>.
              <lv_target> = <lv_source>.
            ENDLOOP.

            INSERT <ls_new_record> INTO TABLE <lt_dependent_entity_data>.

          ENDIF.
        ELSE.
*          MESSAGE x000(zmdg_gen_dm_msg).
        ENDIF.

      ENDLOOP.

    ENDIF.

  ENDMETHOD.


  METHOD filter_current_context.

    LOOP AT get_keys_of_entity( iv_entity )  ASSIGNING FIELD-SYMBOL(<lv_entity_key>).
      READ TABLE it_key_value WITH TABLE KEY key_field = <lv_entity_key> ASSIGNING FIELD-SYMBOL(<ls_key_value>).
      IF sy-subrc = 0.
        INSERT <ls_key_value> INTO TABLE rt_key_value.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.


  METHOD get_all_entities.

    DATA:
      lt_entity_names TYPE  usmd_ts_entity_prop_ext,
      lt_all_entities TYPE usmd_t_entity.

    FIELD-SYMBOLS:
    <ls_entity_key> TYPE usmd_s_entity_prop_ext.

    CLEAR: rt_all_entities.

* fetch all entities from data model
    lt_entity_names = go_model->if_usmd_model_metadata_ext~dt_entity_prop.

* only entity of type 1 and 4 are considered for cache (everything else are key fields)
    DELETE lt_entity_names WHERE ( usage_type <> '1' AND usage_type <> '4' ). "#EC CI_SORTSEQ "sorted access not required due to table size >100

* write date to internal entity list
    LOOP AT lt_entity_names ASSIGNING <ls_entity_key>.
      APPEND <ls_entity_key>-usmd_entity TO lt_all_entities.
    ENDLOOP.
    SORT lt_all_entities.

    rt_all_entities = lt_all_entities.

  ENDMETHOD.


  METHOD get_application_parameter.

    cl_usmd_generic_bolui_assist=>get_application_parameter(
      EXPORTING
        it_parameter           = it_parameter                 " Parameter Value
      IMPORTING
        ev_action              = ev_action                              " Logical Action
        ev_cr_id               = ev_cr_id                               " Change Request ID
        ev_cr_type             = ev_cr_type                             " Type of Change Request
        ev_entity              = ev_entity                              " Entity Type
        ev_model               = ev_model                               " Data Model
        ev_otc                 = ev_otc                                 " Business Object Type
        ev_search_edition_mode = ev_search_edition_mode                 " Indicator: True - Editon Search, False - Valid On Search
        ev_edition             = ev_edition                             " Edition
        ev_hierarchy_entity    = ev_hierarchy_entity                    " Leading Entity Type from Param. USMD_HIERARCHY
    ).

  ENDMETHOD.


  METHOD get_cr_number_from_url.

    IF rv_crequest IS INITIAL.
      get_application_parameter( IMPORTING ev_cr_id  =  rv_crequest ).               " Change Request
    ENDIF.

    cl_usmd_fpm_assist=>get_appl_param_value(
                                    EXPORTING iv_name  = cl_mdg_bs_communicator_assist=>gc_parameter-usmd_crequest
                                    IMPORTING ev_value = rv_crequest ).

    IF rv_crequest IS INITIAL.
      cl_usmd_fpm_assist=>get_appl_param_value(
                                       EXPORTING iv_name  = cl_mdg_bs_communicator_assist=>gc_parameter-crequest
                                       IMPORTING ev_value = rv_crequest ).
    ENDIF.

    IF rv_crequest IS INITIAL.
      DATA(lt_navi_data) = get_navigation_data( ).
      rv_crequest = VALUE usmd_crequest( lt_navi_data[ fieldname = cl_mdg_bs_communicator_assist=>gc_parameter-usmd_crequest ]-value OPTIONAL ).
    ENDIF.

    IF rv_crequest IS INITIAL.
      rv_crequest = VALUE usmd_crequest( lt_navi_data[ fieldname = cl_mdg_bs_communicator_assist=>gc_parameter-crequest ]-value OPTIONAL ).
    ENDIF.

  ENDMETHOD.


  METHOD get_cr_type_from_url.

    cl_usmd_fpm_assist=>get_appl_param_value(
                                    EXPORTING iv_name  = cl_mdg_bs_communicator_assist=>gc_parameter-usmd_crequest_type
                                    IMPORTING ev_value = rv_cr_type ).

    IF rv_cr_type IS INITIAL.
      DATA(lt_navi_data) = get_navigation_data( ).
      rv_cr_type = VALUE #( lt_navi_data[ fieldname = cl_mdg_bs_communicator_assist=>gc_parameter-usmd_crequest_type ]-value OPTIONAL ).
    ENDIF.

  ENDMETHOD.


  METHOD get_entity_reference.

    CONSTANTS:
    lc_prefix TYPE string VALUE 'GT_'.

    DATA:
          lv_gt_name TYPE seocpdname.

    FIELD-SYMBOLS:
    <lt_entity>  TYPE SORTED TABLE.

    CLEAR: er_entity.

    CONCATENATE lc_prefix iv_entity INTO lv_gt_name.

    ASSIGN (lv_gt_name) TO <lt_entity>.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.
    GET REFERENCE OF <lt_entity> INTO er_entity.

  ENDMETHOD.


  METHOD get_navigation_data.

    DATA:
      lo_ui_service   TYPE REF TO if_usmd_ui_services,
      lv_rfcdest      TYPE rfcdest,
      lv_shm_instance TYPE shm_inst_name,
      lv_value        TYPE usmd_value.

    "method call is only valid in FPM environment
    DATA(lo_fpm) = cl_fpm_factory=>get_instance( ).
    IF lo_fpm IS NOT BOUND
    OR lo_fpm->mo_app_parameter IS NOT BOUND.
      RETURN.
    ENDIF.

    "check if shared memory is used
    lo_fpm->mo_app_parameter->get_value(
                                        EXPORTING iv_key   = 'USMD_RFCDEST'
                                        IMPORTING ev_value = lv_rfcdest ).

    lo_fpm->mo_app_parameter->get_value(
                                        EXPORTING iv_key   = 'USMD_SHM_INSTANCE'
                                        IMPORTING ev_value = lv_shm_instance ).

    IF lv_rfcdest IS NOT INITIAL AND lv_shm_instance IS NOT INITIAL.
      lo_ui_service = cl_usmd_ui_services=>get_instance( ).
      IF lo_ui_service IS INITIAL.
        RETURN.
      ENDIF.
      lo_ui_service->get_navigation_data(
      EXPORTING
        i_rfcdest = lv_rfcdest
        i_guid    = lv_shm_instance
      IMPORTING
        et_data   = rt_navi_data ).
    ENDIF.


  ENDMETHOD.


  METHOD get_otc_from_url.

    cl_usmd_fpm_assist=>get_appl_param_value(
                                    EXPORTING iv_name  = if_usmd_generic_bolui_const=>gc_fieldname_usmd_otc
                                    IMPORTING ev_value = rv_otc ).

    IF rv_otc IS INITIAL.
      DATA(lt_navi_data) = get_navigation_data( ).
      rv_otc = VALUE #( lt_navi_data[ fieldname = if_usmd_generic_bolui_const=>gc_fieldname_usmd_otc ]-value OPTIONAL ).
    ENDIF.


  ENDMETHOD.


  METHOD get_current_dqm_rule_id.

    SELECT FROM c_mdqualitytechnicalrule
         FIELDS mdqualitybusinessrule, mdqualitybusinessruleuuid
          WHERE mdqltytechnicalruleuuid = @iv_mdqltytechnicalruleuuid
           INTO (@rv_mdqualitybusinessrule,@ev_mdqualitybusinessruleuuid )
      UP TO 1 ROWS.
    ENDSELECT.

  ENDMETHOD.


  METHOD init_dependent_entities.

  ENDMETHOD.


  METHOD set_message_hyperlink.
    DATA lif_model   TYPE REF TO if_usmd_model_ext.
    DATA lo_key_ref TYPE REF TO data.

    FIELD-SYMBOLS <ls_key> TYPE any.

    CLEAR: ev_row.
    cl_usmd_model_ext=>get_instance(
      EXPORTING i_usmd_model = iv_model
      IMPORTING eo_instance  = lif_model ).

    lif_model->create_data_reference(
      EXPORTING i_fieldname = iv_entity && ''
                i_struct    = if_usmd_model_ext=>gc_struct_key
                if_table    = abap_false
      IMPORTING er_data     = lo_key_ref ).

    ASSIGN lo_key_ref->* TO <ls_key>.
    CHECK <ls_key> IS ASSIGNED.
*    MOVE-CORRESPONDING is_entity_data TO <ls_key>.
    <ls_key> = CORRESPONDING #( is_entity_data ).

    ev_row = cl_mdg_bs_key_row_map_service=>set_key( is_key       = lo_key_ref iv_entity    = iv_entity iv_fieldname = iv_attribute ).
*      RECEIVING rv_row       = ev_row ).
  ENDMETHOD.


  METHOD copy_entity.
  ENDMETHOD.


  METHOD copy_record.
  ENDMETHOD.


  METHOD execute_select_except.

    DATA(sel_list) = NEW select_list( dbtab  = iv_tab
                                      except = iv_except ).

    DATA(token)  = sel_list->get_token( ).
    DATA(target) = sel_list->get_target( ).

    SELECT (token)
      FROM (iv_tab)
INTO TABLE @target->*.

    IF sy-subrc = 0.
      et_data = target->*.
    ENDIF.

  ENDMETHOD.


  METHOD get_cr_changed_fields.

    DATA ls_changed_fields LIKE LINE OF rt_changed_fields.

    IF io_model_ext IS INITIAL.
      DATA(lo_model_ext) = get_cr_usmd_model_ext_api( EXPORTING iv_crequest = iv_crequest ).
    ELSE.
      lo_model_ext = io_model_ext.
    ENDIF.

    IF lo_model_ext IS BOUND.
      lo_model_ext->get_changed_fields( IMPORTING et_entity_fieldname = et_entity_fieldname ).
    ELSE.
*    Raise EXCEPTION
    ENDIF.

    IF iv_entity IS NOT INITIAL.
      DATA(lr_entity) = VALUE usmd_t_entity_r( ( sign = 'I' option = 'EQ' low = iv_entity ) ).
    ENDIF.

    SELECT usmd_entity, 'I' AS sign ,'EQ' AS option, fieldname AS low, ' ' AS high
      FROM @et_entity_fieldname AS itab
     WHERE usmd_entity IN @lr_entity
INTO TABLE @DATA(lt_data)
     .

    SORT lt_data BY usmd_entity.

    LOOP AT lt_data INTO DATA(ls_data) GROUP BY ls_data-usmd_entity.
      ls_changed_fields-usmd_entity = ls_data-usmd_entity.

      SELECT sign,option,low,high
        FROM @lt_data AS field_data
       WHERE usmd_entity = @ls_data-usmd_entity
  INTO TABLE @ls_changed_fields-fieldname.

      INSERT ls_changed_fields INTO TABLE rt_changed_fields.
    ENDLOOP.

  ENDMETHOD.


  METHOD get_cr_gov_api.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
* programming error: gov api must not be instanciated after / used from outside  convenience api"
    IF cl_usmd_conv_som_gov_api=>check_instance_exists( get_data_model( ) ) = abap_false.
      TRY.
          DATA(lv_model) = get_model_by_cr( iv_crequest = COND #( WHEN iv_crequest IS INITIAL THEN get_cr_number( ) ELSE iv_crequest ) ).
          IF  lv_model IS NOT INITIAL.
            cl_usmd_gov_api=>get_instance(
              EXPORTING
                iv_model_name = lv_model
              RECEIVING
                ro_gov_api    = ro_gov_api
            ).
          ENDIF.
        CATCH cx_usmd_gov_api.
*          Read exception and PAss it to ET_message
      ENDTRY.
    ENDIF.

  ENDMETHOD.


  METHOD get_cr_otc.
*****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************

*--------------------------------------------------------------------*
*    Step 1 get it From App Context
*--------------------------------------------------------------------*
    rv_otc = COND #( WHEN cl_usmd_app_context=>get_context( ) IS BOUND THEN cl_usmd_app_context=>get_context( )->mv_otc ).

*--------------------------------------------------------------------*
*    Step 2 get it From URL Parameters
*--------------------------------------------------------------------*
    IF rv_otc IS INITIAL.
      rv_otc = get_otc_from_url( ).
    ENDIF.

*--------------------------------------------------------------------*
*    Step 3 get it From WF Container
*--------------------------------------------------------------------*



*#FallBack API
    IF rv_otc IS INITIAL.
      rv_otc = COND #( WHEN iv_model EQ 'MM' THEN '194'
                       WHEN iv_model EQ 'BP' THEN '147'
                       ELSE rv_otc ).
    ENDIF.

  ENDMETHOD.


  METHOD get_cr_usmd_model_api.
****************************************************************************************
* Program Change History
*****************************************************************************************
* MOD-XXX       :
* Date          :
* Change No     :
* WRICEF-ID     :
* Defect-ID     :
* Transport     :
* Developer ID  :
* Release ID    :
*
**************************************************************************************
    cl_usmd_model=>get_instance(
         EXPORTING
           i_usmd_model = COND #( WHEN iv_usmd_model IS NOT INITIAL THEN iv_usmd_model ELSE get_data_model( ) )
         IMPORTING
          eo_instance  = ro_model
          et_message   = et_message ).

  ENDMETHOD.


  METHOD get_wf_element_value.

    DATA(lo_container) = get_wf_workitem_container( ).

    IF lo_container IS INITIAL.
      RETURN.
    ENDIF.

    TRY.

        lo_container->get(
        EXPORTING
          name       = name
        IMPORTING
          value      = value
          returncode = returncode ).

      CATCH
      cx_swf_cnt_elem_not_found
      cx_swf_cnt_elem_type_conflict
      cx_swf_cnt_unit_type_conflict
      cx_swf_cnt_container.
*     No change request found, therefore nothing to map
        RETURN.
    ENDTRY.

  ENDMETHOD.


  METHOD get_wf_workitem_container.

    DATA(lo_workitem_context) = get_wf_workitem_context( ).
    IF lo_workitem_context IS INITIAL.
      RETURN.
    ENDIF.

* The following steps have only to be performed when the workitem was started
    IF  lo_workitem_context->get_header( )-wi_stat <> swfco_wi_status_started.
      RETURN.
    ENDIF.

* Determine current workitem ID
    DATA(lv_wi) = lo_workitem_context->get_workitem_id( ).

* Determine the top workitem ID. Unfortunately there is no direct access via the workitem
* header but it must be determined via the workitem header details.
    DATA(lo_factory) = cl_swr_api_factory=>get_instance( ).
    IF lo_factory IS INITIAL.
      RETURN.
    ENDIF.

    DATA(lo_wi) = lo_factory->get_workitem_api( i_wi_key = VALUE #( wi_id = lv_wi ) ).
    IF lo_wi IS INITIAL.
      RETURN.
    ENDIF.

* Get workitem header details, there we will find the top workitem ID
    lo_wi->get_header( IMPORTING e_header_detail = DATA(ls_header_detail) ).

    DATA(lv_top_wi) = ls_header_detail-top_wi_id.
    IF lv_top_wi IS INITIAL.
      RETURN.
    ENDIF.

* Updates of the mapping table should only be done for the top work item
    IF lv_top_wi <> lv_wi.
      RETURN.
    ENDIF.

* Determine the change request. It is stored in the workflow container
    re_container = lo_workitem_context->get_wi_container( ).

  ENDMETHOD.


  METHOD get_wf_workitem_context.
    ro_workitem_context = cl_wapi_context_factory=>get_workitem_context( ).
  ENDMETHOD.


  METHOD validate_table.

*   Get the details of the DDIC table
    cl_abap_elemdescr=>describe_by_name(
    EXPORTING
      p_name         =  iv_tab_name                " Type name
      RECEIVING
      p_descr_ref    =  DATA(lo_strucdescr)                " Reference to description object
    EXCEPTIONS
      type_not_found = 1                " Type with name p_name could not be found
      OTHERS         = 2
      ).

* Check if input is a DDIC table
    IF lo_strucdescr IS BOUND AND sy-subrc = 0.
      rv_boolean =  lo_strucdescr->is_ddic_type( ).
    ELSE.
      CLEAR rv_boolean.
    ENDIF.

  ENDMETHOD.


  METHOD get_cr_changed_entity.

    IF io_changed_data IS INITIAL.
      DATA(lo_delta_buffer) =   get_cr_delta_buffer( ).

      IF lo_delta_buffer IS BOUND.
        lo_delta_buffer->get_entity_types( IMPORTING et_entity = rt_entity ).
      ENDIF.

    ELSE.
      io_changed_data->get_entity_types( IMPORTING et_entity = rt_entity ).
    ENDIF.

  ENDMETHOD.


  METHOD get_cr_delta_buffer.
    ro_instance = cl_usmd_delta_buffer=>get_instance( ).
  ENDMETHOD.


  METHOD set_parameter_value.

    FIELD-SYMBOLS: <lft_data>        TYPE ANY TABLE.
    FIELD-SYMBOLS: <lfs_data>        TYPE any.

    DATA lrt_data TYPE REF TO data.

    IF is_data IS NOT INITIAL AND it_data IS INITIAL.
      CREATE DATA lrt_data LIKE TABLE OF is_data.
      ASSIGN lrt_data->* TO <lft_data>.
      INSERT is_data INTO TABLE <lft_data>.
    ENDIF.

    IF it_data IS NOT INITIAL AND is_data IS INITIAL.
      ASSIGN it_data TO <lft_data>.
    ENDIF.

    IF iv_lead_selection IS NOT INITIAL.
      DATA(lv_lead_selection) = iv_lead_selection.
    ELSE.
      lv_lead_selection = 1.
    ENDIF.

    LOOP AT <lft_data> ASSIGNING FIELD-SYMBOL(<ls_data>).
      IF sy-tabix = lv_lead_selection.
        ASSIGN COMPONENT iv_component OF STRUCTURE <ls_data> TO FIELD-SYMBOL(<lv_value>).
        IF  <lv_value> IS ASSIGNED AND <lv_value> IS NOT INITIAL.
          SET PARAMETER ID iv_param_name FIELD <lv_value>.
          EXIT.
        ENDIF.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.


  METHOD yz_intf_usmd_pp_hana_search~adapt_sel_fields.

* entity types must not be marked as read-only even if all fields are read-only; reason is that dependent entity types
* might contain selectable fields

  field-symbols:
    <ls_sel_attribute> like line of ct_sel_attributes.

    set_reuse_mapping(
      EXPORTING
        iv_model =  iv_model                " Data Model
        iv_otc   =  iv_otc                " Business Object Type
    ).

    LOOP AT ct_sel_attributes ASSIGNING <ls_sel_attribute>.

***   adaptation for entities
      CASE <ls_sel_attribute>-entity_type .
        WHEN iv_main_entity. "for all fields of entity itself
          <ls_sel_attribute>-selected  = abap_true. "always in view
          <ls_sel_attribute>-read_only = abap_true. "not changeable
        WHEN OTHERS. "even other entities like for relations
          IF <ls_sel_attribute>-fieldname IS NOT INITIAL. "mark fields but not entities
            READ TABLE gt_reuse_fmap
              WITH KEY model           = iv_model
                       entity          = <ls_sel_attribute>-entity_type
                       model_fieldname = <ls_sel_attribute>-fieldname
              TRANSPORTING NO FIELDS.
            IF sy-subrc IS NOT INITIAL.
*           field is not in mapping
              <ls_sel_attribute>-selected  = abap_false. "not in view
              <ls_sel_attribute>-read_only = abap_true.  "not changeable
            ENDIF.
          ENDIF. "only fields
      ENDCASE.

***   adaptation for special fields
*   Authority group is needed for adaptation of the where_clause
*   Fieldname initial means the entity
*      IF <ls_sel_attribute>-entity_type = 'BP_CENTRL' AND
*       ( <ls_sel_attribute>-fieldname   = 'REF_CEN' OR <ls_sel_attribute>-fieldname IS INITIAL ).
*        <ls_sel_attribute>-selected  = abap_true. "always in view
*        <ls_sel_attribute>-read_only = abap_true. "not changeable
*      ENDIF.

    ENDLOOP.

  ENDMETHOD.


  METHOD yz_intf_usmd_pp_hana_search~adapt_result_list.

    DATA:
      lt_reuse_data         TYPE usmd_t_search_result,
      lt_staging_components TYPE abap_component_tab,
      lr_export_r_data      TYPE REF TO data.

    FIELD-SYMBOLS:
      <ls_staging_component> TYPE abap_componentdescr,
      <ls_reuse_fmap>        TYPE LINE OF gty_t_reuse_attr_map,
      <ls_reuse_data>        TYPE usmd_s_search_result,
      <ls_reuse_r_data>      TYPE any,
      <ls_export_data>       TYPE usmd_s_search_result,
      <ls_export_r_data>     TYPE any,
      <lv_export>            TYPE any,
      <lv_reuse>             TYPE any.

    CLEAR:et_data.
* determine fields for exporting structure from ir_staging_struct_type_ref
    lt_staging_components = ir_staging_struct_type_ref->get_components( ).

    IF it_reuse_data IS NOT INITIAL.
      lt_reuse_data = it_reuse_data.

      LOOP AT lt_reuse_data ASSIGNING <ls_reuse_data>.

        INSERT <ls_reuse_data> INTO TABLE et_data ASSIGNING <ls_export_data>.
        <ls_export_data>-f_active = '1'. "active
        CLEAR <ls_export_data>-r_data. "has to be filled with ref for staging

        ASSIGN <ls_reuse_data>-r_data->* TO <ls_reuse_r_data>.

        CREATE DATA lr_export_r_data TYPE HANDLE ir_staging_struct_type_ref.
        ASSIGN lr_export_r_data->* TO <ls_export_r_data>.

        LOOP AT lt_staging_components ASSIGNING <ls_staging_component>.
          CASE <ls_staging_component>-name .
            WHEN 'USMD_ACTIVE'.".gc_usmd_active.?
              ASSIGN COMPONENT <ls_staging_component>-name OF STRUCTURE <ls_export_r_data> TO <lv_export>.
              <lv_export> = 1.
            WHEN '_SCORE' .
              ASSIGN COMPONENT <ls_staging_component>-name OF STRUCTURE <ls_export_r_data> TO <lv_export>.
              CHECK sy-subrc IS INITIAL.
              ASSIGN COMPONENT <ls_staging_component>-name OF STRUCTURE <ls_reuse_r_data> TO <lv_reuse>.
              CHECK sy-subrc IS INITIAL.
              <lv_export> = <lv_reuse>.
            WHEN OTHERS.
              READ TABLE  gt_reuse_attr
                WITH KEY
                           model_fieldname = <ls_staging_component>-name "#EC WARNOK
                ASSIGNING <ls_reuse_fmap>.
              IF sy-subrc IS INITIAL.
                ASSIGN COMPONENT <ls_staging_component>-name OF STRUCTURE <ls_export_r_data> TO <lv_export>.
                CHECK sy-subrc IS INITIAL.
                IF <ls_reuse_fmap>-deviating_fieldname IS INITIAL.
                  ASSIGN COMPONENT <ls_reuse_fmap>-reuse_fieldname OF STRUCTURE <ls_reuse_r_data> TO <lv_reuse>.
                ELSE.
                  ASSIGN COMPONENT <ls_reuse_fmap>-deviating_fieldname OF STRUCTURE <ls_reuse_r_data> TO <lv_reuse>.
*TODO Error handling incase no staging component found for reuse,no provision to return messages
                ENDIF.
                CHECK sy-subrc IS INITIAL.
                <lv_export> = <lv_reuse>.
              ENDIF.

          ENDCASE.
        ENDLOOP.
        <ls_export_data>-r_data = lr_export_r_data.
      ENDLOOP.

* if number of input records after adaptation is not same as input count throw an error
      IF lines( et_data ) NE lines( it_reuse_data ).
        ASSERT 1 = 2.
      ENDIF.
    ELSE.
      lt_reuse_data = it_reuse_data_mdg_names.

      LOOP AT lt_reuse_data ASSIGNING <ls_reuse_data>.

        INSERT <ls_reuse_data> INTO TABLE et_data ASSIGNING <ls_export_data>.
        <ls_export_data>-f_active = '1'. "active
        CLEAR <ls_export_data>-r_data. "has to be filled with ref for staging

        ASSIGN <ls_reuse_data>-r_data->* TO <ls_reuse_r_data>.

        CREATE DATA lr_export_r_data TYPE HANDLE ir_staging_struct_type_ref.
        ASSIGN lr_export_r_data->* TO <ls_export_r_data>.

        LOOP AT lt_staging_components ASSIGNING <ls_staging_component>.
          CASE <ls_staging_component>-name .
            WHEN 'USMD_ACTIVE'."gc_usmd_active.?
              ASSIGN COMPONENT <ls_staging_component>-name OF STRUCTURE <ls_export_r_data> TO <lv_export>.
              <lv_export> = 1.
            WHEN '_SCORE' .
              ASSIGN COMPONENT <ls_staging_component>-name OF STRUCTURE <ls_export_r_data> TO <lv_export>.
              CHECK sy-subrc IS INITIAL.
              ASSIGN COMPONENT <ls_staging_component>-name OF STRUCTURE <ls_reuse_r_data> TO <lv_reuse>.
              CHECK sy-subrc IS INITIAL.
              <lv_export> = <lv_reuse>.
            WHEN OTHERS.
              ASSIGN COMPONENT <ls_staging_component>-name OF STRUCTURE <ls_export_r_data> TO <lv_export>.
              CHECK sy-subrc IS INITIAL.
              ASSIGN COMPONENT <ls_staging_component>-name OF STRUCTURE <ls_reuse_r_data> TO <lv_reuse>.
              CHECK sy-subrc IS INITIAL.
              <lv_export> = <lv_reuse>.
          ENDCASE.
        ENDLOOP.
        <ls_export_data>-r_data = lr_export_r_data.
      ENDLOOP.
* if number of input records after adaptation is not same as input count throw an error
      IF lines( et_data ) NE lines( it_reuse_data_mdg_names ).
        ASSERT 1 = 2.
      ENDIF.
    ENDIF.

  ENDMETHOD.


  METHOD yz_intf_usmd_pp_hana_search~adapt_where_clause.

*    FIELD-SYMBOLS : <ls_search_attributesa> TYPE usmd_s_sel.
*
*    DATA : lv_query_part TYPE string,
*           lv_entity     TYPE usmd_entity,
*           lv_tdobject   TYPE tdobject,
*           lv_tdid       TYPE tdid,
*           lv_tdobject_  TYPE string,
*           lv_tdid_      TYPE string,
*           lv_quote      TYPE c VALUE `'`,
*           lv_tdobject__ TYPE string,
*           lv_tdid__     TYPE string,
*           lv_separator  TYPE string,
*           lv_open       TYPE c VALUE '(',
*           lv_close      TYPE c VALUE ')'.
*
*    LOOP AT it_search_attributes ASSIGNING <ls_search_attributesa>.
*
*      CLEAR : lv_entity, lv_tdobject, lv_tdid, lv_tdid_, lv_tdid__, lv_tdobject_, lv_tdobject__.
*
*      CASE <ls_search_attributesa>-fieldname.
*        WHEN 'NOTEBSCDA'."gc_fieldname_notebscda."'NOTEBSCDA'.?
*          IF ( <ls_search_attributesa>-low IS NOT INITIAL ).
*            lv_entity = if_mdg_bs_mat_gen_c=>gc_entity_bscdattxt."'BSCDATTXT'.
*            lv_tdobject = if_mdg_bs_mat_gen_c=>gc_entity_material."'MATERIAL'.
*            lv_tdid = 'GRUN'.
*          ENDIF.
*
*        WHEN 'NOTEINTCM'.."gc_fieldname_noteintcm."'NOTEINTCM'.?
*          IF ( <ls_search_attributesa>-low IS NOT INITIAL ).
*            lv_entity = if_mdg_bs_mat_gen_c=>gc_entity_intcmnt."'INTCMNT'.
*            lv_tdobject = if_mdg_bs_mat_gen_c=>gc_entity_material."'MATERIAL'.
*            lv_tdid = 'IVER'.
*          ENDIF.
*
*"Similar cases commneted?
**        WHEN gc_fieldname_txtmrp."'TXTMRP'.
**          lv_entity = if_mdg_bs_mat_gen_c=>gc_entity_mrptxt."'MRPTXT'.
**          lv_tdobject = 'MDTXT'.
**          lv_tdid = 'LTXT'.
**
**        WHEN gc_fieldname_txtpurch. "'TXTPURCH'.
**          lv_entity = if_mdg_bs_mat_gen_c=>gc_entity_purchtxt."'PURCHTXT'.
**          lv_tdobject = if_mdg_bs_mat_gen_c=>gc_entity_material."'MATERIAL'
**          lv_tdid = 'BEST'.
**
**        WHEN gc_fieldname_txtqinsp."'TXTQINSP'.
**          lv_entity = if_mdg_bs_mat_gen_c=>gc_entity_qinsptxt."'QINSPTXT'.
**          lv_tdobject = if_mdg_bs_mat_gen_c=>gc_entity_material."'MATERIAL'.
**          lv_tdid = 'PRUE'.
**
**        WHEN gc_fieldname_txtsales ."'TXTSALES'.
**          lv_entity = if_mdg_bs_mat_gen_c=>gc_entity_salestxt."'SALESTXT'.
**          lv_tdobject = gc_table_mvke."'MVKE'.
**          lv_tdid = '0001'.
*
*        WHEN OTHERS.
*          DATA : lt_flex_attributes TYPE gty_t_reuse_attr_map,
*                 ls_flex_attributes TYPE LINE OF gty_t_reuse_attr_map.
*          CLEAR : ls_flex_attributes.
*          "Identify Flex and collect flex for handling Obsolete Flag
*          READ TABLE mt_flex_attributes INTO ls_flex_attributes WITH KEY model_fieldname = <ls_search_attributesa>-fieldname.
*          IF sy-subrc = 0.
*            "Check and insert
*            READ TABLE lt_flex_attributes TRANSPORTING NO FIELDS WITH KEY entity = ls_flex_attributes-entity.
*            IF sy-subrc <> 0.
*              INSERT ls_flex_attributes INTO TABLE lt_flex_attributes.
*            ENDIF.
*          ENDIF.
*          CONTINUE.
*
*      ENDCASE.
*
*      CHECK lv_entity IS NOT INITIAL.
*
**      CONCATENATE lv_entity '_' gc_fieldname_tdobject INTO lv_tdobject_."Commneted for below?
*      CONCATENATE lv_entity '_' 'TDOBJECT' INTO lv_tdobject_.
*      CONCATENATE lv_entity '_' if_mdg_bs_mat_gen_c=>gc_fieldname_tdid INTO lv_tdid_.
*
*      CONCATENATE lv_quote lv_tdobject lv_quote INTO lv_tdobject__.
*      CONCATENATE lv_quote lv_tdid lv_quote INTO lv_tdid__.
*
*      IF lv_query_part IS INITIAL.
*        lv_separator = space.
*      ELSE.
*        lv_separator = 'AND'.
*      ENDIF.
*
*      CONCATENATE lv_query_part lv_separator lv_open lv_tdobject_ '=' lv_tdobject__ lv_close
*                   'AND' lv_open lv_tdid_ '=' lv_tdid__ lv_close INTO lv_query_part SEPARATED BY space.
*
*    ENDLOOP.
*
*    " Begin Form query using flex ...
*
*    CLEAR ls_flex_attributes.
*    DATA: lv_query_part_flex        TYPE string,
*          lc_obsolete_condition     TYPE c VALUE 'X',
*          lv_obsolete_condition_    TYPE string,
*          lv_obsolete_field         TYPE string,
*          lv_usmd_active_field      TYPE string,
*          lc_usmd_active_condition  TYPE c VALUE '1',
*          lv_usmd_active_condition_ TYPE string.
*
*    CONCATENATE lv_quote lc_obsolete_condition lv_quote INTO lv_obsolete_condition_.
*    CONCATENATE lv_quote lc_usmd_active_condition lv_quote INTO lv_usmd_active_condition_.
*
*    " Handle Obsolete indicator
*    LOOP AT lt_flex_attributes INTO ls_flex_attributes.
*      CLEAR lv_obsolete_field.
*      CONCATENATE ls_flex_attributes-entity '_'  'USMD_O_' ls_flex_attributes-entity INTO lv_obsolete_field.
*
*      IF lv_query_part IS INITIAL.
*        lv_separator = space.
*      ELSE.
*        lv_separator = 'AND'.
*      ENDIF.
*
*      CONCATENATE lv_query_part lv_separator lv_open lv_obsolete_field '<>' lv_obsolete_condition_ lv_close
*                  INTO lv_query_part SEPARATED BY space.
*    ENDLOOP.
*    " Handle USMD_ACTIVE indicator
*    CLEAR ls_flex_attributes.
*
*    LOOP AT lt_flex_attributes INTO ls_flex_attributes.
*      CLEAR lv_usmd_active_field.
*      CONCATENATE ls_flex_attributes-entity  '_' 'USMD_ACTIVE'  INTO lv_usmd_active_field.
*
*      IF lv_query_part IS INITIAL.
*        lv_separator = space.
*      ELSE.
*        lv_separator = 'AND'.
*      ENDIF.
*
*      CONCATENATE lv_query_part lv_separator lv_open lv_usmd_active_field '=' lv_usmd_active_condition_ lv_close
*                  INTO lv_query_part SEPARATED BY space.
*    ENDLOOP.
*
*    " End Form query using flex ...
*
*    CHECK lv_query_part IS NOT INITIAL  .
*
*    CONCATENATE cv_where_clause 'AND' lv_query_part INTO cv_where_clause SEPARATED BY space.
  ENDMETHOD.


  METHOD yz_intf_usmd_pp_hana_search~get_mapping_info.

*! Get the mapping information of the re-use area.
    DATA:
      ls_message TYPE usmd_s_message.

    FIELD-SYMBOLS:
      <ls_reuse_fmap>   LIKE LINE OF gt_reuse_fmap,
      <ls_mapping_info> LIKE LINE OF ct_mapping_info.

    CLEAR et_messages.

    IF is_search_context-entity_main = get_cr_main_entity(
                                         iv_model              = iv_model
                                       ).
      set_reuse_mapping(
        EXPORTING
          iv_model =   iv_model               " Data Model
          iv_otc   =   iv_otc               " Business Object Type
      ).
    ELSE.
      MESSAGE e160(mdgbp) WITH is_search_context-entity_main INTO sy-ucomm.
      CLEAR ls_message.
      ls_message-msgid = 'MDGBP'.
      ls_message-msgty = 'E'.
      ls_message-msgno = '160'.
      ls_message-msgv1 = is_search_context-entity_main.
      APPEND ls_message TO et_messages.
      RETURN.
    ENDIF.

    "Add reuse field name
    LOOP AT ct_mapping_info ASSIGNING <ls_mapping_info>
      WHERE reuse_view_fieldname IS INITIAL.
      READ TABLE gt_reuse_fmap ASSIGNING <ls_reuse_fmap>
        WITH KEY model           = iv_model
                 entity          = <ls_mapping_info>-entity
                 model_fieldname = <ls_mapping_info>-model_fieldname.
      IF sy-subrc IS INITIAL.
        MOVE-CORRESPONDING <ls_reuse_fmap>   TO <ls_mapping_info>.
        IF <ls_reuse_fmap>-deviating_fieldname IS INITIAL.
          <ls_mapping_info>-reuse_view_fieldname = <ls_reuse_fmap>-reuse_fieldname.
        ELSE.
          <ls_mapping_info>-reuse_view_fieldname = <ls_reuse_fmap>-deviating_fieldname.
        ENDIF.
      ELSE.
        IF <ls_mapping_info>-entity = if_mdg_bp_constants=>gc_bp_model_entity-bp
          AND <ls_mapping_info>-model_fieldname EQ 'TXTLG'.
          "BP description - no message
          CONTINUE.
        ELSE.
          MESSAGE e161(mdgbp) WITH <ls_mapping_info>-model_fieldname <ls_mapping_info>-entity INTO sy-ucomm.
          CLEAR ls_message.
          ls_message-msgid = 'MDGBP'.
          ls_message-msgty = 'E'.
          ls_message-msgno = '161'.
          ls_message-msgv1 = <ls_mapping_info>-model_fieldname.
          ls_message-msgv2 = <ls_mapping_info>-entity.
          APPEND ls_message TO et_messages.
        ENDIF.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.


  METHOD yz_intf_usmd_pp_hana_search~get_reuse_view_content.

*! Get the re-use view content for the requested entities / model attributes.
    DATA:
      lv_keyflag          TYPE c,
      ls_message          TYPE usmd_s_message,
      lt_reuse_table      TYPE tty_reuse_table,
      ls_reuse_table      LIKE LINE OF lt_reuse_table,
      ls_reuse_attributes LIKE LINE OF et_reuse_attributes,
      lt_reuse_attributes LIKE et_reuse_attributes,
      lv_dp_status_check  TYPE boole-boole.

    FIELD-SYMBOLS:
      <ls_model_attributes> LIKE LINE OF it_model_attributes,
      <ls_reuse_fmap>       LIKE LINE OF gt_reuse_fmap,
      <ls_reuse_attributes> LIKE LINE OF et_reuse_attributes.

    CLEAR:
      ev_main_table,
      et_join_conditions,
      et_reuse_attributes,
      et_messages.

    IF iv_main_entity EQ get_cr_main_entity(
                           iv_model              = iv_model
                         ).
      set_reuse_mapping(
        EXPORTING
          iv_model =   iv_model               " Data Model
          iv_otc   =   iv_otc               " Business Object Type
      ).
    ELSE.
      MESSAGE e160(mdgbp) WITH iv_main_entity INTO sy-ucomm.
      CLEAR ls_message.
      ls_message-msgid = 'MDGBP'.
      ls_message-msgty = 'E'.
      ls_message-msgno = '160'.
      ls_message-msgv1 = iv_main_entity.
      APPEND ls_message TO et_messages.
      RETURN.
    ENDIF.

    ev_main_table = iv_main_table.


    LOOP AT it_model_attributes ASSIGNING <ls_model_attributes>.
      READ TABLE gt_reuse_fmap ASSIGNING <ls_reuse_fmap>
        WITH KEY model           = iv_model
                 entity          = <ls_model_attributes>-usmd_entity
                 model_fieldname = <ls_model_attributes>-fieldname.
      IF sy-subrc IS INITIAL.
        ls_reuse_table-table = <ls_reuse_fmap>-reuse_table.
        INSERT ls_reuse_table INTO TABLE lt_reuse_table.
        CLEAR ls_reuse_attributes.
        MOVE-CORRESPONDING <ls_reuse_fmap> TO ls_reuse_attributes.
        ls_reuse_attributes-rollname = <ls_reuse_fmap>-reuse_rollname.
        INSERT ls_reuse_attributes INTO TABLE et_reuse_attributes.
      ELSE.
        IF <ls_model_attributes>-usmd_entity EQ get_cr_main_entity(
                                                  iv_model              = iv_model
                                                )
          AND <ls_model_attributes>-fieldname EQ 'TXTLG'. "BP description
          "no message for description field
          CONTINUE.
        ELSE.
          MESSAGE e161(mdgbp) WITH <ls_model_attributes>-fieldname <ls_model_attributes>-usmd_entity INTO sy-ucomm.
          CLEAR ls_message.
          ls_message-msgid = 'MDGBP'.
          ls_message-msgty = 'E'.
          ls_message-msgno = '161'.
          ls_message-msgv1 = <ls_model_attributes>-fieldname.
          ls_message-msgv2 = <ls_model_attributes>-usmd_entity.
          APPEND ls_message TO et_messages.
        ENDIF.
      ENDIF.
    ENDLOOP.

    "set key flags
    LOOP AT et_reuse_attributes ASSIGNING <ls_reuse_attributes>.
      SELECT SINGLE keyflag FROM dd03l INTO lv_keyflag
        WHERE tabname   = <ls_reuse_attributes>-reuse_table
          AND fieldname = <ls_reuse_attributes>-reuse_fieldname.
      IF sy-subrc IS INITIAL.
        <ls_reuse_attributes>-is_key = lv_keyflag.
      ENDIF.
    ENDLOOP.

    "prepare result
    INSERT LINES OF lt_reuse_attributes INTO TABLE et_reuse_attributes.
    SORT et_reuse_attributes BY reuse_table reuse_fieldname.
    DELETE ADJACENT DUPLICATES FROM et_reuse_attributes.

    "get join conditions
    IF lt_reuse_table IS NOT INITIAL.
      et_join_conditions = get_join_conditions( it_reuse_table = lt_reuse_table ).
    ENDIF.

  ENDMETHOD.


  METHOD yz_intf_usmd_pp_hana_search~merge_reuse_authorization.

*    DATA:
*      lt_values        TYPE TABLE OF usvalues,
*      lv_exception     LIKE sy-subrc,
*      lv_auth_relevent TYPE boolean VALUE abap_true.
*
*    FIELD-SYMBOLS:
*      <fs_auth_object> TYPE ty_s_auth_object,
*      <fs_auth_field>  TYPE ty_s_xufield,
*      <fs_reuse_attr>  TYPE gty_s_reuse_attr_map.
*
*    CLEAR:et_auth_attributes,ev_no_authorization.
*
**Fetch all the authorization objects that are needed
*    CALL METHOD add_auth_objects( ).
*
*    LOOP AT mt_auth_object ASSIGNING <fs_auth_object>.
*
**Few Authorization are relevant only in cases where their auth fields are part of the input search criteria
*      IF <fs_auth_object>-input_dep = abap_true.
*        lv_auth_relevent  = abap_false.
*        LOOP AT <fs_auth_object>-auth_fields ASSIGNING <fs_auth_field>.
*          READ TABLE gt_reuse_attr ASSIGNING <fs_reuse_attr> WITH KEY entity = <fs_auth_field>-entity
*          model_fieldname = <fs_auth_field>-model_fieldname.
*          IF sy-subrc IS INITIAL. "ERROR CASE NEEDS TO BE DONE
*            IF <fs_reuse_attr>-deviating_fieldname IS NOT INITIAL.
*              READ TABLE ct_search_attributes WITH KEY fieldname = <fs_reuse_attr>-deviating_fieldname
*              TRANSPORTING NO FIELDS .
*            ELSE.
*              READ TABLE ct_search_attributes WITH KEY fieldname = <fs_reuse_attr>-reuse_fieldname
*              TRANSPORTING NO FIELDS .
*            ENDIF.
*            IF sy-subrc IS INITIAL.
*              lv_auth_relevent  = abap_true.
*              EXIT.
*            ENDIF.
*          ELSEIF <fs_auth_field>-model_fieldname = 'CLASSTYPE'."generic field?
*            READ TABLE ct_search_attributes WITH KEY fieldname = 'KSSK_KLART' "generic field?
*            TRANSPORTING NO FIELDS .
*            IF sy-subrc = 0.
*              lv_auth_relevent  = abap_true.
*              EXIT.
*            ENDIF.
*          ENDIF.
*        ENDLOOP.
*      ENDIF.
*
*      IF lv_auth_relevent = abap_true .
*        CALL METHOD get_user_master_records
*          EXPORTING
*            iv_user_name  = sy-uname
*            iv_sel_object = <fs_auth_object>-auth_object
*          IMPORTING
*            et_values     = lt_values
*            ev_exception  = lv_exception.
*
**User Master records from the previous step are used to form the selection attributes
*        CALL METHOD get_auth_sel_attributes
*          EXPORTING
*            it_values           = lt_values
*            is_auth_data        = <fs_auth_object>
*          IMPORTING
*            ev_no_authorization = ev_no_authorization
*          CHANGING
*            ct_auth_attributes  = et_auth_attributes.
*
*        IF ev_no_authorization = abap_true.
**TODO:Formulate proper error message
*          RETURN.
*        ENDIF.
*      ENDIF.
*
*      lv_auth_relevent = abap_true.
*    ENDLOOP.

  ENDMETHOD.


METHOD adapt_join_condition.

"Only for material?
*  DATA:
*    ls_tcurm            TYPE tcurm,
*    ls_join_condition   TYPE mdg_hdb_s_xml_join_table,
*    ls_join_column      TYPE mdg_hdb_s_xml_join_column,
*    lt_column_mara_marc TYPE mdg_atv_xml_join_column_tty,
*    lt_column_table     TYPE mdg_atv_xml_join_column_tty.
*
*  FIELD-SYMBOLS:
*                 <fs_join_condition> TYPE mdg_hdb_s_xml_join_table.
*
*  CALL FUNCTION 'TCURM_SINGLE_READ'
*    EXPORTING
*      kzrfb                   = 'X'
*    IMPORTING
*      wtcurm                  = ls_tcurm
*    EXCEPTIONS
*      not_found               = 1
*      valuation_level_initial = 2
*      valuation_level_wrong   = 3
*      OTHERS                  = 4.
*  IF sy-subrc <> 0.
** Implement suitable error handling here
*  ENDIF.
*
**If the valuation is set for plants then join condition is mara-marc-mbew else it is mara-mbew
*  IF ls_tcurm-bwkrs_cus = '1' OR ls_tcurm-bwkrs_cus = '2'  .
*
*    READ TABLE ct_join_conditions ASSIGNING <fs_join_condition> WITH KEY
*    left_table = if_mdg_bs_mat_gen_c=>gc_objtype_mara right_table = gc_table_mbew.
*
*    IF sy-subrc = 0.
*
*      ls_join_column-left_field = if_mdg_bs_mat_gen_c=>gc_attr_werks."'WERKS'.
*      ls_join_column-right_field = if_mdg_bs_mat_gen_c=>gc_attr_bwkey."'BWKEY'.
*      INSERT ls_join_column INTO TABLE lt_column_table.
*
*      INSERT LINES OF <fs_join_condition>-t_col INTO TABLE lt_column_table.
*      INSERT LINES OF <fs_join_condition>-t_col INTO TABLE lt_column_mara_marc.
*      ls_join_condition-cardinality = <fs_join_condition>-cardinality.
*      ls_join_condition-joinoperator = <fs_join_condition>-joinoperator.
*      ls_join_condition-jointype = <fs_join_condition>-jointype.
*      ls_join_condition-left_table = gc_table_marc."'MARC'.
*      ls_join_condition-right_table = <fs_join_condition>-right_table.
*      ls_join_condition-t_col = lt_column_table.
*
*      DELETE TABLE ct_join_conditions FROM <fs_join_condition>.
*
*      INSERT ls_join_condition INTO TABLE ct_join_conditions.
*
** If the Evaluation is done on the Plant level then MARC table as to be included as part of the view if it is not part of selection
*      READ TABLE ct_join_conditions WITH KEY left_table = if_mdg_bs_mat_gen_c=>gc_objtype_mara
*      right_table = gc_table_marc TRANSPORTING NO FIELDS .
*
*      IF sy-subrc <> 0.
*        CLEAR:ls_join_condition.
*        ls_join_condition-cardinality = gc_join_card_1_n.
*        ls_join_condition-joinoperator = gc_join_operator_equal.
*        ls_join_condition-jointype = gc_join_type_leftouter.
*        ls_join_condition-left_table = if_mdg_bs_mat_gen_c=>gc_objtype_mara.
*        ls_join_condition-right_table = gc_table_marc."'MARC'.
*        ls_join_condition-t_col = lt_column_mara_marc.
*        INSERT ls_join_condition INTO TABLE ct_join_conditions.
*      ENDIF.
*
*    ENDIF.
*
*
*  ENDIF.


ENDMETHOD.


METHOD add_auth_objects.

*Below Added Attributes has to be pre-selected and made read-only during generation

  DATA:
    ls_auth       TYPE ty_s_auth_object,
    ls_auth_field TYPE ty_s_xufield.

  CLEAR: mt_auth_object.

*  commented
**M_MATE_MAT?
*  ls_auth-auth_object = gc_auth_objects-m_mate_mat.  "              'M_MATE_MAT'.
*  ls_auth_field-field = gc_auth_field_begru.
*  ls_auth_field-entity = gc_entity_material.
*  ls_auth_field-model_fieldname = gc_auth_field_begru.
*  APPEND ls_auth_field TO ls_auth-auth_fields.
*
*  CLEAR:ls_auth_field.
*
*  ls_auth_field-field = gc_auth_fields-actvt.
*  APPEND ls_auth_field TO ls_auth-auth_fields.
*  INSERT ls_auth INTO TABLE mt_auth_object.
*
**M_MATE_MAR?
*  CLEAR:ls_auth,ls_auth_field.
*  ls_auth-auth_object = gc_auth_objects-m_mate_mar .                 "'M_MATE_MAR'.
*  ls_auth_field-field = gc_auth_fields-begru.
*  ls_auth_field-tab_name = gc_auth_table_t134.
*  ls_auth_field-tab_field_name = gc_auth_tabf_mtart.
*  ls_auth_field-entity = gc_entity_material.
*  ls_auth_field-model_fieldname = gc_auth_tabf_mtart.
*  APPEND ls_auth_field TO ls_auth-auth_fields.
*
*  CLEAR:ls_auth_field.
*
*  ls_auth_field-field = gc_auth_fields-actvt.
*  APPEND ls_auth_field TO ls_auth-auth_fields.
*  INSERT ls_auth INTO TABLE mt_auth_object.
*
**M_MATE_MAN?
*  CLEAR:ls_auth,ls_auth_field.
*  ls_auth-auth_object = gc_auth_obj_mate_man.
*  ls_auth_field-field = gc_auth_fields-actvt.
*  APPEND ls_auth_field TO ls_auth-auth_fields.
*  INSERT ls_auth INTO TABLE mt_auth_object.
*
*
** M_MATE_WGR?
*  CLEAR:ls_auth,ls_auth_field.
*  ls_auth-auth_object = gc_auth_objects-m_mate_wgr .
*  ls_auth-input_dep = 'X'.                "'M_MATE_MAR'.
*  ls_auth_field-field = gc_auth_fields-begru.
*  ls_auth_field-tab_name = gc_auth_table_t023.
*  ls_auth_field-tab_field_name =  gc_auth_tabf_matkl.
*  ls_auth_field-entity = gc_entity_material.
*  ls_auth_field-model_fieldname = gc_auth_tabf_matkl.
*  APPEND ls_auth_field TO ls_auth-auth_fields.
*
*  CLEAR:ls_auth_field.
*
*  ls_auth_field-field = gc_auth_fields-actvt.
*  APPEND ls_auth_field TO ls_auth-auth_fields.
*  INSERT ls_auth INTO TABLE mt_auth_object.
*
*
**M_MATE_STA
**  ls_auth-auth_object = gc_auth_objects-m_mate_sta.  "              'M_MATE_MAT'.
**  ls_auth_field-field =  gc_auth_fields-statm.
**  ls_auth_field-entity = gc_entity_material.
**  ls_auth_field-model_fieldname = gc_auth_field_begru.
**  APPEND ls_auth_field TO ls_auth-auth_fields.
**  APPEND ls_auth TO mt_auth_object.
*
**M_MATE_WRK?
*  CLEAR:ls_auth,ls_auth_field.
*  ls_auth-auth_object = gc_auth_objects-m_mate_wrk.  "              'M_MATE_MAT'.
*  ls_auth-input_dep = 'X'.
*  ls_auth_field-field = gc_auth_fields-werks.
*  ls_auth_field-entity = gc_auth_entities-marcbasic.
*  ls_auth_field-model_fieldname = gc_auth_fields-werks.
*  APPEND ls_auth_field TO ls_auth-auth_fields.
*
*  CLEAR:ls_auth_field.
*
*  ls_auth_field-field = gc_auth_fields-actvt.
*  APPEND ls_auth_field TO ls_auth-auth_fields.
*  INSERT ls_auth INTO TABLE mt_auth_object.
*
**M_MATE_BUK
**   ls_auth-auth_object = gc_auth_objects-M_MATE_BUK.  "              'M_MATE_MAT'.
**  ls_auth_field-field = gc_auth_fields-bukrs.
**  ls_auth_field-entity = 'MARCBASIC'.
**  ls_auth_field-model_fieldname = gc_auth_fields-werks.
**  APPEND ls_auth_field TO ls_auth-auth_fields.
**  APPEND ls_auth TO mt_auth_object.
*
**  M_MATE_VKO?
*  CLEAR:ls_auth,ls_auth_field.
*  ls_auth-auth_object = gc_auth_objects-m_mate_vko.
*  ls_auth-input_dep = 'X'.
*  ls_auth_field-field = gc_auth_fields-vkorg.
*  ls_auth_field-entity = gc_auth_entities-mvkesales.
*  ls_auth_field-model_fieldname = gc_auth_fields-vkorg.
*  APPEND ls_auth_field TO ls_auth-auth_fields.
*
*  CLEAR:ls_auth_field.
*
*  ls_auth_field-field = gc_auth_fields-vtweg.
*  ls_auth_field-entity = gc_auth_entities-mvkesales.
*  ls_auth_field-model_fieldname = gc_auth_fields-vtweg.
*  APPEND ls_auth_field TO ls_auth-auth_fields.
*
*  CLEAR:ls_auth_field.
*  ls_auth_field-field = gc_auth_fields-actvt.
*  APPEND ls_auth_field TO ls_auth-auth_fields.
*  INSERT ls_auth INTO TABLE mt_auth_object.
*
**M_MATE_LGN
*  CLEAR:ls_auth,ls_auth_field.
*  ls_auth-auth_object = gc_auth_objects-m_mate_lgn.  "              'M_MATE_MAT'.
*  ls_auth-input_dep = 'X'.
*  ls_auth_field-field = gc_auth_fields-lgnum.
*  ls_auth_field-entity = gc_auth_entities-mlgtstor.
*  ls_auth_field-model_fieldname = gc_auth_fields-lgnum.
*  APPEND ls_auth_field TO ls_auth-auth_fields.
*
*  CLEAR:ls_auth_field.
*  ls_auth_field-field = gc_auth_fields-actvt.
*  APPEND ls_auth_field TO ls_auth-auth_fields.
*  INSERT ls_auth INTO TABLE mt_auth_object.
*
**C_TCLA_BKA
*  CLEAR:ls_auth,ls_auth_field.
*
*
*  ls_auth-auth_object = gc_auth_objects-c_tcla_bka.  "              .
*  ls_auth-input_dep = 'X'.
*  ls_auth_field-field = gc_auth_fields-klart.
*  ls_auth_field-entity = gc_auth_entities-valuation.
*  ls_auth_field-model_fieldname = gc_field_classtype.
*  APPEND ls_auth_field TO ls_auth-auth_fields.
*  INSERT ls_auth INTO TABLE mt_auth_object.

ENDMETHOD.


  METHOD create_attribute_range_table.

    FIELD-SYMBOLS   <ft_data>      TYPE STANDARD TABLE.

    DATA(lv_source) = '@IT_DATA'.

    DATA(lr_data) = create_range_table( iv_data = ir_table_field ) .
    ASSIGN lr_data->* TO <ft_data>.

    CHECK <ft_data> IS ASSIGNED.

    DATA(lv_field) = |'I'  AS SIGN, 'EQ' AS OPTION, { IV_ATTRIBUTE } AS LOW, ` ` AS HIGH |.

    TRY .
        SELECT (lv_field) FROM (lv_source) AS itab INTO TABLE @<ft_data> .
      CATCH cx_sy_dynamic_osql_semantics INTO DATA(lo_error).
        DATA(lv_error) = lo_error->get_text( ).
    ENDTRY.

    er_data = lr_data.

  ENDMETHOD.


  METHOD create_range_table.

    DATA:
      lr_sign_descr   TYPE REF TO cl_abap_elemdescr,
      lr_option_descr TYPE REF TO cl_abap_elemdescr,
      lr_value_descr  TYPE REF TO cl_abap_elemdescr,
      lr_struct_descr TYPE REF TO cl_abap_structdescr,
      lr_table_descr  TYPE REF TO cl_abap_tabledescr,
      component       TYPE cl_abap_structdescr=>component,
      lt_components   TYPE cl_abap_structdescr=>component_table.

    lr_sign_descr   ?= cl_abap_elemdescr=>describe_by_name( 'DDSIGN' ).
    lr_option_descr ?= cl_abap_elemdescr=>describe_by_name( 'DDOPTION' ).

    IF iv_data IS NOT INITIAL.
      lr_value_descr ?= cl_abap_elemdescr=>describe_by_data_ref( p_data_ref = iv_data ).
    ELSE.

    CASE i_typename.
      WHEN 'N'.
        lr_value_descr ?= cl_abap_elemdescr=>get_n( p_length = i_length ).
      WHEN 'C'.
        lr_value_descr ?= cl_abap_elemdescr=>get_c( p_length = i_length ).
      WHEN 'X'.
        lr_value_descr ?= cl_abap_elemdescr=>get_x( p_length = i_length ).
      WHEN 'P'.
        lr_value_descr ?= cl_abap_elemdescr=>get_p( p_length = i_length p_decimals = i_decimals ).
      WHEN OTHERS.
        lr_value_descr ?= cl_abap_elemdescr=>describe_by_name( i_typename ).
    ENDCASE.
    ENDIF.

    component-name = 'SIGN'.
    component-type = lr_sign_descr.
    INSERT component INTO TABLE lt_components.

    component-name = 'OPTION'.
    component-type = lr_option_descr.
    INSERT component INTO TABLE lt_components.

    component-name = 'LOW'.
    component-type = lr_value_descr.
    INSERT component INTO TABLE lt_components.

    component-name = 'HIGH'.
    component-type = lr_value_descr.
    INSERT component INTO TABLE lt_components.

    lr_struct_descr = cl_abap_structdescr=>create( p_components = lt_components p_strict = abap_true ).
    lr_table_descr  = cl_abap_tabledescr=>create( p_line_type = lr_struct_descr ).

    CREATE DATA rt_range_table TYPE HANDLE lr_table_descr.

  ENDMETHOD.


METHOD get_auth_sel_attributes.

  DATA:
    ls_sel          TYPE usmd_s_sel,
    lt_sel_op       TYPE RANGE OF usmd_fieldname,
    ls_sel_op       LIKE LINE OF lt_sel_op,
    ls_reuse_attr   TYPE gty_s_reuse_attr_map,
    lr_data         TYPE REF TO data,
    lr_line         TYPE REF TO data,
    lv_where_clause TYPE string,
    lx_exc          TYPE REF TO cx_sy_dynamic_osql_semantics,
    lv_txt          TYPE string.

  FIELD-SYMBOLS: <fs_values>     TYPE  usvalues,
                 <fs_auth_field> TYPE ty_s_xufield,
                 <fs_table>      TYPE ANY TABLE,
                 <fs_line>       TYPE any,
                 <fs_component>  TYPE any.

  CLEAR:ev_no_authorization.

*  LOOP AT is_auth_data-auth_fields ASSIGNING <fs_auth_field>.
  LOOP AT it_values ASSIGNING <fs_values>.
*Read the User Master Record for the corresponding auth field
    READ TABLE is_auth_data-auth_fields ASSIGNING <fs_auth_field> WITH KEY field = <fs_values>-field.
    IF sy-subrc = 0.   " not intial, incorrect auth fields values added in add_auth_object
      IF <fs_auth_field>-field = 'ACTVT'.
        AUTHORITY-CHECK OBJECT is_auth_data-auth_object
                 ID 'ACTVT' FIELD '03'."gc_aktyp-display."Should be maintained?

        IF sy-subrc <> 0.
* Implement a suitable exception handling here
          ev_no_authorization  = abap_true.
          RETURN.
        ENDIF.
      ELSE.
        CLEAR ls_sel.
*Read the Mapping info to form the select options using reuse names
        READ TABLE gt_reuse_attr INTO ls_reuse_attr WITH KEY model_fieldname = <fs_auth_field>-model_fieldname
        entity = <fs_auth_field>-entity.
        IF sy-subrc IS INITIAL .
          IF ls_reuse_attr-deviating_fieldname IS NOT INITIAL.
            ls_sel-fieldname = ls_reuse_attr-deviating_fieldname.
          ELSE.
            ls_sel-fieldname = ls_reuse_attr-reuse_fieldname.
          ENDIF.
*Handling specific to Classification
        ELSEIF <fs_auth_field>-model_fieldname = 'CLASSTYPE'."?
          ls_sel-fieldname = 'KSSK_KLART'."?
        ENDIF.

*Form the abap select option from the User Master Records for ABAP open SQL quering
*This is relevant in cases where the User Master Records are not the restriction criteria but
*the entries from other tables(T134,T023) based on the User Master Recors
        IF <fs_auth_field>-tab_field_name IS NOT INITIAL AND <fs_auth_field>-tab_name IS NOT INITIAL.

          ls_sel_op-sign = 'I'.
          IF <fs_values>-von CA '*+'.
            ls_sel_op-option = 'CP'.
          ELSE.
            IF <fs_values>-bis IS INITIAL.
              ls_sel_op-option = 'EQ'.
            ELSE.
              ls_sel_op-option = 'BT'.
            ENDIF.
          ENDIF.
          ls_sel_op-low = <fs_values>-von.
          ls_sel_op-high      = <fs_values>-bis.
          INSERT ls_sel_op INTO TABLE lt_sel_op.
*Table and Structure to hold the SQL query output
          CREATE DATA lr_data TYPE TABLE OF (<fs_auth_field>-tab_name).
          CREATE DATA lr_line TYPE (<fs_auth_field>-tab_name).
          IF lr_data IS BOUND.
            ASSIGN lr_data->* TO <fs_table>.
            CONCATENATE <fs_auth_field>-field 'IN' 'lt_sel_op' INTO lv_where_clause SEPARATED BY space.
*            dynamic ABAP Open SQL Query
            TRY .
                SELECT * INTO TABLE <fs_table> FROM (<fs_auth_field>-tab_name) WHERE (lv_where_clause) .
              CATCH cx_sy_dynamic_osql_semantics INTO lx_exc.
                lv_txt = lx_exc->where_clause.
            ENDTRY.
            ASSIGN lr_line->* TO <fs_line>.
            ls_sel-sign = 'I'.
            ls_sel-option = 'EQ'.
            LOOP AT <fs_table> ASSIGNING <fs_line> .
              ASSIGN COMPONENT <fs_auth_field>-tab_field_name OF STRUCTURE <fs_line> TO <fs_component>.
              IF sy-subrc IS INITIAL.
                ls_sel-low = <fs_component>.
                INSERT ls_sel INTO TABLE ct_auth_attributes.
              ENDIF.
            ENDLOOP.
          ENDIF.
        ELSEIF <fs_values>-von NE '*'.
*Incase when the there is no dependency on tables
          ls_sel-sign      = 'I'.
          IF <fs_values>-von CA '*+'.
            ls_sel-option    = 'CP'.
          ELSE.
            IF <fs_values>-bis IS INITIAL.
              ls_sel-option    = 'EQ'.
            ELSE.
              ls_sel-option    = 'BT'.
            ENDIF.
          ENDIF.
          ls_sel-low       = <fs_values>-von.
          ls_sel-high      = <fs_values>-bis.
          INSERT ls_sel INTO TABLE ct_auth_attributes.
        ENDIF.
      ENDIF.
*    ENDLOOP.
    ELSE.
*TODO: ERROR HANDLING INCASE NO AUTH FIELS PRESENT
    ENDIF.
  ENDLOOP.


ENDMETHOD.


METHOD get_entity_details.

  DATA:
    ls_data            TYPE tys_data_2pp,
    ls_fmap            TYPE mdg_hdb_s_pp_fmap,
    ls_reuse_attribute TYPE   gty_s_reuse_attr_map,
    lt_result          TYPE STANDARD TABLE OF string,
    lt_dfies           TYPE STANDARD TABLE OF dfies,
    ls_dfies           TYPE dfies,
    lt_used_tables     TYPE tty_reuse_table,
    lv_table           TYPE char30,
    lv_string          TYPE string,
    lt_no_mapping      TYPE usmd_ts_entity_fieldname,
    lv_to_field        TYPE string.


  FIELD-SYMBOLS:
    <fs_reuse_attribute> TYPE gty_s_reuse_attr_map,
    <fs_attribute>       TYPE usmd_s_entity_fieldname.

* Fetch mapping data if it is initial
  IF gt_mapping IS INITIAL.

    CALL METHOD get_mapping
      EXPORTING
        iv_model = iv_model.

  ENDIF.

*TODO Error Handling has to be done incase of error
  READ TABLE et_messages WITH KEY msgty = 'E' TRANSPORTING NO FIELDS .

*  IF sy-subrc = 0.
*
*    RETURN.
*
*  ELSE.
*Loop through the SMT mapping and fetch the required mappings by spliting the SMT structure that has the Re-use Table name
  LOOP AT it_model_attributes ASSIGNING <fs_attribute> .

    READ TABLE gt_mapping INTO ls_data WITH KEY entity = <fs_attribute>-usmd_entity
    from_field = <fs_attribute>-fieldname .

    IF ( sy-subrc = 0 AND ls_data-to_field IS NOT INITIAL AND "changes below?
      (
        <fs_attribute>-usmd_entity <>  if_mdg_bs_mat_gen_c=>gc_entity_bscdattxt
         AND <fs_attribute>-usmd_entity <> if_mdg_bs_mat_gen_c=>gc_entity_mrptxt    AND <fs_attribute>-usmd_entity <> if_mdg_bs_mat_gen_c=>gc_entity_salestxt
         AND <fs_attribute>-usmd_entity <> if_mdg_bs_mat_gen_c=>gc_entity_mpgdprodg AND <fs_attribute>-usmd_entity <> if_mdg_bs_mat_gen_c=>gc_entity_intcmnt
         AND <fs_attribute>-usmd_entity <> if_mdg_bs_mat_gen_c=>gc_entity_purchtxt  AND <fs_attribute>-usmd_entity <> if_mdg_bs_mat_gen_c=>gc_entity_qinsptxt
         AND <fs_attribute>-usmd_entity <> if_mdg_bs_mat_gen_c=>gc_entity_mlanpurch AND <fs_attribute>-usmd_entity <> if_mdg_bs_mat_gen_c=>gc_entity_mlansales )

       ) .

      ls_reuse_attribute-model_fieldname = ls_data-from_field.
      SPLIT ls_data-tstructure AT '_S_' INTO TABLE lt_result.
      READ TABLE lt_result INTO lv_table INDEX 2.

      "Pick only entries whose table can be identified"Expand table list?
      IF  ( sy-subrc <> 0 ) OR ( ( lv_table <> 'MARA' ) AND ( lv_table <> 'MARC' ) AND ( lv_table <> 'MARD' )
        AND ( lv_table <> 'MAKT' ) AND ( lv_table <> 'MVKE' ) AND ( lv_table <> 'MBEW' ) AND ( lv_table <> 'MARM' )
        AND  ( lv_table <> 'MLGN' ) AND ( lv_table <> 'MEAN' ) AND ( lv_table <> 'MLGT' ) ).
        APPEND <fs_attribute> TO lt_no_mapping.
        CONTINUE.
      ENDIF.

      ls_reuse_attribute-reuse_table = lv_table .
      IF ( ls_data-to_field CA '/').
        DATA : to_field(40) TYPE c.
        to_field = ls_data-to_field.
        REPLACE ALL OCCURRENCES OF '/' IN to_field WITH '_'.
        CONCATENATE lv_table to_field INTO lv_string.
      ELSE.
        CONCATENATE lv_table '_' ls_data-to_field INTO lv_string.
      ENDIF.
      ls_reuse_attribute-reuse_fieldname = ls_data-to_field.

      ls_reuse_attribute-deviating_fieldname = lv_string.

      ls_reuse_attribute-entity = <fs_attribute>-usmd_entity.

      APPEND ls_reuse_attribute TO et_reuse_attributes.

    ELSE.

      APPEND <fs_attribute> TO lt_no_mapping.
    ENDIF.

  ENDLOOP.

  " fill entities : Need for get mapping info called from Search
  IF mt_entities IS INITIAL.
    LOOP AT it_model_attributes ASSIGNING <fs_attribute>.
      READ TABLE mt_entities TRANSPORTING NO FIELDS WITH KEY  table_line =  <fs_attribute>-usmd_entity.
      CHECK sy-subrc <> 0.
      APPEND <fs_attribute>-usmd_entity TO mt_entities.
    ENDLOOP.
  ENDIF.

  " Get flex entity attributes

*  get_flex_attributes(
*    CHANGING
*      ct_no_mapping       =     lt_no_mapping" Field Names of Entity Type
*  ).

*TO DO: Error Handling if there are no mappings available, needs to be handeled and passed to the interface
*----------------------------------------PERFROMANCE CHECK---------------------------------------------------------------

  IF lt_no_mapping IS NOT INITIAL.

    IF mt_fmap IS INITIAL.
*      mt_fmap = cl_mdg_hdb_reuse_mapping=>get_field_mapping( gc_model_mm ).
      mt_fmap = cl_mdg_hdb_reuse_mapping=>get_field_mapping( gc_model )."temp?
    ENDIF.

    LOOP AT lt_no_mapping ASSIGNING <fs_attribute>.

      READ TABLE mt_fmap INTO ls_fmap WITH KEY model_fieldname = <fs_attribute>-fieldname
      entity = <fs_attribute>-usmd_entity.

      IF sy-subrc = 0.
        ls_reuse_attribute-reuse_table =  ls_fmap-reuse_table.
        ls_reuse_attribute-reuse_fieldname = ls_fmap-reuse_fieldname.
        ls_reuse_attribute-rollname = ls_fmap-reuse_rollname.
        ls_reuse_attribute-model_fieldname = ls_fmap-model_fieldname.
        ls_reuse_attribute-entity = ls_fmap-entity.
        ls_reuse_attribute-deviating_fieldname = ls_fmap-deviating_fieldname.
        ls_reuse_attribute-deviating_fieldtext = ls_fmap-deviating_fieldtext.
        APPEND ls_reuse_attribute TO et_reuse_attributes.
      ENDIF.

    ENDLOOP.
  ENDIF.
*----------------------------------------PERFROMANCE CHECK---------------------------------------------------------------

*Sort based on reuse_table to get the roll names of the table fields which is needed for mapping
  SORT et_reuse_attributes BY reuse_table.

  LOOP AT et_reuse_attributes ASSIGNING <fs_reuse_attribute> .

    READ TABLE lt_used_tables WITH KEY table = <fs_reuse_attribute>-reuse_table TRANSPORTING NO FIELDS .

    IF sy-subrc NE 0.
      CALL FUNCTION 'DDIF_FIELDINFO_GET'
        EXPORTING
          tabname   = <fs_reuse_attribute>-reuse_table
        TABLES
          dfies_tab = lt_dfies.

      APPEND <fs_reuse_attribute>-reuse_table TO lt_used_tables.
    ENDIF.

    READ TABLE lt_dfies INTO ls_dfies WITH KEY  tabname = <fs_reuse_attribute>-reuse_table
    fieldname = <fs_reuse_attribute>-reuse_fieldname .

    IF sy-subrc = 0.
      <fs_reuse_attribute>-rollname = ls_dfies-rollname.
*      IF <fs_reuse_attribute>-reuse_fieldname = gc_reuse_matnr.
      <fs_reuse_attribute>-is_key = ls_dfies-keyflag.
*      ENDIF.
    ENDIF.

  ENDLOOP.

  APPEND LINES OF mt_flex_attributes TO et_reuse_attributes.
  APPEND LINES OF lt_used_tables TO et_reuse_table.
  APPEND LINES OF gt_message TO et_messages.
*  ENDIF.
ENDMETHOD.


METHOD get_join_condition.

  DATA:
    lt_table TYPE tty_reuse_table,
    ls_table TYPE LINE OF tty_reuse_table.

  FIELD-SYMBOLS:
    <ls_reuse_table>     TYPE LINE OF tty_reuse_table,
    <ls_join_conditions> LIKE LINE OF gt_join_conditions,
    <ft_join_conditions> TYPE mdg_hdb_tt_xml_join_table.

  lt_table = it_reuse_table.

  CREATE DATA rt_join_conditions.
  ASSIGN rt_join_conditions->* TO <ft_join_conditions>.

  LOOP AT it_reuse_table ASSIGNING <ls_reuse_table>.
    LOOP AT gt_join_conditions ASSIGNING <ls_join_conditions>
      WHERE right_table = <ls_reuse_table>-table.

      INSERT <ls_join_conditions> INTO TABLE <ft_join_conditions>.
      ls_table-table = <ls_join_conditions>-left_table.
      INSERT ls_table INTO TABLE lt_table.
    ENDLOOP.
  ENDLOOP.

  IF lt_table <> it_reuse_table. "new table for join found
*   start next recursion with all tables
    rt_join_conditions = get_join_condition( it_reuse_table = lt_table ).
  ENDIF.



ENDMETHOD.


METHOD get_join_conditions.

  DATA:
    lt_table             LIKE it_reuse_table,
    ls_table             LIKE LINE OF it_reuse_table.

  FIELD-SYMBOLS:
    <ls_reuse_table>     LIKE LINE OF it_reuse_table,
    <ls_join_conditions> LIKE LINE OF gt_join_conditions.

  lt_table = it_reuse_table.

  LOOP AT it_reuse_table ASSIGNING <ls_reuse_table>.
    LOOP AT gt_join_conditions ASSIGNING <ls_join_conditions>
      WHERE right_table = <ls_reuse_table>-table.

      INSERT <ls_join_conditions> INTO TABLE rt_join_conditions.
      ls_table-table = <ls_join_conditions>-left_table.
      INSERT ls_table INTO TABLE lt_table.
    ENDLOOP.
  ENDLOOP.

  IF lt_table <> it_reuse_table. "new table for join found
*   start next recursion with all tables
    rt_join_conditions = get_join_conditions( it_reuse_table = lt_table ).
  ENDIF.

ENDMETHOD.


  METHOD get_join_cond_for_flex.

    DATA:   ls_join_conditions   TYPE mdg_hdb_s_xml_join_table,
            lt_join_fields       TYPE mdg_atv_xml_join_column_tty,
            ls_join_fields       TYPE mdg_hdb_s_xml_join_column,
            ls_attribute_mapping TYPE gty_s_reuse_attr_map,
            lt_reuse_attributes  TYPE mdg_hdb_tt_reuse_attributes,
            ls_reuse_attribute   TYPE LINE OF mdg_hdb_tt_reuse_attributes,
            lv_reuse_table       TYPE usmd_tab_source.

    FIELD-SYMBOLS :
      <ls_flex_attributes>    TYPE gty_s_reuse_attr_map,
      <ls_reuse_attributes>   TYPE gty_s_reuse_attr_map,
      <ls_entity>             TYPE LINE OF usmd_t_entity,
      <ls_model_data>         TYPE LINE OF mdg_hdb_tt_model_entity_data,
      <ls_model_data_mapping> TYPE LINE OF mdg_hdb_tt_model_entity_data,
      <ls_reuse_field_map>    TYPE mdg_hdb_s_pp_fmap,
      <ls_prop_parent_entity>               TYPE usmd_s_entity_prop_ext.

    CHECK mt_flex_attributes IS NOT INITIAL.
    CHECK mt_entities IS NOT INITIAL.

    LOOP AT mt_flex_attributes  INTO ls_attribute_mapping.
      MOVE-CORRESPONDING ls_attribute_mapping TO ls_reuse_attribute.
      APPEND ls_reuse_attribute TO lt_reuse_attributes.
    ENDLOOP.

    LOOP AT mt_entities ASSIGNING <ls_entity>.

      UNASSIGN : <ls_flex_attributes>, <ls_model_data>." , <ls_join_key>.
      CLEAR : ls_join_conditions, lt_join_fields.

      "get Flex data
      READ TABLE mt_flex_attributes ASSIGNING <ls_flex_attributes> WITH KEY entity = <ls_entity>.
      CHECK sy-subrc  = 0.

      "get Flex entity Parent
      READ TABLE mt_model_data ASSIGNING <ls_model_data> WITH KEY incl_entity = <ls_entity>.

      CHECK sy-subrc = 0.
      " Begin Add Mapping table Join conditon

      " Get Reuse table for parent entity, <ls_model_data>-main_entity  contains parent entity

      READ TABLE mt_reuse_attributes ASSIGNING <ls_reuse_attributes> WITH KEY entity = <ls_model_data>-main_entity.

      IF sy-subrc = 0.
        lv_reuse_table = <ls_reuse_attributes>-reuse_table.
      ELSE.
        READ TABLE mt_fmap ASSIGNING <ls_reuse_field_map> WITH KEY
                        model = gv_model entity = <ls_model_data>-main_entity .
        IF sy-subrc = 0.
          lv_reuse_table = <ls_reuse_field_map>-reuse_table.
        ELSE.

          ASSERT 1 = 0."Unable to find parent entities corresponding reuse table.

        ENDIF.
      ENDIF.

      READ TABLE mo_model_ext->dt_entity_prop ASSIGNING <ls_prop_parent_entity>
                              WITH KEY usmd_entity = <ls_model_data>-main_entity . "main_entity contains Parent Entity

      " Get Mapping Data
      READ TABLE mt_model_data ASSIGNING <ls_model_data_mapping> WITH KEY table_type = 'M'."?

      "Check if Mapping record exists, this would always exists, see if the parent is reuse entity
      IF sy-subrc = 0 AND  <ls_prop_parent_entity>-f_has_pp = abap_true.

        " Get Reuse table
        ls_join_conditions-left_table =  <ls_reuse_attributes>-reuse_table.

        " Get mapping Table
        ls_join_conditions-right_table = <ls_model_data_mapping>-incl_table.
        CONCATENATE <ls_model_data>-main_entity '_' ls_join_conditions-right_table INTO ls_join_conditions-right_table_alias.

        ls_join_conditions-cardinality = 'C1_1'.
        ls_join_conditions-joinoperator = 'Equal'.
        ls_join_conditions-jointype = 'leftOuter'.

        ls_join_fields-left_field = gc_fieldname_mandt.."'MANDT'.
        ls_join_fields-right_field = gc_fieldname_mandt."'MANDT'.

        INSERT ls_join_fields INTO TABLE lt_join_fields.

        ls_join_fields-left_field = 'MATNR'."Field?
        ls_join_fields-right_field = '/1MD/MMMATERIAL'."Staging?

        INSERT ls_join_fields INTO TABLE lt_join_fields.

        ls_join_conditions-t_col = lt_join_fields.

        INSERT ls_join_conditions INTO TABLE ct_join_conditions.
      ENDIF.

      "End Add Mapping table join condition

      " Begin Add join condition for flex table

      CLEAR : ls_join_conditions.
      "Assmuption: this code is only for material, anyway materail always has mapping table.
      "Below needs to be made generic or add code for BP?
      IF <ls_prop_parent_entity>-f_has_pp = abap_true.

        ls_join_conditions-left_table = <ls_model_data_mapping>-incl_table.
        CONCATENATE <ls_model_data>-main_entity '_' ls_join_conditions-left_table INTO ls_join_conditions-left_table_alias.
        ls_join_conditions-right_table = <ls_model_data>-incl_table. "incl_table contains current iteration entity table

        CLEAR : lt_join_fields.

        ls_join_fields-left_field = gc_fieldname_mandt.."'MANDT'.
        ls_join_fields-right_field = gc_fieldname_mandt."'MANDT'.
        INSERT ls_join_fields INTO TABLE lt_join_fields.

        ls_join_fields-left_field = 'USMDKMMMATERIAL'.
        ls_join_fields-right_field = 'USMDKMMMATERIAL'.
        INSERT ls_join_fields INTO TABLE lt_join_fields.

        ls_join_conditions-t_col = lt_join_fields.

        ls_join_conditions-cardinality = 'C1_N'.
        ls_join_conditions-joinoperator = 'Equal'.
        ls_join_conditions-jointype = 'leftOuter'.
        INSERT ls_join_conditions INTO TABLE ct_join_conditions.

      ELSE.

        ls_join_conditions-left_table  =  <ls_model_data>-main_table. "Current Entity Parent Table
        ls_join_conditions-right_table = <ls_model_data>-incl_table. " Current Entity Table

        ls_join_conditions-t_col = <ls_model_data>-join_key.

        ls_join_conditions-cardinality = 'C1_N'.
        ls_join_conditions-joinoperator = 'Equal'.
        ls_join_conditions-jointype = 'leftOuter'.

        INSERT ls_join_conditions INTO TABLE ct_join_conditions.

      ENDIF.

    ENDLOOP.
    SORT ct_join_conditions.
    DELETE ADJACENT DUPLICATES FROM ct_join_conditions.
  ENDMETHOD.


METHOD get_longtext_attr_mapping.

  DATA:
    ls_reuse_attribute  TYPE mdg_hdb_s_reuse_attributes,
    ls_reuse_attribute_ TYPE mdg_hdb_s_reuse_attributes.

  FIELD-SYMBOLS : <ls_model_attributes> TYPE usmd_s_entity_fieldname.

  LOOP AT it_model_attributes ASSIGNING <ls_model_attributes>."change below if cond?
    IF <ls_model_attributes>-usmd_entity =  if_mdg_bs_mat_gen_c=>gc_entity_bscdattxt
                         OR  <ls_model_attributes>-usmd_entity =  if_mdg_bs_mat_gen_c=>gc_entity_mrptxt
                         OR  <ls_model_attributes>-usmd_entity =  if_mdg_bs_mat_gen_c=>gc_entity_salestxt
                         OR  <ls_model_attributes>-usmd_entity =  if_mdg_bs_mat_gen_c=>gc_entity_intcmnt
                         OR  <ls_model_attributes>-usmd_entity =  if_mdg_bs_mat_gen_c=>gc_entity_purchtxt
                         OR  <ls_model_attributes>-usmd_entity =  if_mdg_bs_mat_gen_c=>gc_entity_qinsptxt.


      ls_reuse_attribute-reuse_table = 'MDGHDB_LONGTEXT'."gc_table_mdg_longtext.maintain?
      CONCATENATE <ls_model_attributes>-usmd_entity '_' ls_reuse_attribute-reuse_table INTO  ls_reuse_attribute-reuse_table_alias.

      CONCATENATE <ls_model_attributes>-usmd_entity '_' <ls_model_attributes>-fieldname INTO ls_reuse_attribute-deviating_fieldname.

      ls_reuse_attribute-model_fieldname = <ls_model_attributes>-fieldname.

      ls_reuse_attribute_-reuse_table = ls_reuse_attribute-reuse_table.
      ls_reuse_attribute_-reuse_table_alias = ls_reuse_attribute-reuse_table_alias.

      CASE <ls_model_attributes>-fieldname."need to check case?

        WHEN if_mdg_bs_mat_gen_c=>gc_attr_langucode."'LANGUCODE'.

          ls_reuse_attribute-reuse_fieldname = 'TDSPRAS'."gc_fieldname_tdspras."'TDSPRAS'.?
          ls_reuse_attribute-rollname = 'SPRAS'."gc_rollname_spras."'SPRAS'.?

        WHEN 'NOTEBSCDA'. "gc_fieldname_notebscda ."OR  gc_fieldname_txtmrp OR gc_fieldname_txtsales ?
*              OR gc_fieldname_noteintcm OR gc_fieldname_txtpurch OR gc_fieldname_txtqinsp.

          ls_reuse_attribute-reuse_fieldname = 'LONGTEXT'."gc_fieldname_longtext. "LONGTEXT?
          ls_reuse_attribute-rollname = 'MDGHDB_LONGTXT'."gc_table_mdg_longtext."'MDGHDB_LONGTXT'.?

          "ADD TDID, TDOBJECT for each text type
          ls_reuse_attribute_-reuse_fieldname = if_mdg_bs_mat_gen_c=>gc_fieldname_tdid.
          ls_reuse_attribute_-rollname = if_mdg_bs_mat_gen_c=>gc_fieldname_tdid.
          CONCATENATE <ls_model_attributes>-usmd_entity '_' ls_reuse_attribute_-reuse_fieldname INTO ls_reuse_attribute_-deviating_fieldname.
          ls_reuse_attribute_-filter = 'GRUN'."gc_filter_grun."'GRUN'.?
          INSERT ls_reuse_attribute_ INTO TABLE ct_reuse_attributes.

          ls_reuse_attribute_-reuse_fieldname = 'TDOBJECT'."gc_fieldname_tdobject."'TDOBJECT'.?
          ls_reuse_attribute_-rollname = 'TDOBJECT'."gc_fieldname_tdobject."'TDOBJECT'.?
          CONCATENATE <ls_model_attributes>-usmd_entity '_' ls_reuse_attribute_-reuse_fieldname INTO ls_reuse_attribute_-deviating_fieldname.
          ls_reuse_attribute_-filter = 'MATERIAL'."gc_filter_material."'MATERIAL'. "dynamic?
          INSERT ls_reuse_attribute_ INTO TABLE ct_reuse_attributes.



        WHEN 'TXTMRP'."gc_fieldname_txtmrp.?

          ls_reuse_attribute-reuse_fieldname = 'LONGTEXT'."gc_fieldname_longtext. "LONGTEXT?
          ls_reuse_attribute-rollname = 'MDGHDB_LONGTXT'."gc_table_mdg_longtext."'MDGHDB_LONGTXT'.?

          "ADD TDID, TDOBJECT for each text type
          ls_reuse_attribute_-reuse_fieldname = if_mdg_bs_mat_gen_c=>gc_fieldname_tdid.
          ls_reuse_attribute_-rollname = if_mdg_bs_mat_gen_c=>gc_fieldname_tdid.
          CONCATENATE <ls_model_attributes>-usmd_entity '_' ls_reuse_attribute_-reuse_fieldname INTO ls_reuse_attribute_-deviating_fieldname.
          ls_reuse_attribute_-filter = 'LTXT'."gc_filter_ltxt."'LTXT'.
          INSERT ls_reuse_attribute_ INTO TABLE ct_reuse_attributes.

          ls_reuse_attribute_-reuse_fieldname = 'TDOBJECT'."gc_fieldname_tdobject."'TDOBJECT'.?
          ls_reuse_attribute_-rollname ='TDOBJECT'." gc_fieldname_tdobject."'TDOBJECT'.?
          CONCATENATE <ls_model_attributes>-usmd_entity '_' ls_reuse_attribute_-reuse_fieldname INTO ls_reuse_attribute_-deviating_fieldname.
          ls_reuse_attribute_-filter = 'MDTXT'."gc_filter_mdtxt."'MDTXT'.?
          INSERT ls_reuse_attribute_ INTO TABLE ct_reuse_attributes.

        WHEN 'TXTSALES'."gc_fieldname_txtsales.?
          ls_reuse_attribute-reuse_fieldname = 'LONGTEXT'."gc_fieldname_longtext. "LONGTEXT?
          ls_reuse_attribute-rollname = 'MDGHDB_LONGTXT'."gc_table_mdg_longtext."'MDGHDB_LONGTXT'.?

          "ADD TDID, TDOBJECT for each text type
          ls_reuse_attribute_-reuse_fieldname = if_mdg_bs_mat_gen_c=>gc_fieldname_tdid.
          ls_reuse_attribute_-rollname = if_mdg_bs_mat_gen_c=>gc_fieldname_tdid.
          CONCATENATE <ls_model_attributes>-usmd_entity '_' ls_reuse_attribute_-reuse_fieldname INTO ls_reuse_attribute_-deviating_fieldname.
          ls_reuse_attribute_-filter = '0001'."gc_filter_0001."'0001'.?
          INSERT ls_reuse_attribute_ INTO TABLE ct_reuse_attributes.

          ls_reuse_attribute_-reuse_fieldname = 'TDOBJECT'."gc_fieldname_tdobject."'TDOBJECT'.?
          ls_reuse_attribute_-rollname = 'TDOBJECT'."gc_fieldname_tdobject."'TDOBJECT'.?
          CONCATENATE <ls_model_attributes>-usmd_entity '_' ls_reuse_attribute_-reuse_fieldname INTO ls_reuse_attribute_-deviating_fieldname.
          ls_reuse_attribute_-filter = 'MVKE'."gc_filter_mvke."'MVKE'.?
          INSERT ls_reuse_attribute_ INTO TABLE ct_reuse_attributes.

"similarly other cases?
*        WHEN gc_fieldname_noteintcm.
*          ls_reuse_attribute-reuse_fieldname = gc_fieldname_longtext. "LONGTEXT
*          ls_reuse_attribute-rollname = gc_table_mdg_longtext."'MDGHDB_LONGTXT'.
*
*          "ADD TDID, TDOBJECT for each text type
*          ls_reuse_attribute_-reuse_fieldname = if_mdg_bs_mat_gen_c=>gc_fieldname_tdid.
*          ls_reuse_attribute_-rollname = if_mdg_bs_mat_gen_c=>gc_fieldname_tdid.
*          CONCATENATE <ls_model_attributes>-usmd_entity '_' ls_reuse_attribute_-reuse_fieldname INTO ls_reuse_attribute_-deviating_fieldname.
*          ls_reuse_attribute_-filter = gc_filter_iver."'IVER'.
*          INSERT ls_reuse_attribute_ INTO TABLE ct_reuse_attributes.
*
*          ls_reuse_attribute_-reuse_fieldname = gc_fieldname_tdobject."'TDOBJECT'.
*          ls_reuse_attribute_-rollname = gc_fieldname_tdobject."'TDOBJECT'.
*          CONCATENATE <ls_model_attributes>-usmd_entity '_' ls_reuse_attribute_-reuse_fieldname INTO ls_reuse_attribute_-deviating_fieldname.
*          ls_reuse_attribute_-filter = gc_filter_material."'MATERIAL'.
*          INSERT ls_reuse_attribute_ INTO TABLE ct_reuse_attributes.
*
*        WHEN gc_fieldname_txtpurch.
*
*          ls_reuse_attribute-reuse_fieldname = gc_fieldname_longtext. "LONGTEXT
*          ls_reuse_attribute-rollname = gc_table_mdg_longtext."'MDGHDB_LONGTXT'.
*
*          "ADD TDID, TDOBJECT for each text type
*          ls_reuse_attribute_-reuse_fieldname = if_mdg_bs_mat_gen_c=>gc_fieldname_tdid.
*          ls_reuse_attribute_-rollname = if_mdg_bs_mat_gen_c=>gc_fieldname_tdid.
*          CONCATENATE <ls_model_attributes>-usmd_entity '_' ls_reuse_attribute_-reuse_fieldname INTO ls_reuse_attribute_-deviating_fieldname.
*          ls_reuse_attribute_-filter = gc_filter_best."'BEST'.
*          INSERT ls_reuse_attribute_ INTO TABLE ct_reuse_attributes.
*
*          ls_reuse_attribute_-reuse_fieldname = gc_fieldname_tdobject."'TDOBJECT'.
*          ls_reuse_attribute_-rollname = gc_fieldname_tdobject."'TDOBJECT'.
*          CONCATENATE <ls_model_attributes>-usmd_entity '_' ls_reuse_attribute_-reuse_fieldname INTO ls_reuse_attribute_-deviating_fieldname.
*          ls_reuse_attribute_-filter = gc_filter_material."'MATERIAL'.
*          INSERT ls_reuse_attribute_ INTO TABLE ct_reuse_attributes.
*
*        WHEN gc_fieldname_txtqinsp.
*
*          ls_reuse_attribute-reuse_fieldname = gc_fieldname_longtext. "LONGTEXT
*          ls_reuse_attribute-rollname = gc_table_mdg_longtext."'MDGHDB_LONGTXT'.
*
*          "ADD TDID, TDOBJECT for each text type
*          ls_reuse_attribute_-reuse_fieldname = if_mdg_bs_mat_gen_c=>gc_fieldname_tdid.
*          ls_reuse_attribute_-rollname = if_mdg_bs_mat_gen_c=>gc_fieldname_tdid.
*          CONCATENATE <ls_model_attributes>-usmd_entity '_' ls_reuse_attribute_-reuse_fieldname INTO ls_reuse_attribute_-deviating_fieldname.
*          ls_reuse_attribute_-filter = gc_filter_prue."'PRUE'.
*          INSERT ls_reuse_attribute_ INTO TABLE ct_reuse_attributes.
*
*          ls_reuse_attribute_-reuse_fieldname = gc_fieldname_tdobject."'TDOBJECT'.
*          ls_reuse_attribute_-rollname = gc_fieldname_tdobject."'TDOBJECT'.
*          CONCATENATE <ls_model_attributes>-usmd_entity '_' ls_reuse_attribute_-reuse_fieldname INTO ls_reuse_attribute_-deviating_fieldname.
*          ls_reuse_attribute_-filter = gc_filter_material."'MATERIAL'.
*          INSERT ls_reuse_attribute_ INTO TABLE ct_reuse_attributes.
*
*
*        WHEN if_mdg_bs_mat_gen_c=>gc_attr_vkorg."'VKORG'.
*          ls_reuse_attribute-reuse_fieldname = gc_fieldname_key2.
*          ls_reuse_attribute-rollname = if_mdg_bs_mat_gen_c=>gc_attr_vkorg."'VKORG'.
*
*        WHEN if_mdg_bs_mat_gen_c=>gc_attr_vtweg."'VTWEG'.
*          ls_reuse_attribute-reuse_fieldname = gc_fieldname_key3.
*          ls_reuse_attribute-rollname = if_mdg_bs_mat_gen_c=>gc_attr_vtweg."'VTWEG'.
*
*        WHEN if_mdg_bs_mat_gen_c=>gc_attr_werks. "Werks
*
*          ls_reuse_attribute-reuse_fieldname = gc_fieldname_key2.
*          ls_reuse_attribute-rollname = gc_rollname_werks_d.

      ENDCASE.

      CHECK ls_reuse_attribute-rollname IS NOT INITIAL.

      INSERT ls_reuse_attribute INTO TABLE ct_reuse_attributes.
    ENDIF.
  ENDLOOP.

ENDMETHOD.


METHOD get_longtext_joins.

*  DATA:   ls_join_conditions       TYPE mdg_hdb_s_xml_join_table,
*          lt_join_fields           TYPE mdg_atv_xml_join_column_tty,
*          ls_join_fields           TYPE mdg_hdb_s_xml_join_column,
*          lt_reuse_attributes_ltxt TYPE mdg_hdb_tt_reuse_attributes.
*
*  FIELD-SYMBOLS:
*                  <ls_entity> TYPE usmd_entity.
*
*  LOOP AT it_entities ASSIGNING <ls_entity> WHERE
*                            table_line  =  if_mdg_bs_mat_gen_c=>gc_entity_bscdattxt
*                        OR  table_line  =  if_mdg_bs_mat_gen_c=>gc_entity_mrptxt
*                        OR  table_line  =  if_mdg_bs_mat_gen_c=>gc_entity_salestxt
*                        OR  table_line  =  if_mdg_bs_mat_gen_c=>gc_entity_intcmnt
*                        OR  table_line  =  if_mdg_bs_mat_gen_c=>gc_entity_purchtxt
*                        OR  table_line  =  if_mdg_bs_mat_gen_c=>gc_entity_qinsptxt.
*
*    CLEAR : lt_reuse_attributes_ltxt,
*            ls_join_conditions,
*            lt_join_fields,
*            ls_join_fields.
*
*    ls_join_fields-left_field = gc_fieldname_mandt. "'MANDT'
*    ls_join_fields-right_field = gc_fieldname_mandt. "'MANDT'
*    INSERT ls_join_fields INTO TABLE lt_join_fields.
*
*    ls_join_fields-left_field = if_mdg_bs_mat_gen_c=>gc_objkey_field_matnr."'MATNR'.
*    ls_join_fields-right_field = gc_fieldname_key1."'KEY1'.
*
*    INSERT ls_join_fields INTO TABLE lt_join_fields.
*
*    IF <ls_entity>  =  gc_entity_salestxt.
*
*      ls_join_fields-left_field = if_mdg_bs_mat_gen_c=>gc_attr_vkorg."'VKORG'.
*      ls_join_fields-right_field = gc_fieldname_key2."'KEY2'.
*
*      INSERT ls_join_fields INTO TABLE lt_join_fields.
*
*      ls_join_fields-left_field = if_mdg_bs_mat_gen_c=>gc_attr_vtweg."'VTWEG'.
*      ls_join_fields-right_field = gc_fieldname_key3."'KEY3'.
*
*      INSERT ls_join_fields INTO TABLE lt_join_fields.
*
*      ls_join_conditions-left_table = gc_table_mvke."'MVKE'.
*      CALL METHOD me->add_join_conditions
*        EXPORTING
*          iv_table           = gc_table_mvke
*        CHANGING
*          ct_join_conditions = ct_join_conditions.
*    ELSEIF <ls_entity> = gc_entity_mrptxt.
*
*      ls_join_fields-left_field = if_mdg_bs_mat_gen_c=>gc_attr_werks."'WERKS'.
*      ls_join_fields-right_field = gc_fieldname_key2."'KEY2'.
*      INSERT ls_join_fields INTO TABLE lt_join_fields.
*
*      ls_join_conditions-left_table = gc_table_marc."'MARC'.
*      CALL METHOD me->add_join_conditions
*        EXPORTING
*          iv_table           = gc_table_marc
*        CHANGING
*          ct_join_conditions = ct_join_conditions.
*
*    ELSE.
*      ls_join_conditions-left_table = gc_table_mara.
*    ENDIF.
*
*    ls_join_conditions-right_table = gc_table_mdg_longtext.
*    CONCATENATE <ls_entity> '_' gc_table_mdg_longtext INTO ls_join_conditions-right_table_alias.
*
*    ls_join_conditions-t_col = lt_join_fields.
*
*    ls_join_conditions-cardinality = 'C1_N'.               ##no_text
*    ls_join_conditions-joinoperator = 'Equal'.            ##no_text
*    ls_join_conditions-jointype = 'leftOuter'.            ##no_text
*
*    INSERT ls_join_conditions INTO TABLE ct_join_conditions.
*
*  ENDLOOP.

ENDMETHOD.


METHOD get_mapping.


*-------------------------------------------------- SMT Mapping info based on the report:MDG_BS_MAT_FIND_MODEL_DETAILS ----------------------------------------
*-------------------------------------------------- Code is not modularized in object oriented context ---------------------------------------------------------
*-------------------------------------------------- Makes use of Local classes ---------------------------------------------------------------------------------

  FIELD-SYMBOLS:
    <gs_mapping_details>      TYPE mdg_bs_mat_s_smt_fld_mappinf_d."?

*  SUBMIT MDG_BS_MAT_FIND_MODEL_DETAILS AND RETURN.

  IF iv_model IS INITIAL.
    gv_model = cl_mdg_bs_mat_model=>get_model( )."?
  ELSE.
    gv_model = iv_model.
  ENDIF.


  CALL METHOD cl_mdg_bs_mat_smt=>find_prop_entities
    EXPORTING
      iv_model          = gv_model
      iv_respect_switch = abap_false
    IMPORTING
      et_prop_entities  = gt_attr_and_keys_rest.


* Get the structure of every entity
  CALL METHOD cl_mdg_bs_mat_smt=>get_enties_struc
    EXPORTING
      iv_model        = gv_model
    IMPORTING
      et_entity_struc = gt_entity_struc.


* Merge mapping details for pp and for sta
  CALL METHOD cl_mdg_bs_mat_smt=>merge_mapp_final_enbl
    EXPORTING
      iv_model                = gv_model
    RECEIVING
      rt_merged_mapping_final = gt_merged_mapping_final.



***************
* To active area
***************

  CLEAR:
     gt_all_entity,
     gt_mapped_entity,
     gt_rmapped_entity,
     gt_rnmapped_entity,
     gt_flexmapped_entity,
     gt_flexnmapped_entity,
     gt_flex_entity.
* get mappped reuse not mapped reused and flex entities
  gv_map_to_pp = abap_true.
  CALL METHOD cl_mdg_bs_mat_smt=>get_rmapp_rnmapp_flex_entities
    EXPORTING
      iv_model              = gv_model
      iv_map_to_pp          = gv_map_to_pp
    IMPORTING
      et_all_entity         = gt_all_entity
      et_mapped_entity      = gt_mapped_entity
      et_rmapped_entity     = gt_rmapped_entity
      et_rnmapped_entity    = gt_rnmapped_entity
      et_flexmapped_entity  = gt_flexmapped_entity
      et_flexnmapped_entity = gt_flexnmapped_entity
      et_flex_entity        = gt_flex_entity.


* Find smt-mapping details for entities whose source structure
* is a source structure in the smt mapping
*--------------------------------------------------------------

* get the group
  gv_group = 1.
  LOOP AT gt_merged_mapping_final ASSIGNING <gs_mapping_details>
                                    WHERE   is_mapp_to_pp = abap_true.
    CLEAR:  gv_is_usable_mapping,
            gv_is_used_mapping,
            gv_entity_kind,
            gv_is_compl_trans,
            gv_is_extension,
            gv_entity,
            gv_entity1,
            gv_disabled_entity,
            gv_pp_structure,
            gv_fp_structure,
            gv_fc_structure.

* Preparation: Define some components for the for the output, make some checks
* and generate some messages...
* -----------------------------------------------------------------------------

* Check whether the source structure of the entity in the mapping
* is the generated structure of the entity
    READ TABLE gt_entity_struc INTO gs_entity_struc
                           WITH KEY structure = <gs_mapping_details>-sstructure.

    IF sy-subrc <> 0. " That means that the source structure in mapping is not the one of the entity
      gv_is_usable_mapping = abap_true.
      gv_is_used_mapping = abap_false.
*        gv_entity_kind = 'not defined'(005).
* generate a message
      CLEAR gs_message.
      MESSAGE w011(mdg_bs_mat_tools) INTO gv_message WITH <gs_mapping_details>-event <gs_mapping_details>-smt_appl."standard msg?
      MOVE-CORRESPONDING sy TO gs_message.
      INSERT gs_message INTO TABLE gt_message.
    ELSE. " The entity is mapped
      gv_entity1 = gs_entity_struc-entity.
      APPEND gv_entity1 TO gt_considered_entities.
      CLEAR:
       gv_disabled_entity,
       gv_struc_attr,
       gt_attr_usual,
       gt_enabled_attr_usual,
       gt_disabled_attr_usual,
       gv_struc_txt,
       gt_attr_txt_usual,
       gt_enabled_attr_txt_usual,
       gt_disabled_attr_txt_usual,
       gv_fp_structure,
       gv_fc_structure.
      CALL METHOD cl_mdg_bs_mat_smt=>get_disabling_info_enty
        EXPORTING
          iv_model         = gv_model
          iv_entity        = gv_entity1
        IMPORTING
          ev_disabled      = gv_disabled_entity
          ev_struc_attr    = gv_struc_attr
          et_attr          = gt_attr_usual
          et_enabled_attr  = gt_enabled_attr_usual
          et_disabled_attr = gt_disabled_attr_usual
          ev_struc_txt     = gv_struc_txt
          et_txt           = gt_attr_txt_usual
          et_enabled_txt   = gt_enabled_attr_txt_usual
          et_disabled_txt  = gt_disabled_attr_txt_usual
          ev_fp_struc      = gv_fp_structure
          ev_fc_struc      = gv_fc_structure.

      CALL METHOD lcl_find_model_details=>check_enty_details_in_mapping
        EXPORTING
          iv_entity                  = gv_entity1
          is_txt                     = gs_entity_struc-is_txt
          it_rmapped_entity          = gt_rmapped_entity
          it_flexmapped_entity       = gt_flexmapped_entity
          it_disabled_attr_usual     = gt_disabled_attr_usual
          it_disabled_attr_txt_usual = gt_disabled_attr_txt_usual
          iv_struc_attr              = gv_struc_attr
          iv_struc_txt               = gv_struc_txt
          iv_fc_structure            = gv_fp_structure
          iv_fp_structure            = gv_fc_structure
        IMPORTING
          ev_pp_structure            = gv_pp_structure
          ev_is_usable_mapping       = gv_is_usable_mapping
          ev_is_used_mapping         = gv_is_used_mapping
          ev_entity_kind             = gv_entity_kind
          et_disabled_fields_usual   = gt_disabled_fields_usual
          ev_entity                  = gv_entity
        CHANGING
          ct_message                 = gt_message.
    ENDIF.

* Set the rest components of the output entry depending on the from_field and on
* whether or not the transformation is complex or not
* ------------------------------------------------------------------------
    CALL METHOD lcl_find_model_details=>get_mattr_details_2pp
      EXPORTING
        is_mapping_details       = <gs_mapping_details>
        iv_group                 = gv_group
        iv_entity                = gv_entity1
        iv_entity_h              = gv_entity
        is_entity_struc          = gs_entity_struc
        it_attr                  = gt_attr_usual
        it_txt                   = gt_attr_txt_usual
        iv_pp_structure          = gv_pp_structure
        iv_fc_structure          = gv_fc_structure
        iv_fp_structure          = gv_fp_structure
        iv_is_usable_mapping     = gv_is_usable_mapping
        iv_is_used_mapping       = gv_is_used_mapping
        iv_entity_kind           = gv_entity_kind
        iv_disabled_entity       = gv_disabled_entity
      CHANGING
        ct_disabled_fields_usual = gt_disabled_fields_usual
        ct_attr_and_keys_rest    = gt_attr_and_keys_rest
        ct_data                  = gt_mapping
        ct_message               = gt_message.
    gv_group = gv_group + 1.
  ENDLOOP.

  SORT gt_considered_entities.
  DELETE ADJACENT DUPLICATES FROM gt_considered_entities.

* Add not mapped attributes of previoulsy considered entities to the GT_MAPPING
*----------------------------------------------------------------------------
  CALL METHOD lcl_find_model_details=>get_nmattr_detl_consenties_2pp
    EXPORTING
      iv_model               = gv_model
      it_attr_and_keys_rest  = gt_attr_and_keys_rest
      it_considered_entities = gt_considered_entities
      it_rmapped_entity      = gt_rmapped_entity
      it_flexmapped_entity   = gt_flexmapped_entity
    CHANGING
      ct_data                = gt_mapping
      ct_message             = gt_message.

* get the list of the reuse entities which should have mapping (structures are generated) but which do not have
* SMT mapping. First we add the entries of gt_rnmapped_entity into table gt_rnmapped_entity. The differense betwwen
* this union and thetable of the previously considered entities is the rest of the not mapped reuse entities.

  APPEND LINES OF gt_rmapped_entity TO gt_rnmapped_entity.
  DELETE ADJACENT DUPLICATES FROM gt_rnmapped_entity.

* Consider the rest of the not mapped reuse entities with respect to considered entities
  CALL METHOD lcl_find_model_details=>get_rest_rnmenties_details_2pp
    EXPORTING
      iv_model               = gv_model
      it_considered_entities = gt_considered_entities
      it_rnmapped_entity     = gt_rnmapped_entity
    CHANGING
      ct_data                = gt_mapping
      ct_message             = gt_message.

* Consider the rest of the flex entities (i.e., not mapped flex)
  CALL METHOD lcl_find_model_details=>get_rest_nmflex_details_2pp
    EXPORTING
      iv_model              = gv_model
      it_flexnmapped_entity = gt_flexnmapped_entity
    CHANGING
      ct_data               = gt_mapping
      ct_message            = gt_message.

* Check multiple field-mapping
  CALL METHOD lcl_find_model_details=>check_multiple_field_mapping
    EXPORTING
      iv_model     = gv_model
      iv_map_to_pp = abap_true
      it_data      = gt_mapping
    CHANGING
      ct_message   = gt_message.


* remove dublicates
  SORT gt_message.
  DELETE ADJACENT DUPLICATES FROM gt_mapping.

* if all is OK, generate a succes message
  IF gt_message IS INITIAL.
    CLEAR gs_message.
    MESSAGE i016(mdg_bs_mat_tools) INTO gv_message.
    MOVE-CORRESPONDING sy TO gs_message.
    INSERT gs_message INTO TABLE gt_message.
  ENDIF.

*  APPEND LINES OF GT_MAPPING to et_data.
*  Messages are consolidated and sent back
  APPEND LINES OF gt_message TO et_messages.


*  ET_DATA = GT_MAPPING.
ENDMETHOD.


METHOD get_user_master_records.

  DATA:
        lt_values TYPE ty_t_usvalues,
        ls_value TYPE usvalues.

  CLEAR:et_values, ev_exception.

  CALL FUNCTION 'SUSR_USER_AUTH_FOR_OBJ_GET'
    EXPORTING
*     NEW_BUFFERING       = 3
*     MANDANT             = SY-MANDT
      user_name           = iv_user_name
      sel_object          = iv_sel_object
    TABLES
      values              = lt_values
    EXCEPTIONS
      user_name_not_exist = 1
      not_authorized      = 2
      internal_error      = 3
      OTHERS              = 4.

  et_values = lt_values.
*sort lt_values by field von bis .

  DELETE ADJACENT DUPLICATES FROM lt_values COMPARING objct field von bis.
  DELETE ADJACENT DUPLICATES FROM et_values COMPARING objct field von bis.

  LOOP AT lt_values INTO ls_value WHERE von = '*'.

    DELETE  et_values WHERE field = ls_value-field.

  ENDLOOP.

  IF sy-subrc <> 0.
    ev_exception = sy-subrc.
  ENDIF.

ENDMETHOD.


  METHOD send_teams_notification.
    DATA: lo_http_client     TYPE REF TO if_http_client,
          lv_body            TYPE        string,
          lv_response        TYPE string,
          lv_templatecontent TYPE string,
          lo_conv            TYPE REF TO cl_abap_conv_in_ce.

    cl_mime_repository_api=>get_api( )->get(
      EXPORTING
        i_url                  = '/SAP/PUBLIC/ZMESSAGE_TEMP/teams_notif_template.txt'                 " Object URL
      IMPORTING
        e_content              =   DATA(lv_content_hex)               " Object Contents
      EXCEPTIONS
        parameter_missing      = 1                " Parameter missing or is initial
        error_occured          = 2                " Unspecified Error Occurred
        not_found              = 3                " Object not found
        permission_failure     = 4                " Missing Authorization
        OTHERS                 = 5
    ).
    IF sy-subrc <> 0.
*     MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
*       WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
    ENDIF..
    lo_conv = cl_abap_conv_in_ce=>create( input = lv_content_hex ).

* Convert the HEX to Standard String
    CALL METHOD lo_conv->read
      IMPORTING
        data = lv_templatecontent.
    """"""""WRITE CODE HERE TO replace mime content with CR data and CR URL*************
    REPLACE ALL OCCURRENCES OF '<--CR_NUMBER-->'  IN lv_templatecontent WITH iv_crequest.
    REPLACE ALL OCCURRENCES OF '<--CR_TYPE-->'    IN lv_templatecontent WITH iv_cr_type.
    REPLACE ALL OCCURRENCES OF '<--CR_STATUS-->'  IN lv_templatecontent WITH iv_cr_status.
    REPLACE ALL OCCURRENCES OF '<--ROLE-->'       IN lv_templatecontent WITH iv_role_desc.
    REPLACE ALL OCCURRENCES OF '<--URL-->'     IN lv_templatecontent WITH construct_url( im_cr = iv_crequest ).
    lv_body = lv_templatecontent.
    """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

    """Send notification to microsoft teams
    cl_http_client=>create_by_url(
      EXPORTING
        url    = 'https://deloitte.webhook.office.com/webhookb2/033857f0-8958-4e7a-8b4c-a190631524a4@36da45f1-dd2c-4d1f-af13-5abe46b99921/IncomingWebhook/073cdb299e8e40ceb8207c5b3741911d/7e463a96-da81-4cb5-9b81-40777d762142'
      IMPORTING
        client = lo_http_client
    ).
    "setting request method
    lo_http_client->request->set_method('POST').
    lo_http_client->request->set_header_field( name = 'Content-Type' value = 'application/json' ).

    lo_http_client->request->set_cdata(
      EXPORTING
        data = lv_body ).

    lo_http_client->send(
      EXCEPTIONS
        http_communication_failure = 1
        http_invalid_state         = 2
        http_processing_failed     = 3
        http_invalid_timeout       = 4
        OTHERS                     = 5 ).

    lo_http_client->receive(
      EXCEPTIONS
        http_communication_failure = 1
        http_invalid_state         = 2
        http_processing_failed     = 3
        OTHERS                     = 4
    ).

    lv_response = lo_http_client->response->get_cdata( ).

  ENDMETHOD.


  METHOD set_reuse_mapping.

    IF gt_reuse_fmap IS NOT INITIAL OR gt_join_conditions IS NOT INITIAL.
      RETURN.
    ENDIF.

    CLEAR: gt_reuse_fmap, gt_join_conditions.

    gt_reuse_fmap      = cl_mdg_hdb_reuse_mapping=>get_field_mapping( iv_model ).
    gt_join_conditions = cl_mdg_hdb_reuse_mapping=>get_join_conditions( iv_otc ).

  ENDMETHOD.
ENDCLASS.
